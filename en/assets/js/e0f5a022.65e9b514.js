"use strict";(self.webpackChunkditsmod_github_io=self.webpackChunkditsmod_github_io||[]).push([[528],{2144:(e,o,t)=>{t.r(o),t.d(o,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"basic-components-of-the-app/module","title":"Modules","description":"One of the key elements of the Ditsmod architecture is its modules. But what exactly makes a modular architecture so advantageous? \u2014 Modularity allows you to compose various autonomous elements and assemble a scalable application from them. Thanks to the autonomy of modules, large projects are easier to develop, test, deploy, and maintain. Modularity also simplifies the transition to a microservices architecture if, in the future, you decide that your Ditsmod application requires horizontal scaling.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/00-basic-components-of-the-app/02-module.md","sourceDirName":"00-basic-components-of-the-app","slug":"/basic-components-of-the-app/module","permalink":"/en/basic-components-of-the-app/module","draft":false,"unlisted":false,"editUrl":"https://github.com/ditsmod/ditsmod/edit/main/website/i18n/en/docusaurus-plugin-content-docs/current/00-basic-components-of-the-app/02-module.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Dependency Injection","permalink":"/en/basic-components-of-the-app/dependency-injection"},"next":{"title":"Init Decorators and Init Hooks","permalink":"/en/basic-components-of-the-app/init-decorators"}}');var n=t(4848),r=t(8453);const i={sidebar_position:2},a="Modules",l={},d=[{value:"Root module",id:"root-module",level:2},{value:"Feature module",id:"feature-module",level:2}];function c(e){const o={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(o.header,{children:(0,n.jsx)(o.h1,{id:"modules",children:"Modules"})}),"\n",(0,n.jsx)(o.p,{children:"One of the key elements of the Ditsmod architecture is its modules. But what exactly makes a modular architecture so advantageous? \u2014 Modularity allows you to compose various autonomous elements and assemble a scalable application from them. Thanks to the autonomy of modules, large projects are easier to develop, test, deploy, and maintain. Modularity also simplifies the transition to a microservices architecture if, in the future, you decide that your Ditsmod application requires horizontal scaling."}),"\n",(0,n.jsxs)(o.p,{children:["A modular architecture makes it possible to isolate ",(0,n.jsx)(o.strong,{children:"several code files"})," within a single module that may have different roles but a ",(0,n.jsx)(o.strong,{children:"shared specialization"}),". A module can be compared to an orchestra, where there are different instruments, but all of them create a shared piece of music. On the other hand, the need to isolate different modules arises because they may have different specializations and, as a result, may interfere with one another. Continuing the analogy with people, if you place police officers and musicians, or brokers and translators, in the same office, they will most likely interfere with each other. That is why ",(0,n.jsx)(o.strong,{children:"narrow specialization"})," is important for a module."]}),"\n",(0,n.jsx)(o.p,{children:"Modules are the largest building blocks of an application, and their metadata can declare components such as:"}),"\n",(0,n.jsxs)(o.ul,{children:["\n",(0,n.jsx)(o.li,{children:"controllers that accept HTTP requests and send HTTP responses;"}),"\n",(0,n.jsx)(o.li,{children:"services where the business logic of the application is described;"}),"\n",(0,n.jsx)(o.li,{children:"interceptors and guards that allow you to automate the processing of HTTP requests according to typical patterns;"}),"\n",(0,n.jsx)(o.li,{children:"decorators and extensions that allow you to add new rules and behaviors to the application;"}),"\n",(0,n.jsx)(o.li,{children:"other classes, interfaces, helpers, data types intended for the operation of the current module."}),"\n"]}),"\n",(0,n.jsx)(o.p,{children:"There are two types of modules:"}),"\n",(0,n.jsxs)(o.ol,{children:["\n",(0,n.jsx)(o.li,{children:"Root module."}),"\n",(0,n.jsx)(o.li,{children:"Feature module. Most often, this type of module is used for publishing on npmjs.com."}),"\n"]}),"\n",(0,n.jsx)(o.h2,{id:"root-module",children:"Root module"}),"\n",(0,n.jsxs)(o.p,{children:["Other modules are attached to the root module; it is the only one for the entire application, and its class is recommended to be named ",(0,n.jsx)(o.code,{children:"AppModule"}),". A TypeScript class becomes a Ditsmod root module by using one of the decorators such as ",(0,n.jsx)(o.code,{children:"rootModule"}),", ",(0,n.jsx)(o.code,{children:"restRootModule"}),", ",(0,n.jsx)(o.code,{children:"trpcRootModule"}),", etc., depending on the architectural style you are using. For example, if you are using REST, the root module is declared as follows:"]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"import { restRootModule } from '@ditsmod/rest';\n\n@restRootModule()\nexport class AppModule {}\n"})}),"\n",(0,n.jsxs)(o.p,{children:["In general, an object with the following properties can be passed to the ",(0,n.jsx)(o.code,{children:"restRootModule"})," decorator:"]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"import { restRootModule } from '@ditsmod/rest';\n\n@restRootModule({\n  imports: [], // Imported modules\n  appends: [], // Appending modules that have controllers\n  providersPerApp: [], // Providers at the application level\n  providersPerMod: [], //         ...at the module level\n  providersPerRou: [], //         ...at the route level\n  providersPerReq: [], //         ...at the HTTP request level\n  exports: [], // Exported modules and providers from the current module\n  extensions: [], // Extensions\n  extensionsMeta: {}, // Data for extensions\n  resolvedCollisionsPerApp: [], // Resolution of imported class collisions at the application level\n  resolvedCollisionsPerMod: [], //                                   ...at the module level\n  resolvedCollisionsPerRou: [], //                                   ...at the route level\n  resolvedCollisionsPerReq: [], //                                   ...at the HTTP request level\n  controllers: [], // List of controllers in the current module\n})\nexport class AppModule {}\n"})}),"\n",(0,n.jsx)(o.h2,{id:"feature-module",children:"Feature module"}),"\n",(0,n.jsxs)(o.p,{children:["A TypeScript class becomes a Ditsmod feature module thanks to one of the following decorators: ",(0,n.jsx)(o.code,{children:"featureModule"}),", ",(0,n.jsx)(o.code,{children:"restModule"}),", ",(0,n.jsx)(o.code,{children:"trpcModule"}),", etc., depending on the architectural style you are using. For example, if you are using REST, the root module is declared as follows:"]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"import { restModule } from '@ditsmod/rest';\n\n@restModule()\nexport class SomeModule {}\n"})}),"\n",(0,n.jsxs)(o.p,{children:["It is recommended that module files end with ",(0,n.jsx)(o.code,{children:"*.module.ts"})," and that their class names end with ",(0,n.jsx)(o.code,{children:"*Module"}),"."]}),"\n",(0,n.jsxs)(o.p,{children:["It can contain exactly the same metadata as root modules, except for the ",(0,n.jsx)(o.code,{children:"resolvedCollisionsPerApp"})," property. In addition to being declared directly in the application, feature module can also be published on npmjs.com."]})]})}function u(e={}){const{wrapper:o}={...(0,r.R)(),...e.components};return o?(0,n.jsx)(o,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},8453:(e,o,t)=>{t.d(o,{R:()=>i,x:()=>a});var s=t(6540);const n={},r=s.createContext(n);function i(e){const o=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function a(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),s.createElement(r.Provider,{value:o},e.children)}}}]);