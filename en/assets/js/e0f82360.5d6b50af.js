"use strict";(self.webpackChunkditsmod_github_io=self.webpackChunkditsmod_github_io||[]).push([[9],{2813:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"components-of-ditsmod-app/controllers-and-services","title":"Router, controllers and services","description":"What does a router do?","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/00-components-of-ditsmod-app/02-controllers-and-services.md","sourceDirName":"00-components-of-ditsmod-app","slug":"/components-of-ditsmod-app/controllers-and-services","permalink":"/en/components-of-ditsmod-app/controllers-and-services","draft":false,"unlisted":false,"editUrl":"https://github.com/ditsmod/ditsmod/edit/main/website/i18n/en/docusaurus-plugin-content-docs/current/00-components-of-ditsmod-app/02-controllers-and-services.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Modules","permalink":"/en/components-of-ditsmod-app/module"},"next":{"title":"HTTP Interceptors","permalink":"/en/components-of-ditsmod-app/http-interceptors"}}');var t=n(4848),s=n(8453);const i={sidebar_position:3},c="Router, controllers and services",l={},d=[{value:"What does a router do?",id:"what-does-a-router-do",level:2},{value:"What is a controller",id:"what-is-a-controller",level:2},{value:"Injector-scoped controller",id:"injector-scoped-controller",level:3},{value:"Routing parameters",id:"routing-parameters",level:4},{value:"Context-scoped controller",id:"context-scoped-controller",level:3},{value:"Controller injector hierarchy",id:"controller-injector-hierarchy",level:3},{value:"Binding of the controller to the host module",id:"binding-of-the-controller-to-the-host-module",level:2},{value:"Services",id:"services",level:2},{value:"Service injector hierarchy",id:"service-injector-hierarchy",level:3},{value:"Transfer of providers to the DI registry",id:"transfer-of-providers-to-the-di-registry",level:2},{value:"Re-adding providers",id:"re-adding-providers",level:2}];function a(e){const r={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.header,{children:(0,t.jsx)(r.h1,{id:"router-controllers-and-services",children:"Router, controllers and services"})}),"\n",(0,t.jsx)(r.h2,{id:"what-does-a-router-do",children:"What does a router do?"}),"\n",(0,t.jsxs)(r.p,{children:["A router maps URLs to the appropriate request handler. For example, when users request URLs like ",(0,t.jsx)(r.code,{children:"/some-path"}),", ",(0,t.jsx)(r.code,{children:"/other-path"}),", or ",(0,t.jsx)(r.code,{children:"/path-with/:parameter"})," from their browser, they are informing the Ditsmod application that they want to access a specific resource or perform an action on the website. To enable the Ditsmod application to respond appropriately in these cases, you need to define the corresponding request handlers in the code. So, if ",(0,t.jsx)(r.code,{children:"/some-path"})," is requested, a specific function is executed; if ",(0,t.jsx)(r.code,{children:"/other-path"})," is requested, a different function is triggered, and so on. This process of defining the relationship between a URL and its handler is known as URL-to-handler mapping."]}),"\n",(0,t.jsx)(r.p,{children:"Although you won't have to manually write this mapping, for a general understanding of how a router works, it can be simplified like this:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",children:"const routes = new Map<string, Function>();\nroutes.set('/some-path', function() { /** request handling... **/ });\nroutes.set('/other-path', function() { /** request handling... **/ });\nroutes.set('/path-with/:parameter', function() { /** request handling... **/ });\n// ...\n"})}),"\n",(0,t.jsxs)(r.p,{children:["Right after Node.js receives an HTTP request and passes it to Ditsmod, the request URL is split into two parts separated by a question mark (if present). The first part always contains the so-called ",(0,t.jsx)(r.em,{children:"path"}),", while the second part contains the ",(0,t.jsx)(r.em,{children:"query parameters"}),", if the URL included a question mark."]}),"\n",(0,t.jsxs)(r.p,{children:["The router's task is to find the HTTP request handler by ",(0,t.jsx)(r.em,{children:"path"}),". In a very simplified form, this process can be imagined as follows:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",children:"const path = '/some-path';\nconst handle = routes.get(path);\n\n// ...\n// And then this handler is called in a function that listens for HTTP requests.\nif (handle) {\n  handle();\n}\n"})}),"\n",(0,t.jsx)(r.p,{children:"In most cases, the request handler calls the controller method."}),"\n",(0,t.jsx)(r.h2,{id:"what-is-a-controller",children:"What is a controller"}),"\n",(0,t.jsxs)(r.p,{children:["The mapping between the URL and the request handler is based on the metadata attached to the controller methods. A TypeScript class becomes a Ditsmod controller thanks to the ",(0,t.jsx)(r.code,{children:"controller"})," decorator:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:"{3}",children:"import { controller, route } from '@ditsmod/rest';\n\n@controller()\nexport class SomeController {\n  @route('GET', 'hello')\n  method1() {\n    // ...\n  }\n}\n"})}),"\n",(0,t.jsxs)(r.p,{children:["It is recommended that controller files end with ",(0,t.jsx)(r.code,{children:"*.controller.ts"})," and their class names end with ",(0,t.jsx)(r.code,{children:"*Controller"}),"."]}),"\n",(0,t.jsx)(r.p,{children:"As can be seen from the previous example, any controller must have:"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsx)(r.li,{children:"A class method that will be invoked during an HTTP request."}),"\n",(0,t.jsxs)(r.li,{children:["The HTTP method name (",(0,t.jsx)(r.code,{children:"GET"}),", ",(0,t.jsx)(r.code,{children:"POST"}),", ",(0,t.jsx)(r.code,{children:"PATCH"}),", etc.)."]}),"\n",(0,t.jsx)(r.li,{children:"The URL to which the class method call will be bound (optionally)."}),"\n"]}),"\n",(0,t.jsxs)(r.p,{children:["The combination of the second and third points must be unique across the entire application. In other words, if you define that ",(0,t.jsx)(r.code,{children:"GET"})," + ",(0,t.jsx)(r.code,{children:"/hello"})," is bound to a specific controller method, this combination must not be reused. Otherwise, the ",(0,t.jsx)(r.code,{children:"@ditsmod/rest"})," module will throw an error with an appropriate message."]}),"\n",(0,t.jsx)(r.p,{children:"Ditsmod provides controllers in two alternative modes, which differ in particular in the mechanism for passing the HTTP request to the controller method:"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Injector-scoped controller"})," (default). A controller method can receive any number of arguments from the ",(0,t.jsx)(r.a,{href:"/components-of-ditsmod-app/dependency-injection/#injector-and-providers",children:"DI injector"}),". These arguments can include an HTTP request."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Context-scoped controller"}),". The controller method receives a single argument - the request context, which includes the HTTP request."]}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:"The first mode is more convenient and safer when working within the context of the current HTTP request (e.g., when the client provides a specific identifier that must be considered when forming the response). The second mode is noticeably faster (approximately 15\u201320%) and consumes less memory, but the request context cannot be stored in the instance properties of the controller, as this instance may be used simultaneously for other clients."}),"\n",(0,t.jsx)(r.h3,{id:"injector-scoped-controller",children:"Injector-scoped controller"}),"\n",(0,t.jsxs)(r.p,{children:["By default, Ditsmod works with the controller in injector-scoped mode. This means, first, that a separate controller instance will be created for each HTTP request. Second, any controller method that has a ",(0,t.jsx)(r.code,{children:"route"})," decorator will receive an arbitrary number of arguments from the ",(0,t.jsx)(r.a,{href:"/components-of-ditsmod-app/dependency-injection/#injector-and-providers",children:"DI injector"}),". The following example creates a single route that accepts a ",(0,t.jsx)(r.code,{children:"GET"})," request at ",(0,t.jsx)(r.code,{children:"/hello"}),":"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:"{7}",children:"import { controller, route, Res } from '@ditsmod/rest';\nimport { Service1 } from './service-1';\nimport { Service2 } from './service-2';\n\n@controller()\nexport class HelloWorldController {\n  @route('GET', 'hello')\n  method1(service1: Service1, service2: Service2, res: Res) {\n    // Working with service1 and service2\n    // ...\n    res.send('Hello, World!');\n  }\n}\n"})}),"\n",(0,t.jsx)(r.p,{children:"What we see here:"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:["A route is created using the ",(0,t.jsx)(r.code,{children:"route"})," decorator, which is placed before a class method, and the method's name doesn't matter."]}),"\n",(0,t.jsxs)(r.li,{children:["In this controller mode, the class method can declare any number of parameters. In this case, we declared three parameters: ",(0,t.jsx)(r.code,{children:"service1"})," of type ",(0,t.jsx)(r.code,{children:"Service1"}),", ",(0,t.jsx)(r.code,{children:"service2"})," of type ",(0,t.jsx)(r.code,{children:"Service2"}),", and ",(0,t.jsx)(r.code,{children:"res"})," of type ",(0,t.jsx)(r.code,{children:"Res"}),". This way, we are instructing Ditsmod to create instances of these classes based on their types and pass them to the corresponding variables. By the way, ",(0,t.jsx)(r.code,{children:"res"})," is short for ",(0,t.jsx)(r.em,{children:"response"}),"."]}),"\n",(0,t.jsxs)(r.li,{children:["Text responses to HTTP requests are sent using ",(0,t.jsx)(r.code,{children:"res.send()"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(r.p,{children:["Although in the previous example the class instances were injected into ",(0,t.jsx)(r.code,{children:"method1"}),", we can request these instances in the constructor in the same way:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:"{7}",children:"import { controller, Res, route } from '@ditsmod/rest';\nimport { Service1 } from './service-1';\nimport { Service2 } from './service-2';\n\n@controller()\nexport class HelloWorldController {\n  constructor(private service1: Service1, private service2: Service2, private res: Res) {}\n\n  @route('GET', 'hello')\n  method1() {\n    // Working with this.service1 and this.service2\n    // ...\n    this.res.send('Hello, World!');\n  }\n}\n"})}),"\n",(0,t.jsx)(r.p,{children:"Of course, other instances of classes can be requested in the parameters, and the order of the parameters is not important."}),"\n",(0,t.jsx)(r.admonition,{title:"Use the access modifier",type:"tip",children:(0,t.jsxs)(r.p,{children:["The access modifier in the constructor can be any of the following: ",(0,t.jsx)(r.code,{children:"private"}),", ",(0,t.jsx)(r.code,{children:"protected"}),", or ",(0,t.jsx)(r.code,{children:"public"}),". However, if no modifier is specified, the parameters will only be visible within the constructor (they will not be accessible in the methods)."]})}),"\n",(0,t.jsx)(r.h4,{id:"routing-parameters",children:"Routing parameters"}),"\n",(0,t.jsxs)(r.p,{children:["To pass path parameters to the router, you need to use a colon before the parameter name. For example, the URL ",(0,t.jsx)(r.code,{children:"some-url/:param1/:param2"})," includes two path parameters. If you are using the ",(0,t.jsx)(r.code,{children:"@ditsmod/rest"})," module for routing, only path parameters determine the routes, while query parameters are not taken into account."]}),"\n",(0,t.jsxs)(r.p,{children:["To access path or query parameters, you need to use the ",(0,t.jsx)(r.code,{children:"inject"})," decorator along with the ",(0,t.jsx)(r.code,{children:"PATH_PARAMS"})," and ",(0,t.jsx)(r.code,{children:"QUERY_PARAMS"})," tokens:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:"{8-9}",children:"import { inject, AnyObj } from '@ditsmod/core';\nimport { controller, route, PATH_PARAMS, QUERY_PARAMS } from '@ditsmod/rest';\n\n@controller()\nexport class SomeController {\n  @route('GET', 'some-url/:param1/:param2')\n  method1(\n    @inject(PATH_PARAMS) pathParams: AnyObj,\n    @inject(QUERY_PARAMS) queryParams: AnyObj\n  ) {\n    return ({ pathParams, queryParams });\n  }\n}\n"})}),"\n",(0,t.jsxs)(r.p,{children:["You can find more information about what a token is and what the ",(0,t.jsx)(r.code,{children:"inject"})," decorator does in the ",(0,t.jsx)(r.a,{href:"/components-of-ditsmod-app/dependency-injection/#injector-and-providers",children:"Dependency Injection"})," section."]}),"\n",(0,t.jsxs)(r.p,{children:["As you can see from the previous example, responses to HTTP requests can also be sent using the regular ",(0,t.jsx)(r.code,{children:"return"}),"."]}),"\n",(0,t.jsxs)(r.p,{children:["Native Node.js request and response objects can be obtained by tokens, respectively - ",(0,t.jsx)(r.code,{children:"RAW_REQ"})," and ",(0,t.jsx)(r.code,{children:"RAW_RES"}),":"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:"{7-8}",children:"import { inject } from '@ditsmod/core';\nimport { controller, route, RAW_REQ, RAW_RES, RawRequest, RawResponse } from '@ditsmod/rest';\n\n@controller()\nexport class HelloWorldController {\n  constructor(\n    @inject(RAW_REQ) private rawReq: RawRequest,\n    @inject(RAW_RES) private rawRes: RawResponse\n  ) {}\n\n  @route('GET', 'hello')\n  method1() {\n    this.rawRes.end('Hello, World!');\n  }\n}\n"})}),"\n",(0,t.jsxs)(r.p,{children:["You may also be interested in ",(0,t.jsx)(r.a,{href:"/native-modules/body-parser#retrieving-the-request-body",children:"how to get the HTTP request body"}),"."]}),"\n",(0,t.jsx)(r.h3,{id:"context-scoped-controller",children:"Context-scoped controller"}),"\n",(0,t.jsxs)(r.p,{children:["To make a controller operate in the context-scoped mode, you need to specify ",(0,t.jsx)(r.code,{children:"{ scope: 'ctx' }"})," in its metadata. Because the controller is instantiated in this mode only once, you will not be able to query in its constructor for class instances that are instantiated on each request. For example, if you request an instance of the ",(0,t.jsx)(r.code,{children:"Res"})," class in the constructor, Ditsmod will throw an error:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:"{3,5}",children:"import { RequestContext, controller, route } from '@ditsmod/rest';\n\n@controller({ scope: 'ctx' })\nexport class HelloWorldController {\n  constructor(private res: Res) {}\n\n  @route('GET', 'hello')\n  method1() {\n    this.res.send('Hello, World!');\n  }\n}\n"})}),"\n",(0,t.jsx)(r.p,{children:"The working case will be as follows:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:"{3,6}",children:"import { controller, RequestContext, route } from '@ditsmod/rest';\n\n@controller({ scope: 'ctx' })\nexport class HelloWorldController {\n  @route('GET', 'hello')\n  method1(ctx: RequestContext) {\n    ctx.send('Hello, World!');\n  }\n}\n"})}),"\n",(0,t.jsx)(r.p,{children:'In the "context-scoped" mode, controller methods bound to specific routes receive a single argument - the request context. That is, in this mode you will no longer be able to declare other method parameters. However, in the constructor you can still declare an arbitrary number of parameters that are created only once.'}),"\n",(0,t.jsx)(r.h3,{id:"controller-injector-hierarchy",children:"Controller injector hierarchy"}),"\n",(0,t.jsxs)(r.p,{children:["A controller ",(0,t.jsx)(r.a,{href:"#injector-scoped-controller",children:"in injector-scoped mode"}),", besides its own injector at the request level, also has three parent injectors: at the route level, module level and application level. These injectors are also formed based on the providers that you pass into the following arrays:"]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"providersPerApp"}),";"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"providersPerMod"}),";"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"providersPerRou"}),";"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"providersPerReq"})," (this array forms the injector for a controller in injector-scoped mode)."]}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:"Thus a controller in injector-scoped mode can depend on services at any level."}),"\n",(0,t.jsxs)(r.p,{children:["If a controller is ",(0,t.jsx)(r.a,{href:"#context-scoped-controller",children:"in context-scoped mode"}),", its own injector is located at the module level, and it has one parent injector at the application level:"]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"providersPerApp"}),";"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"providersPerMod"})," (this array forms the injector for a controller in context-scoped mode)."]}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"binding-of-the-controller-to-the-host-module",children:"Binding of the controller to the host module"}),"\n",(0,t.jsxs)(r.p,{children:["Any controller should only be bound to the current module where it was declared, i.e. the host module. This binding is done via the ",(0,t.jsx)(r.code,{children:"controllers"})," array:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:"{4}",children:"import { restModule } from '@ditsmod/rest';\nimport { SomeController } from './some.controller.js';\n\n@restModule({ controllers: [SomeController] })\nexport class SomeModule {}\n"})}),"\n",(0,t.jsxs)(r.p,{children:["After binding controllers to the host module, in order for Ditsmod to recognize them in an external module, the host module must either be appended or imported as an object that implements the ",(0,t.jsx)(r.a,{href:"/developer-guides/exports-and-imports#ModuleWithParams",children:"ModuleWithParams"})," interface. The following example shows both appending and fully importing the host module (this is done only to demonstrate the possibility; in practice, there is no reason to do both at the same time):"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:"{5,7}",children:"import { restModule } from '@ditsmod/rest';\nimport { SomeModule } from './some.module.js';\n\n@restModule({\n  appends: [SomeModule],\n  // OR\n  imports: [{ module: SomeModule, path: '' }]\n})\nexport class OtherModule {}\n"})}),"\n",(0,t.jsxs)(r.p,{children:["If the module is imported without the ",(0,t.jsx)(r.code,{children:"path"})," property, Ditsmod will only import ",(0,t.jsx)(r.a,{href:"/components-of-ditsmod-app/dependency-injection/#injector-and-providers",children:"providers"})," and ",(0,t.jsx)(r.a,{href:"/components-of-ditsmod-app/extensions/",children:"extensions"})," from it:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:"{5}",children:"import { restModule } from '@ditsmod/rest';\nimport { SomeModule } from './some.module.js';\n\n@restModule({\n  imports: [SomeModule]\n})\nexport class OtherModule {}\n"})}),"\n",(0,t.jsxs)(r.p,{children:["You can read more detailed information in the section ",(0,t.jsx)(r.a,{href:"/developer-guides/exports-and-imports#import-module",children:"Export, import and appends of modules"}),"."]}),"\n",(0,t.jsx)(r.h2,{id:"services",children:"Services"}),"\n",(0,t.jsxs)(r.p,{children:["While it's technically possible to get by with just one controller to handle an HTTP request, it's better to separate the extensive business logic code into separate classes so that the code can be reused as needed and is easier to test. These separate classes with business logic are usually called ",(0,t.jsx)(r.em,{children:"services"}),"."]}),"\n",(0,t.jsx)(r.p,{children:"What services can do:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"check access rights;"}),"\n",(0,t.jsx)(r.li,{children:"validate the request;"}),"\n",(0,t.jsx)(r.li,{children:"provide configuration;"}),"\n",(0,t.jsx)(r.li,{children:"parsing the request body;"}),"\n",(0,t.jsx)(r.li,{children:"work with databases, with email;"}),"\n",(0,t.jsx)(r.li,{children:"etc."}),"\n"]}),"\n",(0,t.jsxs)(r.p,{children:["Any TypeScript class can be a Ditsmod service, but if you want ",(0,t.jsx)(r.a,{href:"/components-of-ditsmod-app/dependency-injection/",children:"DI"})," to resolve the dependency you specify in the constructors of these classes, you must specify the ",(0,t.jsx)(r.code,{children:"injectable"})," decorator before them:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:"{4,6}",children:"import { injectable } from '@ditsmod/core';\nimport { FirstService } from './first.service.js';\n\n@injectable()\nexport class SecondService {\n  constructor(private firstService: FirstService) {}\n\n  methodOne() {\n    this.firstService.doSomeThing();\n  }\n}\n"})}),"\n",(0,t.jsxs)(r.p,{children:["It is recommended that service files end with ",(0,t.jsx)(r.code,{children:"*.service.ts"}),", and their classes end with ",(0,t.jsx)(r.code,{children:"*Service"}),"."]}),"\n",(0,t.jsxs)(r.p,{children:["As you can see, the rules for getting a class instance in the constructor are the same as in controllers: using the ",(0,t.jsx)(r.code,{children:"private"})," access modifier, we declare a property of the ",(0,t.jsx)(r.code,{children:"firstService"})," class with the ",(0,t.jsx)(r.code,{children:"FirstService"})," data type."]}),"\n",(0,t.jsxs)(r.p,{children:["To be able to use the newly created service classes, they must be passed in the metadata of the ",(0,t.jsx)(r.strong,{children:"current"})," module or controller. You can pass the services in the module metadata as follows:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:"{8-9}",children:"import { restModule } from '@ditsmod/rest';\n\nimport { FirstService } from './first.service.js';\nimport { SecondService } from './second.service.js';\n\n@restModule({\n  providersPerReq: [\n    FirstService,\n    SecondService\n  ],\n})\nexport class SomeModule {}\n"})}),"\n",(0,t.jsx)(r.p,{children:"Similarly, the services is passed in the controller metadata:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:"{8-9}",children:"import { controller, Res, route } from '@ditsmod/rest';\n\nimport { FirstService } from './first.service.js';\nimport { SecondService } from './second.service.js';\n\n@controller({\n  providersPerReq: [\n    FirstService,\n    SecondService\n  ],\n})\nexport class SomeController {\n  @route('GET', 'hello')\n  method1(res: Res, secondService: SecondService) {\n    res.send(secondService.sayHello());\n  }\n}\n"})}),"\n",(0,t.jsxs)(r.p,{children:["In the last two examples, the services is passed to the ",(0,t.jsx)(r.code,{children:"providersPerReq"})," array, but this is not the only way to pass services. For more information about the rules of working with DI, see ",(0,t.jsx)(r.a,{href:"/components-of-ditsmod-app/dependency-injection/",children:"Dependency Injection"}),"."]}),"\n",(0,t.jsx)(r.h3,{id:"service-injector-hierarchy",children:"Service injector hierarchy"}),"\n",(0,t.jsxs)(r.p,{children:["Unlike a controller, the injector of a given service can be at any level: at the application level, module level, route level, or request level. In practice, this means that the provider for a given service is passed into one (or several) ",(0,t.jsx)(r.code,{children:"providersPer*"})," arrays. For example, in the following example ",(0,t.jsx)(r.code,{children:"SomeService"})," is passed into the injector at the route level, and ",(0,t.jsx)(r.code,{children:"OtherService"})," \u2014 into the module level:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:"{5-6}",children:"import { Injector } from '@ditsmod/core';\n// ...\n\nconst providersPerApp = [];\nconst providersPerMod = [OtherService];\nconst providersPerRou = [SomeService];\nconst providersPerReq = [];\n\nconst injectorPerApp = Injector.resolveAndCreate(providersPerApp);\nconst injectorPerMod = injectorPerApp.resolveAndCreateChild(providersPerMod);\nconst injectorPerRou = injectorPerMod.resolveAndCreateChild(providersPerRou);\nconst injectorPerReq = injectorPerRou.resolveAndCreateChild(providersPerReq);\n"})}),"\n",(0,t.jsxs)(r.p,{children:["In this case, if ",(0,t.jsx)(r.code,{children:"SomeService"})," has a dependency on ",(0,t.jsx)(r.code,{children:"OtherService"}),", DI will be able to create an instance of ",(0,t.jsx)(r.code,{children:"SomeService"}),", because the injector at the route level can obtain an instance of ",(0,t.jsx)(r.code,{children:"OtherService"})," from its parent injector at the module level. However, if ",(0,t.jsx)(r.code,{children:"OtherService"})," depends on ",(0,t.jsx)(r.code,{children:"SomeService"}),", DI will not be able to create an instance of ",(0,t.jsx)(r.code,{children:"OtherService"}),", because the injector at the module level does not see its child injector at the route level."]}),"\n",(0,t.jsxs)(r.p,{children:["The following example shows four different ways to request an instance of ",(0,t.jsx)(r.code,{children:"SomeService"})," using ",(0,t.jsx)(r.code,{children:"injectorPer*.get()"})," directly or via class method parameters:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",children:"injectorPerRou.get(SomeService); // Injector per route.\n// OR\ninjectorPerReq.get(SomeService); // Injector per request.\n// OR\n@injectable()\nclass Service1 {\n  constructor(private someService: SomeService) {} // Constructor's parameters.\n}\n// OR\n@controller()\nclass controller1 {\n  @route('GET', 'some-path')\n  method1(someService: SomeService) {} // Method's parameters.\n}\n"})}),"\n",(0,t.jsxs)(r.p,{children:["Here it is important to remember the following rule: the value for ",(0,t.jsx)(r.code,{children:"SomeService"})," is created in the injector where the provider was passed, and this value is created only once on the first request. In our example, the ",(0,t.jsx)(r.code,{children:"SomeService"})," class is actually passed to ",(0,t.jsx)(r.code,{children:"injectorPerRou"}),", so the instance of the class ",(0,t.jsx)(r.code,{children:"SomeService"})," will be created in ",(0,t.jsx)(r.code,{children:"injectorPerRou"}),", even if this instance is requested in the child ",(0,t.jsx)(r.code,{children:"injectorPerReq"}),"."]}),"\n",(0,t.jsx)(r.p,{children:"This rule is very important because it clearly shows:"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsx)(r.li,{children:"in which injector the value for a given provider is created;"}),"\n",(0,t.jsx)(r.li,{children:"that if you take a single injector, the value for a given provider (for a given token) is created only once in it;"}),"\n",(0,t.jsxs)(r.li,{children:["that if the child injector lacks a provider, it can ask the parent injector for the ",(0,t.jsx)(r.em,{children:"value"})," of that provider (i.e., the child injector asks the parent injector for the ",(0,t.jsx)(r.em,{children:"value"}),", not for the provider itself)."]}),"\n"]}),"\n",(0,t.jsxs)(r.p,{children:["This rule applies to the ",(0,t.jsx)(r.code,{children:"injector.get()"})," method, but not to ",(0,t.jsx)(r.code,{children:"injector.pull()"})," or ",(0,t.jsx)(r.code,{children:"injector.resolveAndInstantiate()"}),"."]}),"\n",(0,t.jsx)(r.h2,{id:"transfer-of-providers-to-the-di-registry",children:"Transfer of providers to the DI registry"}),"\n",(0,t.jsxs)(r.p,{children:["For a single dependency, one or more ",(0,t.jsx)(r.a,{href:"/components-of-ditsmod-app/dependency-injection/#injector-and-providers",children:"providers"})," must be passed to the DI registry. Usually providers are passed to the DI registry via module metadata, although sometimes they are passed via controller metadata or even directly to ",(0,t.jsx)(r.a,{href:"/components-of-ditsmod-app/dependency-injection/#injector-and-providers",children:"injectors"}),". In the following example ",(0,t.jsx)(r.code,{children:"SomeService"})," is passed into the ",(0,t.jsx)(r.code,{children:"providersPerMod"})," array:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:"{6}",children:"import { restModule } from '@ditsmod/rest';\nimport { SomeService } from './some.service.js';\n\n@restModule({\n  providersPerMod: [\n    SomeService\n  ],\n})\nexport class SomeModule {}\n"})}),"\n",(0,t.jsxs)(r.p,{children:["After such a transfer, consumers of providers can use ",(0,t.jsx)(r.code,{children:"SomeService"})," within ",(0,t.jsx)(r.code,{children:"SomeModule"}),". And now let's additionally pass another provider with the same token, but this time in the controller metadata:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:"{8}",children:"import { controller } from '@ditsmod/rest';\n\nimport { SomeService } from './some.service.js';\nimport { OtherService } from './other.service.js';\n\n@controller({\n  providersPerReq: [\n    { token: SomeService, useClass: OtherService }\n  ]\n})\nexport class SomeController {\n  constructor(private someService: SomeService) {}\n  // ...\n}\n"})}),"\n",(0,t.jsxs)(r.p,{children:['Pay attention to the highlighted line. Thus we tell DI: "If this controller has a dependency on the provider with the token ',(0,t.jsx)(r.code,{children:"SomeService"}),", it should be substituted with an instance of the class ",(0,t.jsx)(r.code,{children:"OtherService"}),'". This substitution will apply only to this controller. All other controllers in ',(0,t.jsx)(r.code,{children:"SomeModule"})," will receive instances of ",(0,t.jsx)(r.code,{children:"SomeService"})," for the ",(0,t.jsx)(r.code,{children:"SomeService"})," token."]}),"\n",(0,t.jsx)(r.p,{children:"You can perform a similar substitution at the application or module level. This can sometimes be useful, for example when you want to have default configuration values at the application level but custom values for that configuration at a specific module level. In that case, first pass the default configuration in the root module:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:"{6}",children:"import { rootModule } from '@ditsmod/core';\nimport { ConfigService } from './config.service.js';\n\n@rootModule({\n  providersPerApp: [\n    ConfigService\n  ],\n})\nexport class AppModule {}\n"})}),"\n",(0,t.jsxs)(r.p,{children:["And then in some module substitute ",(0,t.jsx)(r.code,{children:"ConfigService"})," with an arbitrary value:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:"{6}",children:"import { restModule } from '@ditsmod/rest';\nimport { ConfigService } from './config.service.js';\n\n@restModule({\n  providersPerMod: [\n    { token: ConfigService, useValue: { propery1: 'some value' } }\n  ],\n})\nexport class SomeModule {}\n"})}),"\n",(0,t.jsx)(r.h2,{id:"re-adding-providers",children:"Re-adding providers"}),"\n",(0,t.jsx)(r.p,{children:"Different providers with the same token can be added many times in module or controller metadata, but DI will choose the provider that was added last (exceptions to this rule apply only for multi-providers):"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",children:"import { restModule } from '@ditsmod/rest';\n\n@restModule({\n  providersPerMod: [\n    { token: 'token1', useValue: 'value1' },\n    { token: 'token1', useValue: 'value2' },\n    { token: 'token1', useValue: 'value3' },\n  ],\n})\nexport class SomeModule {}\n"})}),"\n",(0,t.jsxs)(r.p,{children:["In this case, within ",(0,t.jsx)(r.code,{children:"SomeModule"})," the ",(0,t.jsx)(r.code,{children:"token1"})," will return ",(0,t.jsx)(r.code,{children:"value3"})," at the module, route or request level."]}),"\n",(0,t.jsx)(r.p,{children:"Additionally, different providers with the same token can be provided at multiple different hierarchy levels simultaneously, but DI will always choose the nearest injector (i.e., if a provider value is requested at the request level, the injector at the request level will be inspected first, and only if the required provider is not found there will DI ascend to parent injectors):"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",children:"import { restModule } from '@ditsmod/rest';\n\n@restModule({\n  providersPerMod: [{ token: 'token1', useValue: 'value1' }],\n  providersPerRou: [{ token: 'token1', useValue: 'value2' }],\n  providersPerReq: [{ token: 'token1', useValue: 'value3' }],\n})\nexport class SomeModule {}\n"})}),"\n",(0,t.jsxs)(r.p,{children:["In this case, within ",(0,t.jsx)(r.code,{children:"SomeModule"})," for ",(0,t.jsx)(r.code,{children:"token1"})," the value ",(0,t.jsx)(r.code,{children:"value3"})," will be returned at the request level, ",(0,t.jsx)(r.code,{children:"value2"})," at the route level, and ",(0,t.jsx)(r.code,{children:"value1"})," at the module level."]}),"\n",(0,t.jsx)(r.p,{children:"Also, if you import a provider from an external module and you have a provider with the same token in your current module, the local provider will have higher priority provided they were passed at the same hierarchy level."})]})}function h(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>i,x:()=>c});var o=n(6540);const t={},s=o.createContext(t);function i(e){const r=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function c(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),o.createElement(s.Provider,{value:r},e.children)}}}]);