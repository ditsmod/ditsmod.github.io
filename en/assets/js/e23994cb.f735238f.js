"use strict";(self.webpackChunkditsmod_github_io=self.webpackChunkditsmod_github_io||[]).push([[638],{1589:(e,o,r)=>{r.r(o),r.d(o,{assets:()=>l,contentTitle:()=>d,default:()=>p,frontMatter:()=>i,metadata:()=>n,toc:()=>a});const n=JSON.parse('{"id":"developer-guides/exports-and-imports","title":"Export, import, append","description":"The module where you declare certain providers is called the host module for those providers. And when you use those providers in an external module, that external module is called the consumer module of those providers.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/01-developer-guides/01-exports-and-imports.md","sourceDirName":"01-developer-guides","slug":"/developer-guides/exports-and-imports","permalink":"/en/developer-guides/exports-and-imports","draft":false,"unlisted":false,"editUrl":"https://github.com/ditsmod/ditsmod/edit/main/website/i18n/en/docusaurus-plugin-content-docs/current/01-developer-guides/01-exports-and-imports.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Providers helper","permalink":"/en/components-of-ditsmod-app/providers-helper"},"next":{"title":"\u041c\u043e\u043d\u043e\u0440\u0435\u043f\u043e\u0437\u0438\u0442\u043e\u0440\u0456\u0439","permalink":"/en/developer-guides/monorepo"}}');var t=r(4848),s=r(8453);const i={sidebar_position:1},d="Export, import, append",l={},a=[{value:"Exporting providers from a <code>featureModule</code>",id:"exporting-providers-from-a-featuremodule",level:2},{value:"Exporting providers from <code>rootModule</code>",id:"exporting-providers-from-rootmodule",level:2},{value:"Import module",id:"import-module",level:2},{value:"Import classes or class instances?",id:"import-classes-or-class-instances",level:3},{value:"Import and encapsulation",id:"import-and-encapsulation",level:3},{value:"Appending of the module",id:"appending-of-the-module",level:2},{value:"Re-export of the module",id:"re-export-of-the-module",level:2}];function c(e){const o={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(o.header,{children:(0,t.jsx)(o.h1,{id:"export-import-append",children:"Export, import, append"})}),"\n",(0,t.jsxs)(o.p,{children:["The module where you declare certain ",(0,t.jsx)(o.a,{href:"/components-of-ditsmod-app/dependency-injection/#providers",children:"providers"})," is called the ",(0,t.jsx)(o.strong,{children:"host module"})," for those providers. And when you use those providers in an external module, that external module is called the ",(0,t.jsx)(o.strong,{children:"consumer module"})," of those providers."]}),"\n",(0,t.jsxs)(o.p,{children:["In order for a consumer module to use providers from a host module, the corresponding provider ",(0,t.jsx)(o.a,{href:"/components-of-ditsmod-app/dependency-injection/#dependency-token",children:"tokens"})," must first be exported from the host module. This is done in the metadata that is passed to the ",(0,t.jsx)(o.code,{children:"featureModule"})," or ",(0,t.jsx)(o.code,{children:"rootModule"})," decorator:"]}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-ts",metastring:"{9}",children:"import { featureModule } from '@ditsmod/core';\n\nimport { FirstService } from './first.service.js';\nimport { SecondService } from './second.service.js';\nimport { ThirdService } from './third.service.js';\n\n@featureModule({\n  providersPerMod: [FirstService, { token: SecondService, useClass: ThirdService }],\n  exports: [SecondService],\n})\nexport class SomeModule {}\n"})}),"\n",(0,t.jsxs)(o.p,{children:["Considering the exported tokens, Ditsmod will look for exported providers in the ",(0,t.jsx)(o.code,{children:"providersPerMod"})," array. It makes no sense to export the providers that are passed to ",(0,t.jsx)(o.code,{children:"providersPerApp"}),", since this array will be used to form the ",(0,t.jsx)(o.a,{href:"/components-of-ditsmod-app/dependency-injection#injector",children:"injector"})," at the application level. That is, the providers from the ",(0,t.jsx)(o.code,{children:"providersPerApp"})," array will be available for any module, at any level, and without exporting."]}),"\n",(0,t.jsxs)(o.p,{children:["Since you only need to export provider tokens from the host module, not the providers themselves, you cannot directly pass providers in the form of an object to the ",(0,t.jsx)(o.code,{children:"exports"})," property."]}),"\n",(0,t.jsxs)(o.p,{children:["Keep in mind that you only need to export providers from the host module that will be directly used in the consumer modules. In the example above, ",(0,t.jsx)(o.code,{children:"SecondService"})," can depend on ",(0,t.jsx)(o.code,{children:"FirstService"}),", but ",(0,t.jsx)(o.code,{children:"FirstService"})," does not need to be exported if it is not directly used in the consumer module. This ensures module encapsulation."]}),"\n",(0,t.jsx)(o.p,{children:"Exporting controllers does not make sense, since exporting only applies to providers."}),"\n",(0,t.jsxs)(o.h2,{id:"exporting-providers-from-a-featuremodule",children:["Exporting providers from a ",(0,t.jsx)(o.code,{children:"featureModule"})]}),"\n",(0,t.jsxs)(o.p,{children:["By exporting tokens from a host module in the ",(0,t.jsx)(o.code,{children:"featureModule"})," decorator metadata, you are declaring that the corresponding providers can be used in consumer modules if they import this host module."]}),"\n",(0,t.jsxs)(o.h2,{id:"exporting-providers-from-rootmodule",children:["Exporting providers from ",(0,t.jsx)(o.code,{children:"rootModule"})]}),"\n",(0,t.jsx)(o.p,{children:"Exporting providers from the root module means that these providers will automatically be added to every module in the application:"}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-ts",metastring:"{9}",children:"import { rootModule } from '@ditsmod/core';\n\nimport { SomeService } from './some.service.js';\nimport { OtherModule } from './other.module.js';\n\n@rootModule({\n  imports: [OtherModule],\n  providersPerMod: [SomeService],\n  exports: [SomeService, OtherModule],\n})\nexport class AppModule {}\n"})}),"\n",(0,t.jsxs)(o.p,{children:["In this case, ",(0,t.jsx)(o.code,{children:"SomeService"})," will be added to all application modules at the module level. As you can see, you can also export entire modules. In this case, all providers exported from ",(0,t.jsx)(o.code,{children:"OtherModule"})," will also be added to each application module."]}),"\n",(0,t.jsx)(o.h2,{id:"import-module",children:"Import module"}),"\n",(0,t.jsxs)(o.p,{children:["You cannot import a single provider into a module, but you can import an entire module with all the providers and ",(0,t.jsx)(o.a,{href:"/components-of-ditsmod-app/extensions",children:"extensions"})," exported from it:"]}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-ts",metastring:"{6}",children:"import { featureModule } from '@ditsmod/core';\nimport { FirstModule } from './first.module.js';\n\n@featureModule({\n  imports: [\n    FirstModule\n  ]\n})\nexport class SecondModule {}\n"})}),"\n",(0,t.jsxs)(o.p,{children:["For example, if ",(0,t.jsx)(o.code,{children:"SomeService"})," is exported from the ",(0,t.jsx)(o.code,{children:"FirstModule"}),", then this service can now be used in the ",(0,t.jsx)(o.code,{children:"SecondModule"}),". However, if ",(0,t.jsx)(o.code,{children:"FirstModule"})," has controllers, they will be ignored in this import form. For Ditsmod to take into account controllers from an imported module, the module must be imported with a prefix passed in ",(0,t.jsx)(o.code,{children:"path"}),":"]}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-ts",metastring:"{7}",children:"import { featureModule } from '@ditsmod/core';\nimport { initRest } from '@ditsmod/rest';\nimport { FirstModule } from './first.module';\n\n@initRest({\n  importsWithParams: [\n    { modRefId: FirstModule, path: '' }\n  ]\n})\n@featureModule()\nexport class SecondModule {}\n"})}),"\n",(0,t.jsxs)(o.p,{children:["Although ",(0,t.jsx)(o.code,{children:"path"})," is an empty string here, for Ditsmod, the presence of ",(0,t.jsx)(o.code,{children:"path"})," means:"]}),"\n",(0,t.jsxs)(o.ol,{children:["\n",(0,t.jsx)(o.li,{children:"to consider controllers from the imported module as well;"}),"\n",(0,t.jsxs)(o.li,{children:["to use ",(0,t.jsx)(o.code,{children:"path"})," as a prefix for all controllers imported from ",(0,t.jsx)(o.code,{children:"FirstModule"}),"."]}),"\n"]}),"\n",(0,t.jsx)(o.p,{children:"As you can see, in the previous example, this time neither the provider nor the module is imported, but the object. This object has the following interface:"}),"\n",(0,t.jsx)("a",{id:"ModuleWithParams"}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-ts",children:"interface ModuleWithParams {\n  id?: string;\n  module: ModuleType<M>;\n  /**\n   * Providers per the application.\n   */\n  providersPerApp?: Providers | Provider[] = [];\n  /**\n   * Providers per a module.\n   */\n  providersPerMod?: Providers | Provider[] = [];\n  /**\n   * List of modules, `ModuleWithParams` or tokens of providers exported by this\n   * module.\n   */\n  exports?: any[];\n  /**\n   * This property allows you to pass any information to extensions.\n   *\n   * You must follow this rule: data for one extension - one key in `extensionsMeta` object.\n   */\n  extensionsMeta?: E;\n}\n"})}),"\n",(0,t.jsx)(o.p,{children:"To reduce the length of the code when importing an object of this type, it is sometimes advisable to write a static method in the importing module. To see this clearly, let's take the previous example again:"}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-ts",metastring:"{7}",children:"import { featureModule } from '@ditsmod/core';\nimport { initRest } from '@ditsmod/rest';\nimport { FirstModule } from './first.module';\n\n@initRest({\n  importsWithParams: [\n    { modRefId: FirstModule, path: '' }\n  ]\n})\n@featureModule()\nexport class SecondModule {}\n"})}),"\n",(0,t.jsxs)(o.p,{children:["If you declare ",(0,t.jsx)(o.code,{children:"FirstModule"})," and knew that this module would make sense to be imported many times into different modules with different prefixes, then in this case you could write a static method in this class that returns an object specially designed for import:"]}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-ts",children:"// ...\nexport class FirstModule {\n  static withPrefix(path: string) {\n    return {\n      modRefId: this,\n      path,\n    };\n  }\n}\n"})}),"\n",(0,t.jsx)(o.p,{children:"Now the object returned by this method can be imported as follows:"}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-ts",metastring:"{4}",children:"// ...\n@featureModule({\n  importsWithParams: [\n    FirstModule.withPrefix('some-prefix')\n  ]\n})\n@featureModule()\nexport class SecondModule {}\n"})}),"\n",(0,t.jsx)(o.p,{children:"Static methods make it easier to pass module parameters."}),"\n",(0,t.jsxs)(o.p,{children:["In order for TypeScript to control exactly what the static import method returns, it is recommended to use the ",(0,t.jsx)(o.code,{children:"ModuleWithParams"})," interface:"]}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-ts",children:"import { ModuleWithParams } from '@ditsmod/core';\n// ...\nexport class SomeModule {\n  static withParams(someParams: SomeParams): ModuleWithParams<SomeModule> {\n    return {\n      module: this,\n      // ...\n    }\n  }\n}\n"})}),"\n",(0,t.jsx)(o.h3,{id:"import-classes-or-class-instances",children:"Import classes or class instances?"}),"\n",(0,t.jsx)(o.p,{children:"Let's consider a specific situation. In the following example, each provider is a class. Note what arrays these providers are passed to and what exactly is exported."}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-ts",children:"// ...\n@featureModule({\n  providersPerMod: [Provider1],\n  exports: [Provider1],\n})\nexport class Module1 {}\n"})}),"\n",(0,t.jsxs)(o.p,{children:["Suppose we import this module into ",(0,t.jsx)(o.code,{children:"Module2"}),", which has no providers of its own:"]}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-ts",children:"// ...\n@featureModule({\n  imports: [Module1]\n  // ...\n})\nexport class Module2 {}\n"})}),"\n",(0,t.jsxs)(o.p,{children:["As a result of this import, the consumer module (",(0,t.jsx)(o.code,{children:"Module2"}),") will now have ",(0,t.jsx)(o.code,{children:"Provider1"})," at the module level, because it is declared at that level in the host module (",(0,t.jsx)(o.code,{children:"Module1"}),"). When working with ",(0,t.jsx)(o.code,{children:"Provider1"}),", its instances will be created separately in both modules. ",(0,t.jsx)(o.a,{href:"https://en.wikipedia.org/wiki/Singleton_pattern",children:"Singleton"})," can be shared between modules only if its provider is declared at the application level. In our example, the provider is declared at the module level, so ",(0,t.jsx)(o.code,{children:"Module1"})," and ",(0,t.jsx)(o.code,{children:"Module2"})," will not have instances of ",(0,t.jsx)(o.code,{children:"Provider1"})," shared at either level."]}),"\n",(0,t.jsx)(o.p,{children:"So it can be argued that classes are imported, not their instances."}),"\n",(0,t.jsx)(o.h3,{id:"import-and-encapsulation",children:"Import and encapsulation"}),"\n",(0,t.jsxs)(o.p,{children:["Let's consider a situation where only ",(0,t.jsx)(o.code,{children:"Provider3"})," is exported from ",(0,t.jsx)(o.code,{children:"Module1"}),", since only this provider is directly used in external modules:"]}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-ts",children:"// ...\n@featureModule({\n  providersPerMod: [Provider3, Provider2, Provider1],\n  exports: [Provider3],\n})\nexport class Module1 {}\n"})}),"\n",(0,t.jsxs)(o.p,{children:["Suppose ",(0,t.jsx)(o.code,{children:"Provider3"})," has a dependency on ",(0,t.jsx)(o.code,{children:"Provider1"})," and ",(0,t.jsx)(o.code,{children:"Provider2"}),". What will Ditsmod do when importing this module into other modules? Ditsmod will import all three providers, since ",(0,t.jsx)(o.code,{children:"Provider3"})," depends on the other two providers."]}),"\n",(0,t.jsx)(o.h2,{id:"appending-of-the-module",children:"Appending of the module"}),"\n",(0,t.jsxs)(o.p,{children:["If you don't need to import providers and ",(0,t.jsx)(o.a,{href:"/components-of-ditsmod-app/extensions",children:"extensions"})," into the current module, but just append the external module to the path prefix of the current module, you can use the ",(0,t.jsx)(o.code,{children:"appends"})," array:"]}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-ts",metastring:"{5}",children:"import { featureModule } from '@ditsmod/core';\nimport { FirstModule } from './first.module.js';\n\n@featureModule({\n  appends: [FirstModule]\n})\nexport class SecondModule {}\n"})}),"\n",(0,t.jsxs)(o.p,{children:["In this case, if ",(0,t.jsx)(o.code,{children:"SecondModule"})," has a path prefix, it will be used as a prefix for all routes contained in ",(0,t.jsx)(o.code,{children:"FirstModule"}),". Only those modules with controllers can be appended."]}),"\n",(0,t.jsxs)(o.p,{children:["You can also attach an additional path prefix to ",(0,t.jsx)(o.code,{children:"FirstModule"}),":"]}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-ts",metastring:"{3}",children:"// ...\n@featureModule({\n  appends: [{ path: 'some-path', module: FirstModule }]\n})\nexport class SecondModule {}\n"})}),"\n",(0,t.jsx)(o.p,{children:"In this example, an object was used, in which the module is passed for appending, it has the following interface:"}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-ts",children:"interface AppendsWithParams<T extends AnyObj = AnyObj> {\n  id?: string;\n  path: string;\n  module: ModuleType<T>;\n  guards?: GuardItem[];\n}\n"})}),"\n",(0,t.jsx)(o.h2,{id:"re-export-of-the-module",children:"Re-export of the module"}),"\n",(0,t.jsx)(o.p,{children:"In addition to importing a specific module, the same module can be simultaneously exported:"}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-ts",children:"import { featureModule } from '@ditsmod/core';\nimport { FirstModule } from './first.module.js';\n\n@featureModule({\n  imports: [FirstModule],\n  exports: [FirstModule],\n})\nexport class SecondModule {}\n"})}),"\n",(0,t.jsxs)(o.p,{children:["What is the meaning of this? - Now if you import ",(0,t.jsx)(o.code,{children:"SecondModule"})," into some other module, you will actually have ",(0,t.jsx)(o.code,{children:"FirstModule"})," imported as well."]}),"\n",(0,t.jsxs)(o.p,{children:["Pay attention! If during re-export you import an object with ",(0,t.jsx)(o.code,{children:"ModuleWithParams"})," interface, the same object must also be exported:"]}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-ts",children:"import { featureModule, ModuleWithParams } from '@ditsmod/core';\nimport { FirstModule } from './first.module.js';\n\nconst firstModuleWithParams: ModuleWithParams = { path: 'some-path', module: FirstModule };\n\n@featureModule({\n  imports: [firstModuleWithParams],\n  exports: [firstModuleWithParams],\n})\nexport class SecondModule {}\n"})})]})}function p(e={}){const{wrapper:o}={...(0,s.R)(),...e.components};return o?(0,t.jsx)(o,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,o,r)=>{r.d(o,{R:()=>i,x:()=>d});var n=r(6540);const t={},s=n.createContext(t);function i(e){const o=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function d(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),n.createElement(s.Provider,{value:o},e.children)}}}]);