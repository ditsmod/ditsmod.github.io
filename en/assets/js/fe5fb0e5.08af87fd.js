"use strict";(self.webpackChunkditsmod_github_io=self.webpackChunkditsmod_github_io||[]).push([[13],{1070:(e,o,t)=>{t.r(o),t.d(o,{assets:()=>d,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"components-of-ditsmod-app/module","title":"Modules","description":"One of the main elements of the Ditsmod architecture are its modules. But what exactly is good about modular architecture? - Modularity allows you to compose different autonomous elements and assemble them into a scalable application. Thanks to the autonomy of the modules, large projects are easier to develop, test, deploy and maintain.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/00-components-of-ditsmod-app/01-module.md","sourceDirName":"00-components-of-ditsmod-app","slug":"/components-of-ditsmod-app/module","permalink":"/en/components-of-ditsmod-app/module","draft":false,"unlisted":false,"editUrl":"https://github.com/ditsmod/ditsmod/edit/main/website/i18n/en/docusaurus-plugin-content-docs/current/00-components-of-ditsmod-app/01-module.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Dependency Injection","permalink":"/en/components-of-ditsmod-app/dependency-injection"},"next":{"title":"Router, controllers and services","permalink":"/en/components-of-ditsmod-app/controllers-and-services"}}');var n=t(4848),s=t(8453);const i={sidebar_position:1},l="Modules",d={},a=[{value:"Root module",id:"root-module",level:2},{value:"Feature module",id:"feature-module",level:2},{value:"Transfer of providers to the DI registry",id:"transfer-of-providers-to-the-di-registry",level:2},{value:"Re-adding providers",id:"re-adding-providers",level:2}];function c(e){const o={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(o.header,{children:(0,n.jsx)(o.h1,{id:"modules",children:"Modules"})}),"\n",(0,n.jsx)(o.p,{children:"One of the main elements of the Ditsmod architecture are its modules. But what exactly is good about modular architecture? - Modularity allows you to compose different autonomous elements and assemble them into a scalable application. Thanks to the autonomy of the modules, large projects are easier to develop, test, deploy and maintain."}),"\n",(0,n.jsxs)(o.p,{children:["Such architecture allows you to isolate in one module ",(0,n.jsx)(o.strong,{children:"several code files"})," that may have different roles, but ",(0,n.jsx)(o.strong,{children:"common specialization"}),". A module can be compared to an orchestra, in which there are different instruments, but they all create music together. On the other hand, the need to isolate different modules arises due to the fact that they may have different specializations and because of this - may interfere with each other. Continuing the analogy with people, if you put police and musicians, or brokers and translators in the same office, they will most likely interfere with each other. That is why ",(0,n.jsx)(o.strong,{children:"narrow specialization"})," is important for a module."]}),"\n",(0,n.jsx)(o.p,{children:"Modules are the largest building blocks of an application, and their metadata declares such module components as:"}),"\n",(0,n.jsxs)(o.ul,{children:["\n",(0,n.jsx)(o.li,{children:"controllers that accept HTTP requests and send HTTP responses;"}),"\n",(0,n.jsx)(o.li,{children:"services where the business logic of the application is described;"}),"\n",(0,n.jsx)(o.li,{children:"interceptors and guards that allow you to automate the processing of HTTP requests according to typical patterns;"}),"\n",(0,n.jsx)(o.li,{children:"decorators and extensions that allow you to add new rules and behaviors to the application;"}),"\n",(0,n.jsx)(o.li,{children:"other classes, interfaces, helpers, data types intended for the operation of the current module."}),"\n"]}),"\n",(0,n.jsx)(o.p,{children:"There are two types of modules:"}),"\n",(0,n.jsxs)(o.ol,{children:["\n",(0,n.jsx)(o.li,{children:"Root module."}),"\n",(0,n.jsx)(o.li,{children:"Feature module."}),"\n"]}),"\n",(0,n.jsx)(o.h2,{id:"root-module",children:"Root module"}),"\n",(0,n.jsxs)(o.p,{children:["Other modules are linked to the root module, which is the only one for the entire application, and its class is recommended to be named ",(0,n.jsx)(o.code,{children:"AppModule"}),". A TypeScript class becomes a Ditsmod root module thanks to one of the decorators such as ",(0,n.jsx)(o.code,{children:"rootModule"}),", ",(0,n.jsx)(o.code,{children:"restRootModule"}),", ",(0,n.jsx)(o.code,{children:"trpcRootModule"}),", etc., depending on the module you are using. For example, if you are using REST, the root module is declared as follows:"]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"import { restRootModule } from '@ditsmod/rest';\n\n@restRootModule()\nexport class AppModule {}\n"})}),"\n",(0,n.jsxs)(o.p,{children:["In general, an object with the following properties can be passed to the ",(0,n.jsx)(o.code,{children:"restRootModule"})," decorator:"]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"import { restRootModule } from '@ditsmod/rest';\n\n@restRootModule({\n  imports: [], // Imported modules\n  appends: [], // Appending modules that have controllers\n  providersPerApp: [], // Providers at the application level\n  providersPerMod: [], //         ...at the module level\n  providersPerRou: [], //         ...at the route level\n  providersPerReq: [], //         ...at the HTTP request level\n  exports: [], // Exported modules and providers from the current module\n  extensions: [], // Extensions\n  extensionsMeta: {}, // Data for extensions\n  resolvedCollisionsPerApp: [], // Resolution of imported class collisions at the application level\n  resolvedCollisionsPerMod: [], //                                   ...at the module level\n  resolvedCollisionsPerRou: [], //                                   ...at the route level\n  resolvedCollisionsPerReq: [], //                                   ...at the HTTP request level\n  controllers: [], // List of controllers in the current module\n})\nexport class AppModule {}\n"})}),"\n",(0,n.jsx)(o.h2,{id:"feature-module",children:"Feature module"}),"\n",(0,n.jsxs)(o.p,{children:["A TypeScript class becomes a Ditsmod feature module thanks to one of the following decorators: ",(0,n.jsx)(o.code,{children:"featureModule"}),", ",(0,n.jsx)(o.code,{children:"restModule"}),", ",(0,n.jsx)(o.code,{children:"trpcModule"}),", etc., depending on the module you are using. For example, if you are using REST, the root module is declared as follows:"]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"import { restModule } from '@ditsmod/rest';\n\n@restModule()\nexport class SomeModule {}\n"})}),"\n",(0,n.jsxs)(o.p,{children:["It is recommended that module files end with ",(0,n.jsx)(o.code,{children:"*.module.ts"})," and that their class names end with ",(0,n.jsx)(o.code,{children:"*Module"}),"."]}),"\n",(0,n.jsxs)(o.p,{children:["It can contain exactly the same metadata as root modules, except for the ",(0,n.jsx)(o.code,{children:"resolvedCollisionsPerApp"})," property. In addition to being declared directly in the application, feature module can also be published on npmjs.com."]}),"\n",(0,n.jsx)(o.h2,{id:"transfer-of-providers-to-the-di-registry",children:"Transfer of providers to the DI registry"}),"\n",(0,n.jsxs)(o.p,{children:["For a single dependency, one or more ",(0,n.jsx)(o.a,{href:"/components-of-ditsmod-app/dependency-injection/#injector-and-providers",children:"providers"})," must be passed to the DI registry. Usually providers are passed to the DI registry via module metadata, although sometimes they are passed via controller metadata or even directly to ",(0,n.jsx)(o.a,{href:"/components-of-ditsmod-app/dependency-injection/#injector-and-providers",children:"injectors"}),". In the following example ",(0,n.jsx)(o.code,{children:"SomeService"})," is passed into the ",(0,n.jsx)(o.code,{children:"providersPerMod"})," array:"]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",metastring:"{9}",children:"import { restModule } from '@ditsmod/rest';\n\nimport { SomeService } from './some.service.js';\nimport { SomeController } from './some.controller.js';\n\n@restModule({\n  controllers: [SomeController],\n  providersPerMod: [\n    SomeService\n  ],\n})\nexport class SomeModule {}\n"})}),"\n",(0,n.jsxs)(o.p,{children:["After such a transfer, consumers of providers can use ",(0,n.jsx)(o.code,{children:"SomeService"})," within ",(0,n.jsx)(o.code,{children:"SomeModule"}),". And now let's additionally pass another provider with the same token, but this time in the controller metadata:"]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",metastring:"{8}",children:"import { controller } from '@ditsmod/rest';\n\nimport { SomeService } from './some.service.js';\nimport { OtherService } from './other.service.js';\n\n@controller({\n  providersPerReq: [\n    { token: SomeService, useClass: OtherService }\n  ]\n})\nexport class SomeController {\n  constructor(private someService: SomeService) {}\n  // ...\n}\n"})}),"\n",(0,n.jsxs)(o.p,{children:['Pay attention to the highlighted line. Thus we tell DI: "If this controller has a dependency on the provider with the token ',(0,n.jsx)(o.code,{children:"SomeService"}),", it should be substituted with an instance of the class ",(0,n.jsx)(o.code,{children:"OtherService"}),'". This substitution will apply only to this controller. All other controllers in ',(0,n.jsx)(o.code,{children:"SomeModule"})," will receive instances of ",(0,n.jsx)(o.code,{children:"SomeService"})," for the ",(0,n.jsx)(o.code,{children:"SomeService"})," token."]}),"\n",(0,n.jsx)(o.p,{children:"You can perform a similar substitution at the application or module level. This can sometimes be useful, for example when you want to have default configuration values at the application level but custom values for that configuration at a specific module level. In that case, first pass the default configuration in the root module:"}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",metastring:"{6}",children:"import { rootModule } from '@ditsmod/core';\nimport { ConfigService } from './config.service.js';\n\n@rootModule({\n  providersPerApp: [\n    ConfigService\n  ],\n})\nexport class AppModule {}\n"})}),"\n",(0,n.jsxs)(o.p,{children:["And then in some module substitute ",(0,n.jsx)(o.code,{children:"ConfigService"})," with an arbitrary value:"]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",metastring:"{6}",children:"import { restModule } from '@ditsmod/rest';\nimport { ConfigService } from './config.service.js';\n\n@restModule({\n  providersPerMod: [\n    { token: ConfigService, useValue: { propery1: 'some value' } }\n  ],\n})\nexport class SomeModule {}\n"})}),"\n",(0,n.jsx)(o.h2,{id:"re-adding-providers",children:"Re-adding providers"}),"\n",(0,n.jsx)(o.p,{children:"Different providers with the same token can be added many times in module or controller metadata, but DI will choose the provider that was added last (exceptions to this rule apply only for multi-providers):"}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"import { restModule } from '@ditsmod/rest';\n\n@restModule({\n  providersPerMod: [\n    { token: 'token1', useValue: 'value1' },\n    { token: 'token1', useValue: 'value2' },\n    { token: 'token1', useValue: 'value3' },\n  ],\n})\nexport class SomeModule {}\n"})}),"\n",(0,n.jsxs)(o.p,{children:["In this case, within ",(0,n.jsx)(o.code,{children:"SomeModule"})," the ",(0,n.jsx)(o.code,{children:"token1"})," will return ",(0,n.jsx)(o.code,{children:"value3"})," at the module, route or request level."]}),"\n",(0,n.jsx)(o.p,{children:"Additionally, different providers with the same token can be provided at multiple different hierarchy levels simultaneously, but DI will always choose the nearest injector (i.e., if a provider value is requested at the request level, the injector at the request level will be inspected first, and only if the required provider is not found there will DI ascend to parent injectors):"}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"import { restModule } from '@ditsmod/rest';\n\n@restModule({\n  providersPerMod: [{ token: 'token1', useValue: 'value1' }],\n  providersPerRou: [{ token: 'token1', useValue: 'value2' }],\n  providersPerReq: [{ token: 'token1', useValue: 'value3' }],\n})\nexport class SomeModule {}\n"})}),"\n",(0,n.jsxs)(o.p,{children:["In this case, within ",(0,n.jsx)(o.code,{children:"SomeModule"})," for ",(0,n.jsx)(o.code,{children:"token1"})," the value ",(0,n.jsx)(o.code,{children:"value3"})," will be returned at the request level, ",(0,n.jsx)(o.code,{children:"value2"})," at the route level, and ",(0,n.jsx)(o.code,{children:"value1"})," at the module level."]}),"\n",(0,n.jsx)(o.p,{children:"Also, if you import a provider from an external module and you have a provider with the same token in your current module, the local provider will have higher priority provided they were passed at the same hierarchy level."})]})}function u(e={}){const{wrapper:o}={...(0,s.R)(),...e.components};return o?(0,n.jsx)(o,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},8453:(e,o,t)=>{t.d(o,{R:()=>i,x:()=>l});var r=t(6540);const n={},s=r.createContext(n);function i(e){const o=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function l(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),r.createElement(s.Provider,{value:o},e.children)}}}]);