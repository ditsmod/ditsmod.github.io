"use strict";(self.webpackChunkditsmod_github_io=self.webpackChunkditsmod_github_io||[]).push([[307],{9349:(e,o,r)=>{r.r(o),r.d(o,{assets:()=>l,contentTitle:()=>t,default:()=>a,frontMatter:()=>d,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"developer-guides/providers-collisions","title":"Provider Collisions","description":"Provider collisions occur when different providers that offer the same service are imported into the current module.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/01-developer-guides/09-providers-collisions.md","sourceDirName":"01-developer-guides","slug":"/developer-guides/providers-collisions","permalink":"/en/developer-guides/providers-collisions","draft":false,"unlisted":false,"editUrl":"https://github.com/ditsmod/ditsmod/edit/main/website/i18n/en/docusaurus-plugin-content-docs/current/01-developer-guides/09-providers-collisions.md","tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"sidebar_position":9},"sidebar":"tutorialSidebar","previous":{"title":"Export, import, append","permalink":"/en/developer-guides/exports-and-imports"},"next":{"title":"Ditsmod coding style guide","permalink":"/en/developer-guides/conventions"}}');var s=r(4848),n=r(8453);const d={sidebar_position:9},t="Provider Collisions",l={},c=[{value:"Collision resolution",id:"collision-resolution",level:2}];function u(e){const o={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,n.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(o.header,{children:(0,s.jsx)(o.h1,{id:"provider-collisions",children:"Provider Collisions"})}),"\n",(0,s.jsx)(o.p,{children:"Provider collisions occur when different providers that offer the same service are imported into the current module."}),"\n",(0,s.jsxs)(o.p,{children:["Let's take a closer look at a specific example. Imagine you have ",(0,s.jsx)(o.code,{children:"Module3"}),", where you import ",(0,s.jsx)(o.code,{children:"Module2"})," and ",(0,s.jsx)(o.code,{children:"Module1"}),". You made these imports because you need ",(0,s.jsx)(o.code,{children:"Service2"})," and ",(0,s.jsx)(o.code,{children:"Service1"})," from these modules, respectively. You review the results of these services operations, but for some reason, ",(0,s.jsx)(o.code,{children:"Service1"})," does not behave as expected. You start debugging and discover that ",(0,s.jsx)(o.code,{children:"Service1"})," is exported from both ",(0,s.jsx)(o.code,{children:"Module2"})," and ",(0,s.jsx)(o.code,{children:"Module1"}),". You expected ",(0,s.jsx)(o.code,{children:"Service1"})," to be exported only from ",(0,s.jsx)(o.code,{children:"Module1"}),", but in reality, the version exported by ",(0,s.jsx)(o.code,{children:"Module2"})," is being used:"]}),"\n",(0,s.jsx)(o.pre,{children:(0,s.jsx)(o.code,{className:"language-ts",metastring:"{8,14,19}",children:"import { restModule, restRootModule } from '@ditsmod/rest';\n\nclass Service1 {}\nclass Service2 {}\n\n@restModule({\n  providersPerMod: [Service1],\n  exports: [Service1]\n})\nclass Module1 {}\n\n@restModule({\n  providersPerMod: [{ token: Service1, useValue: 'some value' }, Service2],\n  exports: [Service1, Service2],\n})\nclass Module2 {}\n\n@restRootModule({\n  imports: [Module1, Module2],\n})\nclass Module3 {}\n"})}),"\n",(0,s.jsx)(o.p,{children:"To prevent this, if you import two or more modules that export non-identical providers with the same token, Ditsmod will throw an error similar to this:"}),"\n",(0,s.jsxs)(o.blockquote,{children:["\n",(0,s.jsx)(o.p,{children:"Error: Importing providers to Module3 failed: exports from Module1, Module2 causes collision with Service1. You should add Service1 to resolvedCollisionsPerMod in this module. For example: resolvedCollisionsPerMod: [ [Service1, Module1] ]."}),"\n"]}),"\n",(0,s.jsx)(o.p,{children:"In this specific scenario:"}),"\n",(0,s.jsxs)(o.ol,{children:["\n",(0,s.jsxs)(o.li,{children:[(0,s.jsx)(o.code,{children:"Module1"})," exports a provider with the token ",(0,s.jsx)(o.code,{children:"Service1"}),"."]}),"\n",(0,s.jsxs)(o.li,{children:[(0,s.jsx)(o.code,{children:"Module2"})," overrides and then exports a provider with the token ",(0,s.jsx)(o.code,{children:"Service1"}),"."]}),"\n",(0,s.jsxs)(o.li,{children:["The providers with the token ",(0,s.jsx)(o.code,{children:"Service1"})," in ",(0,s.jsx)(o.code,{children:"Module1"})," and ",(0,s.jsx)(o.code,{children:"Module2"})," are not identical."]}),"\n"]}),"\n",(0,s.jsxs)(o.p,{children:["And because both of these modules are imported into ",(0,s.jsx)(o.code,{children:"Module3"}),', a "provider collision" occurs, leaving the developer uncertain about which provider will be used in ',(0,s.jsx)(o.code,{children:"Module3"}),"."]}),"\n",(0,s.jsx)(o.h2,{id:"collision-resolution",children:"Collision resolution"}),"\n",(0,s.jsxs)(o.p,{children:["If ",(0,s.jsx)(o.code,{children:"Module3"})," is declared in your application (it is not imported from ",(0,s.jsx)(o.code,{children:"node_modules"}),"), the collision is resolved by adding to ",(0,s.jsx)(o.code,{children:"resolvedCollisionsPer*"})," an array of two elements, with the provider's token in the first place and the module from which the provider needs to be taken in the second place:"]}),"\n",(0,s.jsx)(o.pre,{children:(0,s.jsx)(o.code,{className:"language-ts",metastring:"{20}",children:"import { restModule, restRootModule } from '@ditsmod/rest';\n\nclass Service1 {}\nclass Service2 {}\n\n@restModule({\n  providersPerMod: [Service1],\n  exports: [Service1]\n})\nclass Module1 {}\n\n@restModule({\n  providersPerMod: [{ token: Service1, useValue: 'some value' }, Service2],\n  exports: [Service1, Service2],\n})\nclass Module2 {}\n\n@restRootModule({\n  imports: [Module1, Module2],\n  resolvedCollisionsPerMod: [ [Service1, Module1] ]\n})\nclass Module3 {}\n"})}),"\n",(0,s.jsxs)(o.p,{children:["If you have installed ",(0,s.jsx)(o.code,{children:"Module3"})," using packages manager (npm, yarn, etc.), there is no point in modifying this module locally to resolve the collision. This situation can only occur if ",(0,s.jsx)(o.code,{children:"Module2"})," and ",(0,s.jsx)(o.code,{children:"Module1"})," are exported from the root module, so you need to remove one of these modules from there. And, of course, after that you will have to explicitly import the deleted module into those modules where it is needed."]})]})}function a(e={}){const{wrapper:o}={...(0,n.R)(),...e.components};return o?(0,s.jsx)(o,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},8453:(e,o,r)=>{r.d(o,{R:()=>d,x:()=>t});var i=r(6540);const s={},n=i.createContext(s);function d(e){const o=i.useContext(n);return i.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function t(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),i.createElement(n.Provider,{value:o},e.children)}}}]);