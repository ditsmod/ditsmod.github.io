"use strict";(self.webpackChunkditsmod_github_io=self.webpackChunkditsmod_github_io||[]).push([[856],{5504:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var r=n(3117),o=(n(7294),n(3905));const i={sidebar_position:2},a="Dependency Injection",s={unversionedId:"components-of-ditsmod-app/dependency-injection",id:"components-of-ditsmod-app/dependency-injection",title:"Dependency Injection",description:"Basic concepts",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/00-components-of-ditsmod-app/02-dependency-injection.md",sourceDirName:"00-components-of-ditsmod-app",slug:"/components-of-ditsmod-app/dependency-injection",permalink:"/en/components-of-ditsmod-app/dependency-injection",draft:!1,editUrl:"https://github.com/ditsmod/ditsmod/edit/main/website/i18n/en/docusaurus-plugin-content-docs/current/00-components-of-ditsmod-app/02-dependency-injection.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Router, controllers and services",permalink:"/en/components-of-ditsmod-app/controllers-and-services"},next:{title:"Export, import, append",permalink:"/en/components-of-ditsmod-app/exports-and-imports"}},l={},c=[{value:"Basic concepts",id:"basic-concepts",level:2},{value:"Dependency",id:"dependency",level:2},{value:"Optional dependency",id:"optional-dependency",level:3},{value:"Dependency token",id:"dependency-token",level:2},{value:"Providers",id:"providers",level:2},{value:"Injector",id:"injector",level:2},{value:"Hierarchy of injectors",id:"hierarchy-of-injectors",level:2},{value:"Hierarchy of injectors in the Ditsmod application",id:"hierarchy-of-injectors-in-the-ditsmod-application",level:3},{value:"Hierarchy of controller injectors",id:"hierarchy-of-controller-injectors",level:3},{value:"Hierarchy of service injectors",id:"hierarchy-of-service-injectors",level:3},{value:"Current injector",id:"current-injector",level:3},{value:"Multi-providers",id:"multi-providers",level:2},{value:"Changing multi-providers",id:"changing-multi-providers",level:3},{value:"Passing of providers to the DI registry",id:"passing-of-providers-to-the-di-registry",level:2},{value:"Re-adding providers",id:"re-adding-providers",level:2},{value:"When DI can&#39;t find the right provider",id:"when-di-cant-find-the-right-provider",level:2}],p={toc:c};function d(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"dependency-injection"},"Dependency Injection"),(0,o.kt)("h2",{id:"basic-concepts"},"Basic concepts"),(0,o.kt)("p",null,"Ditsmod DI has the following basic concepts:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"dependency"),(0,o.kt)("li",{parentName:"ul"},"dependency token, token types"),(0,o.kt)("li",{parentName:"ul"},"provider"),(0,o.kt)("li",{parentName:"ul"},"injector"),(0,o.kt)("li",{parentName:"ul"},"injector hierarchy"),(0,o.kt)("li",{parentName:"ul"},"provider substitution")),(0,o.kt)("h2",{id:"dependency"},"Dependency"),(0,o.kt)("p",null,"If creating an instance of a given class requires first creating instances of other classes, then that class has dependencies. For example, if you write this in the service constructor:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{7}","{7}":!0},"import { injectable } from '@ditsmod/core';\n\nimport { FirstService } from './first.service';\n\n@injectable()\nexport class SecondService {\n  constructor(private firstService: FirstService) {}\n  // ...\n}\n")),(0,o.kt)("p",null,"this means that ",(0,o.kt)("inlineCode",{parentName:"p"},"SecondService")," has a dependency on ",(0,o.kt)("inlineCode",{parentName:"p"},"FirstService"),", and you is expected that DI will resolve this dependency as follows:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"DI will first look through the constructor of ",(0,o.kt)("inlineCode",{parentName:"li"},"FirstService"),";"),(0,o.kt)("li",{parentName:"ol"},"if ",(0,o.kt)("inlineCode",{parentName:"li"},"FirstService")," has no dependency, an instance of ",(0,o.kt)("inlineCode",{parentName:"li"},"FirstService")," will be created;"),(0,o.kt)("li",{parentName:"ol"},"instance of ",(0,o.kt)("inlineCode",{parentName:"li"},"FirstService")," will be passed to the ",(0,o.kt)("inlineCode",{parentName:"li"},"SecondService")," constructor.")),(0,o.kt)("p",null,"If after the first step it turns out that ",(0,o.kt)("inlineCode",{parentName:"p"},"FirstService")," has its own dependencies, then DI will recursively execute these three steps for each given dependency."),(0,o.kt)("h3",{id:"optional-dependency"},"Optional dependency"),(0,o.kt)("p",null,"Sometimes you may need to specify an optional dependency in the constructor. Let's take a look at the following example, where a question mark is placed after the ",(0,o.kt)("inlineCode",{parentName:"p"},"firstService")," property, thus indicating to TypeScript that this property is optional:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{7}","{7}":!0},"import { injectable } from '@ditsmod/core';\n\nimport { FirstService } from './first.service';\n\n@injectable()\nexport class SecondService {\n  constructor(private firstService?: FirstService) {}\n  // ...\n}\n")),(0,o.kt)("p",null,"But DI will ignore this optionality and generate an error if there is no possibility to create ",(0,o.kt)("inlineCode",{parentName:"p"},"FirstService"),". To make this code work, you need use the ",(0,o.kt)("inlineCode",{parentName:"p"},"optional")," decorator:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{7}","{7}":!0},"import { injectable, optional } from '@ditsmod/core';\n\nimport { FirstService } from './first.service';\n\n@injectable()\nexport class SecondService {\n  constructor(@optional() private firstService?: FirstService) {}\n  // ...\n}\n")),(0,o.kt)("h2",{id:"dependency-token"},"Dependency token"),(0,o.kt)("p",null,"In class constructors, dependencies are specified using so-called ",(0,o.kt)("strong",{parentName:"p"},"tokens"),". Basically, a token is an identifier with which a certain dependency is associated, and this association occurs in the Node.js runtime. That is, data types that are present in TypeScript and not in JavaScript are not suitable for use as tokens."),(0,o.kt)("p",null,"A token can be of any JavaScript type, but DI currently has a limitation where DI does not distinguish between different primitive types, different ",(0,o.kt)("em",{parentName:"p"},"array")," or ",(0,o.kt)("em",{parentName:"p"},"enum")," types. In addition, you should remember that the token must remain in the JavaScript file after compilation from TypeScript code, so in particular interfaces or types declared with the ",(0,o.kt)("inlineCode",{parentName:"p"},"type")," keyword cannot be used as a token."),(0,o.kt)("p",null,"Let's revisit the previous example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{7}","{7}":!0},"import { injectable } from '@ditsmod/core';\n\nimport { FirstService } from './first.service';\n\n@injectable()\nexport class SecondService {\n  constructor(private firstService: FirstService) {}\n  // ...\n}\n")),(0,o.kt)("p",null,"In this case, ",(0,o.kt)("inlineCode",{parentName:"p"},"FirstService")," is used both as a variable type and as a token to indicate the dependency of ",(0,o.kt)("inlineCode",{parentName:"p"},"SecondService")," on an instance of the ",(0,o.kt)("inlineCode",{parentName:"p"},"FirstService")," class. This means that ",(0,o.kt)("inlineCode",{parentName:"p"},"FirstService")," must be a class, but not an interface or a primitive type."),(0,o.kt)("h1",{id:"the-inject-decorator"},"The ",(0,o.kt)("inlineCode",{parentName:"h1"},"inject")," decorator"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"inject")," decorator allows using an alternative token, which is necessary for obtaining various primitive types, arrays, enums, or any other value in the constructor:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{7}","{7}":!0},"import { injectable, inject } from '@ditsmod/core';\n\nimport { InterfaceOfItem } from './types';\n\n@injectable()\nexport class SecondService {\n  constructor(@inject('some-string') private someArray: InterfaceOfItem[]) {}\n  // ...\n}\n")),(0,o.kt)("p",null,"When ",(0,o.kt)("inlineCode",{parentName:"p"},"inject")," is used, DI ignores the variable type and instead uses an alternative token passed to it. In this case, DI ignores the variable type - ",(0,o.kt)("inlineCode",{parentName:"p"},"InterfaceOfItem[]"),", using ",(0,o.kt)("inlineCode",{parentName:"p"},"some-string")," as the token instead."),(0,o.kt)("p",null,"Keep in mind that the easiest and most reliable dependency type to use is a class. DI recognizes well the types of different classes, even if they have the same name, so the ",(0,o.kt)("inlineCode",{parentName:"p"},"inject")," decorator can not be used with them. For all other types of dependencies, we recommend using an instance of the ",(0,o.kt)("inlineCode",{parentName:"p"},"InjectionToken<T>")," class as a token, and passing an arbitrary text value to its constructor for a short description:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{5}","{5}":!0},"// tokens.ts\nimport { InjectionToken } from '@ditsmod/core';\nimport { InterfaceOfItem } from './types';\n\nconst SOME_TOKEN = new InjectionToken<InterfaceOfItem[]>('InterfaceOfItem');\n\n// second-service.ts\nimport { injectable, inject } from '@ditsmod/core';\nimport { InterfaceOfItem } from './types';\nimport { SOME_TOKEN } from './tokens';\n\n@injectable()\nexport class SecondService {\n  constructor(@inject(SOME_TOKEN) private someArray: InterfaceOfItem[]) {}\n  // ...\n}\n")),(0,o.kt)("h2",{id:"providers"},"Providers"),(0,o.kt)("p",null,"DI has a dependency registry, which is essentially a mapping between a token and a value to be emitted for a particular dependency. It can be schematically shown as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"token1 => value15\ntoken2 => value100\n...\n")),(0,o.kt)("p",null,"Such values are created by DI using ",(0,o.kt)("strong",{parentName:"p"},"providers"),". So, to resolve a certain dependency, you first need to pass the corresponding provider to the DI registry, and then DI will issue value of this provider by its token. The ",(0,o.kt)("a",{parentName:"p",href:"#passing-of-providers-to-the-di-registry"},"next section")," discusses how providers can be passed to DI. Providers have this type:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{3-7}","{3-7}":!0},"import { Class } from '@ditsmod/core';\n\ntype Provider = Class<any> |\n{ token: any, useClass: Class<any>, multi?: boolean } |\n{ token: any, useValue: any, multi?: boolean } |\n{ token?: any, useFactory: [Class<any>, Class<any>.prototype.methodName], multi?: boolean } |\n{ token: any, useToken: any, multi?: boolean }\n")),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"* here ",(0,o.kt)("inlineCode",{parentName:"em"},"Class<any>")," means any class.")),(0,o.kt)("p",null,"Note that the token for the provider with the ",(0,o.kt)("inlineCode",{parentName:"p"},"useFactory")," property is optional, since DI can use the method of the specified class as a token."),(0,o.kt)("p",null,"In the example above, the definition of the provider object type is shown, the following values are passed to its properties:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"useClass")," - the class is passed, DI will make an instance of this class. An example of such a provider:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"{ token: 'token1', useClass: SomeService }\n"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"useValue")," - any value is passed, DI will output it unchanged. An example of such a provider:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"{ token: 'token2', useValue: 'some value' }\n"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"useFactory")," - ",(0,o.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/docs/handbook/2/objects.html#tuple-types"},"tuple")," is passed, where the class should be in the first place, and in the second place - the method of this class, which should return any value for the specified token. For example, if the class is like this:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { methodFactory } from '@ditsmod/core';\n\nexport class ClassWithFactory {\n  @methodFactory()\n  method1(dependecy1: Dependecy1, dependecy2: Dependecy2) {\n    // ...\n    return '...';\n  }\n}\n")),(0,o.kt)("p",{parentName:"li"},"in this case, the provider must be transferred to the DI registry in the following format:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"{ token: 'token3', useFactory: [ClassWithFactory, ClassWithFactory.prototype.method1] }\n")),(0,o.kt)("p",{parentName:"li"},"First, DI will create an instance of this class, then call its method and get the result, which will be associated with the specified token.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"useToken")," - another token is passed to this provider property. If you write the following:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"{ token: SecondService, useToken: FirstService }\n")),(0,o.kt)("p",{parentName:"li"},'this is how you say DI: "When provider consumers request the ',(0,o.kt)("inlineCode",{parentName:"p"},"SecondService")," token, the value for the ",(0,o.kt)("inlineCode",{parentName:"p"},"FirstService"),' token should be used". In other words, this directive makes an alias ',(0,o.kt)("inlineCode",{parentName:"p"},"SecondService")," that points to ",(0,o.kt)("inlineCode",{parentName:"p"},"FirstService"),". The DI algorithm in such cases is as follows:"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"When provider consumers request ",(0,o.kt)("inlineCode",{parentName:"li"},"SecondService"),", DI will look up the value for it in its registry using the ",(0,o.kt)("inlineCode",{parentName:"li"},"FirstService")," token."),(0,o.kt)("li",{parentName:"ul"},"After DI finds the value for ",(0,o.kt)("inlineCode",{parentName:"li"},"FirstService"),", it will be returned to the consumer who requested ",(0,o.kt)("inlineCode",{parentName:"li"},"SecondService"),".")))),(0,o.kt)("p",null,"Now that you are familiar with the concept of ",(0,o.kt)("strong",{parentName:"p"},"provider"),", we can clarify that ",(0,o.kt)("strong",{parentName:"p"},"dependency")," means dependency on providers. Such dependencies are made by ",(0,o.kt)("strong",{parentName:"p"},"consumers")," of providers either in service constructors, or in constructors or methods of controllers, or in the ",(0,o.kt)("inlineCode",{parentName:"p"},"get()")," method of ",(0,o.kt)("a",{parentName:"p",href:"#injector"},"injectors")," (more on this later)."),(0,o.kt)("h2",{id:"injector"},"Injector"),(0,o.kt)("p",null,"The so-called ",(0,o.kt)("strong",{parentName:"p"},"DI registry")," has been mentioned above. Now that you know what DI uses the registry for, it's time to learn that these registries are in injectors, and there can be many such injectors in a Ditsmod application. But first, let's understand how injectors work."),(0,o.kt)("p",null,"If we simplify the DI working scheme greatly, we can say that DI takes an array of providers as input and outputs an injector that can create instances of the passed providers, taking into account their dependencies. It has approximately the following picture:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{16}","{16}":!0},"import 'reflect-metadata';\nimport { Injector, injectable } from '@ditsmod/core';\n\nclass Service1 {}\n\n@injectable()\nclass Service2 {\n  constructor(service1: Service1) {}\n}\n\n@injectable()\nclass Service3 {\n  constructor(service2: Service2) {}\n}\n\nconst injector = Injector.resolveAndCreate([Service1, Service2, Service3]);\nconst service3 = injector.get(Service3);\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Injector.resolveAndCreate()")," method accepts an array of providers as input, and outputs a certain object, which is exactly what is called an ",(0,o.kt)("strong",{parentName:"p"},"injector"),". This injector obviously contains a registry of transferred providers, and is able to create their instances using the ",(0,o.kt)("inlineCode",{parentName:"p"},"injector.get()")," method, taking into account the entire chain of dependencies (",(0,o.kt)("inlineCode",{parentName:"p"},"Service3")," -> ",(0,o.kt)("inlineCode",{parentName:"p"},"Service2")," -> ",(0,o.kt)("inlineCode",{parentName:"p"},"Service1"),")."),(0,o.kt)("p",null,"What the injector does:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"when ",(0,o.kt)("inlineCode",{parentName:"li"},"Service3")," is requested, injector looks at the constructor of this class, sees the dependency on ",(0,o.kt)("inlineCode",{parentName:"li"},"Service2"),";"),(0,o.kt)("li",{parentName:"ul"},"then looks at the constructor in ",(0,o.kt)("inlineCode",{parentName:"li"},"Service2"),", sees the dependency on ",(0,o.kt)("inlineCode",{parentName:"li"},"Service1"),";"),(0,o.kt)("li",{parentName:"ul"},"then looks at the constructor in ",(0,o.kt)("inlineCode",{parentName:"li"},"Service1"),", does not find dependencies there, and therefore first creates an instance of ",(0,o.kt)("inlineCode",{parentName:"li"},"Service1"),";"),(0,o.kt)("li",{parentName:"ul"},"then creates an instance of ",(0,o.kt)("inlineCode",{parentName:"li"},"Service2")),(0,o.kt)("li",{parentName:"ul"},"and the last one creates the ",(0,o.kt)("inlineCode",{parentName:"li"},"Service3")," instance.")),(0,o.kt)("p",null,"Using DI, you may not know the entire ",(0,o.kt)("inlineCode",{parentName:"p"},"Service3")," dependency chain, entrust this work to the injector, the main thing is to transfer all necessary classes to the DI registry. Keep in mind that you can write unit tests for individual classes this way."),(0,o.kt)("h2",{id:"hierarchy-of-injectors"},"Hierarchy of injectors"),(0,o.kt)("p",null,"Ditsmod DI also allows you to create a hierarchy of injectors - this is when there are parent and child injectors. At first glance, there is nothing interesting in such a hierarchy, because it is not clear what it is needed for, but in Ditsmod this possibility is used very often, since it allows you to make the application architecture modular. It is worth paying special attention to the study of the specifics of the hierarchy, it will save you more than one hour of time in the future, because you will know how it works and why it does not find this dependency..."),(0,o.kt)("p",null,"When creating a hierarchy, only the child injector holds the connection, it has an object of the parent injector. At the same time, the parent injector knows nothing about its child injectors. That is, the connection between injectors in the hierarchy is one-way. Conditionally, it looks like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{6}","{6}":!0},"interface Parent {\n  // There are certain properties of the parent injector, but no child injector\n}\n\ninterface Child {\n  parent: Parent;\n  // There are other properties of the child injector.\n}\n")),(0,o.kt)("p",null,"By having a parent injector object, a child injector can refer to its parent when child needs a provider instance that it does not have."),(0,o.kt)("p",null,"Let's consider the following example. For simplicity, no decorators are used here at all, since each class is independent:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{8-9}","{8-9}":!0},"import { Injector } from '@ditsmod/core';\n\nclass Service1 {}\nclass Service2 {}\nclass Service3 {}\nclass Service4 {}\n\nconst parent = Injector.resolveAndCreate([Service1, Service2]); // Parent injector\nconst child = parent.resolveAndCreateChild([Service2, Service3]); // Child injector\n\nchild.get(Service1); // \u041e\u041a\nparent.get(Service1); // \u041e\u041a\n\nparent.get(Service1) === child.get(Service1); // true\n\nchild.get(Service2); // \u041e\u041a\nparent.get(Service2); // \u041e\u041a\n\nparent.get(Service2) === child.get(Service2); // false\n\nchild.get(Service3); // \u041e\u041a\nparent.get(Service3); // Error - No provider for Service3!\n\nchild.get(Service4); // Error - No provider for Service4!\nparent.get(Service4); // Error - No provider for Service4!\n")),(0,o.kt)("p",null,"As you can see, when the child injector was created, ",(0,o.kt)("inlineCode",{parentName:"p"},"Service1")," was not passed to it, so when an instance of this class is requested, it will turn to the parent. By the way, there is one non-obvious but very important point here: child injectors only request certain instances of classes from parent injectors and do not create them on their own. That is why this expression returns ",(0,o.kt)("inlineCode",{parentName:"p"},"true"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"parent.get(Service1) === child.get(Service1); // true\n")),(0,o.kt)("p",null,"And ",(0,o.kt)("inlineCode",{parentName:"p"},"Service2")," is in both injectors, so each of them will create its own local version of this service, and that is why this expression returns ",(0,o.kt)("inlineCode",{parentName:"p"},"false"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"parent.get(Service2) === child.get(Service2); // false\n")),(0,o.kt)("p",null,"The parent injector cannot create an instance of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Service3")," class because the parent injector has no connection to the child injector that contains ",(0,o.kt)("inlineCode",{parentName:"p"},"Service3"),"."),(0,o.kt)("p",null,"Well, both injectors cannot issue ",(0,o.kt)("inlineCode",{parentName:"p"},"Service4")," instance, because they were not given this class when they were created."),(0,o.kt)("h3",{id:"hierarchy-of-injectors-in-the-ditsmod-application"},"Hierarchy of injectors in the Ditsmod application"),(0,o.kt)("p",null,"Earlier in the documentation, you encountered the following object properties that are passed in module or controller metadata:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"providersPerApp")," - providers at the application level;"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"providersPerMod")," - providers at the module level;"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"providersPerRou")," - providers at the route level;"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"providersPerReq")," - providers at the HTTP request level.")),(0,o.kt)("p",null,"Using these arrays, Ditsmod creates four different injectors, which are interconnected in a hierarchical relationship. Such a hierarchy can be simulated as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { Injector } from '@ditsmod/core';\n\nconst providersPerApp = [];\nconst providersPerMod = [];\nconst providersPerRou = [];\nconst providersPerReq = [];\n\nconst injectorPerApp = Injector.resolveAndCreate(providersPerApp);\nconst injectorPerMod = injectorPerApp.resolveAndCreateChild(providersPerMod);\nconst injectorPerRou = injectorPerMod.resolveAndCreateChild(providersPerRou);\nconst injectorPerReq = injectorPerRou.resolveAndCreateChild(providersPerReq);\n")),(0,o.kt)("p",null,"Under the hood, Ditsmod performs a similar procedure multiple times for different modules, routes, and requests. For example, if the Ditsmod application has two modules and ten routes, one injector will be created at the application level, one injector for each module (2 pcs), one injector for each route (10 pcs), and one injector for each request. Request-level injectors are automatically removed after processing each request."),(0,o.kt)("p",null,"It should be noted that higher-level injectors do not have access to lower-level injectors. To successfully resolve the dependencies of a particular provider with DI, the provider must be passed to the lowest-level injector among those that will be involved in resolving the dependencies."),(0,o.kt)("p",null,"For example, if you write a class that depends on an HTTP request, you can only pass it to the ",(0,o.kt)("inlineCode",{parentName:"p"},"providersPerReq")," array, as only from this array an injector is formed, to which Ditsmod will automatically add the provider with the HTTP request object. On the other hand, an instance of this class will have access to all of its parent injectors: at the route, module, and application levels. Therefore, this class can depend on providers at any level."),(0,o.kt)("p",null,"You can also write a certain class and pass it to the ",(0,o.kt)("inlineCode",{parentName:"p"},"providersPerMod")," array. In this case, it can only depend on providers at the module or application level. If it depends on the providers you passed in the ",(0,o.kt)("inlineCode",{parentName:"p"},"providersPerRou")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"providersPerReq")," array, you will get an error saying that those providers were not found."),(0,o.kt)("h3",{id:"hierarchy-of-controller-injectors"},"Hierarchy of controller injectors"),(0,o.kt)("p",null,"Any controller, in addition to its own injector at the request level, also has three parent injectors: at the route, module, and application levels. These injectors are also generated based on the providers you pass in the following arrays:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"providersPerApp"),";"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"providersPerMod"),";"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"providersPerRou"),";"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"providersPerReq")," (<-- this is the array from which the injector for the controller is formed).")),(0,o.kt)("h3",{id:"hierarchy-of-service-injectors"},"Hierarchy of service injectors"),(0,o.kt)("p",null,"Unlike the controller, the injector of a certain service can be at any level: at the application, module, route, or request level. In practice, this means that the provider for this service is transferred to one (or several) of the above-mentioned arrays. For example, in the following example, ",(0,o.kt)("inlineCode",{parentName:"p"},"SomeService")," is passed to the injector at the request level, and ",(0,o.kt)("inlineCode",{parentName:"p"},"OtherService")," is passed to the injector at the module level:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{4-5}","{4-5}":!0},"import { Injector } from '@ditsmod/core';\n\nconst providersPerApp = [];\nconst providersPerMod = [OtherService];\nconst providersPerRou = [SomeService];\nconst providersPerReq = [];\n\nconst injectorPerApp = Injector.resolveAndCreate(providersPerApp);\nconst injectorPerMod = injectorPerApp.resolveAndCreateChild(providersPerMod);\nconst injectorPerRou = injectorPerMod.resolveAndCreateChild(providersPerRou);\nconst injectorPerReq = injectorPerRou.resolveAndCreateChild(providersPerReq);\n")),(0,o.kt)("p",null,"In this case, if ",(0,o.kt)("inlineCode",{parentName:"p"},"SomeService")," has a dependency on ",(0,o.kt)("inlineCode",{parentName:"p"},"OtherService"),", DI will be able to create an instance of ",(0,o.kt)("inlineCode",{parentName:"p"},"SomeService")," because a route-level injector can get an instance of ",(0,o.kt)("inlineCode",{parentName:"p"},"OtherService")," from its parent module-level injector. But if on the contrary - ",(0,o.kt)("inlineCode",{parentName:"p"},"OtherService")," will have a dependency on ",(0,o.kt)("inlineCode",{parentName:"p"},"SomeService")," - DI will not be able to create an instance of ",(0,o.kt)("inlineCode",{parentName:"p"},"OtherService"),", because the injector at the module level does not see its child injector at the route level."),(0,o.kt)("h3",{id:"current-injector"},"Current injector"),(0,o.kt)("p",null,"You may rarely need the service or controller injector itself directly, but you can get it in the constructor like any other provider instance:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { injectable, Injector } from '@ditsmod/core';\nimport { FirstService } from './first.service';\n\n@injectable()\nexport class SecondService {\n  constructor(private injector: Injector) {}\n\n  someMethod() {\n    const firstService = this.injector.get(FirstService);  // Lazy loading of dependency\n  }\n}\n")),(0,o.kt)("p",null,"Keep in mind that this way you get an injector that created an instance of this service. The hierarchy level of this injector depends only on the registry of the injector to which ",(0,o.kt)("inlineCode",{parentName:"p"},"SecondService")," was transferred."),(0,o.kt)("h2",{id:"multi-providers"},"Multi-providers"),(0,o.kt)("p",null,"This type of providers exists only in the form of an object, and it differs from ordinary DI providers by the presence of the ",(0,o.kt)("inlineCode",{parentName:"p"},"multi: true")," property. Such providers are advisable to use when there is a need to transfer several providers with the same token to DI at once, so that DI returns the same number of values for these providers in one array:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { Injector } from '@ditsmod/core';\n\nimport { LOCAL } from './tokens';\n\nconst injector = Injector.resolveAndCreate([\n  { token: LOCAL, useValue: 'uk', multi: true },\n  { token: LOCAL, useValue: 'en', multi: true },\n]);\n\nconst locals = injector.get(LOCAL); // ['uk', 'en']\n")),(0,o.kt)("p",null,"Basically, multi-providers allow you to create groups of providers that share a common token. This feature is particularly used to create the ",(0,o.kt)("inlineCode",{parentName:"p"},"HTTP_INTERCEPTORS")," group, as well as to create various extension groups."),(0,o.kt)("p",null,"It is not allowed that both ordinary and multi-providers have the same token in one injector:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { Injector } from '@ditsmod/core';\n\nimport { LOCAL } from './tokens';\n\nconst injector = Injector.resolveAndCreate([\n  { token: LOCAL, useValue: 'uk' },\n  { token: LOCAL, useValue: 'en', multi: true },\n]);\n\nconst locals = injector.get(LOCAL); // Error: Cannot mix multi providers and regular providers\n")),(0,o.kt)("p",null,"Child injectors can return multi-providers of the parent injector only if no providers with the same tokens were passed to them when the child injectors were created:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { Injector } from '@ditsmod/core';\n\nimport { LOCAL } from './tokens';\n\nconst parent = Injector.resolveAndCreate([\n  { token: LOCAL, useValue: 'uk', multi: true },\n  { token: LOCAL, useValue: 'en', multi: true },\n]);\n\nconst child = parent.resolveAndCreateChild([]);\n\nconst locals = child.get(LOCAL); // ['uk', 'en']\n")),(0,o.kt)("p",null,"If both the child and the parent injector have multi-providers with the same token, the child injector will return values only from its array:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { Injector } from '@ditsmod/core';\n\nimport { LOCAL } from './tokens';\n\nconst parent = Injector.resolveAndCreate([\n  { token: LOCAL, useValue: 'uk', multi: true },\n  { token: LOCAL, useValue: 'en', multi: true },\n]);\n\nconst child = parent.resolveAndCreateChild([\n  { token: LOCAL, useValue: '\u0430\u0430', multi: true }\n]);\n\nconst locals = child.get(LOCAL); // ['\u0430\u0430']\n")),(0,o.kt)("h3",{id:"changing-multi-providers"},"Changing multi-providers"),(0,o.kt)("p",null,"To make it possible to change a specific multi-provider, you can do the following:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"first pass the multi-provider and use the ",(0,o.kt)("inlineCode",{parentName:"li"},"useExisting")," property;"),(0,o.kt)("li",{parentName:"ol"},"then transfer the class you want to replace;"),(0,o.kt)("li",{parentName:"ol"},"and at the end of the array, pass the class that replaces the class you need.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { Injector } from '@ditsmod/core';\n\nimport { HTTP_INTERCEPTORS } from './constants';\nimport { DefaultInterceptor } from './default.interceptor';\nimport { MyInterceptor } from './my.interceptor';\n\nconst injector = Injector.resolveAndCreate([\n  { token: HTTP_INTERCEPTORS, useExisting: DefaultInterceptor, multi: true },\n  DefaultInterceptor,\n  { token: DefaultInterceptor, useClass: MyInterceptor }\n]);\n\nconst locals = injector.get(HTTP_INTERCEPTORS); // [MyInterceptor]\n")),(0,o.kt)("p",null,"This construction makes sense, for example, if the first two points are performed somewhere in an external module to which you do not have access to edit, and the third point is already performed by the user of this module."),(0,o.kt)("h2",{id:"passing-of-providers-to-the-di-registry"},"Passing of providers to the DI registry"),(0,o.kt)("p",null,"For one dependency, you need to transfer one or more providers to the DI registry. Most often, providers are passed to the DI registry via module metadata, although sometimes they are passed via controller metadata, or even directly to ",(0,o.kt)("a",{parentName:"p",href:"#injector"},"injectors"),". In the following example, ",(0,o.kt)("inlineCode",{parentName:"p"},"SomeService")," is passed into the ",(0,o.kt)("inlineCode",{parentName:"p"},"providersPerMod")," array:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{7}","{7}":!0},"import { featureModule } from '@ditsmod/core';\n\nimport { SomeService } from './some.service';\n\n@featureModule({\n  providersPerMod: [\n    SomeService\n  ],\n})\nexport class SomeModule {}\n")),(0,o.kt)("p",null,"After such a passing, consumers of providers can use ",(0,o.kt)("inlineCode",{parentName:"p"},"SomeService")," within ",(0,o.kt)("inlineCode",{parentName:"p"},"SomeModule"),". The identical result will be if we pass the same provider in object format:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{7}","{7}":!0},"import { featureModule } from '@ditsmod/core';\n\nimport { SomeService } from './some.service';\n\n@featureModule({\n  providersPerMod: [\n    { token: SomeService, useClass: SomeService }\n  ],\n})\nexport class SomeModule {}\n")),(0,o.kt)("p",null,"And now let's additionally pass another provider with the same token, but this time in the controller metadata:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{8}","{8}":!0},"import { controller } from '@ditsmod/core';\n\nimport { SomeService } from './some.service';\nimport { OtherService } from './other.service';\n\n@controller({\n  providersPerReq: [\n    { token: SomeService, useClass: OtherService }\n  ]\n})\nexport class SomeController {\n  constructor(private someService: SomeService) {}\n  // ...\n}\n")),(0,o.kt)("p",null,'Pay attention to the highlighted line. This is how we say DI: "If this controller has a dependency on a provider with token ',(0,o.kt)("inlineCode",{parentName:"p"},"SomeService"),", it should be substituted with an instance of class ",(0,o.kt)("inlineCode",{parentName:"p"},"OtherService"),'". This substitution will be valid only for this controller. All other controllers in ',(0,o.kt)("inlineCode",{parentName:"p"},"SomeModule")," will receive ",(0,o.kt)("inlineCode",{parentName:"p"},"SomeService")," class instances by ",(0,o.kt)("inlineCode",{parentName:"p"},"SomeService")," token."),(0,o.kt)("p",null,"Similar substitution can be done at the application level and at the module level. This may sometimes be necessary, for example, when you want to have default configuration values at the application level, but custom values of this configuration at the level of a specific module. In this case, pass the default configuration in the root module first:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{7}","{7}":!0},"import { rootModule } from '@ditsmod/core';\n\nimport { ConfigService } from './config.service';\n\n@rootModule({\n  providersPerApp: [\n    ConfigService\n  ],\n})\nexport class AppModule {}\n")),(0,o.kt)("p",null,"And in a certain module, we substitute ",(0,o.kt)("inlineCode",{parentName:"p"},"ConfigService")," with an arbitrary value:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{7}","{7}":!0},"import { featureModule } from '@ditsmod/core';\n\nimport { ConfigService } from './config.service';\n\n@featureModule({\n  providersPerMod: [\n    { token: ConfigService, useValue: { propery1: 'some value' } }\n  ],\n})\nexport class SomeModule {}\n")),(0,o.kt)("h2",{id:"re-adding-providers"},"Re-adding providers"),(0,o.kt)("p",null,"The same provider can be added multiple times in the metadata of a module or controller, but DI will choose the provider that was added last (there is an exception to this rule, but it only applies to multi-providers):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { featureModule } from '@ditsmod/core';\n\n@featureModule({\n  providersPerMod: [\n    { token: 'token1', useValue: 'value1' },\n    { token: 'token1', useValue: 'value2' },\n    { token: 'token1', useValue: 'value3' },\n  ],\n})\nexport class SomeModule {}\n")),(0,o.kt)("p",null,"In this case, within ",(0,o.kt)("inlineCode",{parentName:"p"},"SomeModule"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"value3")," will be issued on ",(0,o.kt)("inlineCode",{parentName:"p"},"token1")," at the module, route or request level."),(0,o.kt)("p",null,"In addition, the same provider can be transmitted simultaneously at several different levels of the hierarchy, but DI will always choose the closest injectors (ie, if a value for a provider is queried at the request level, then the injector at the request level will be looked up first, and only if there is no required provider, DI will rise to the parent injectors):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { featureModule } from '@ditsmod/core';\n\n@featureModule({\n  providersPerMod: [{ token: 'token1', useValue: 'value1' }],\n  providersPerRou: [{ token: 'token1', useValue: 'value2' }],\n  providersPerReq: [{ token: 'token1', useValue: 'value3' }],\n})\nexport class SomeModule {}\n")),(0,o.kt)("p",null,"In this case, within ",(0,o.kt)("inlineCode",{parentName:"p"},"SomeModule"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"value3")," will be returned at the module, route, or request level for ",(0,o.kt)("inlineCode",{parentName:"p"},"token1"),"."),(0,o.kt)("p",null,"Also, if you import a specific provider from an external module and you have a provider with the same token in the current module, the local provider will have higher priority, provided they were passed at the same level of the injector hierarchy."),(0,o.kt)("h2",{id:"when-di-cant-find-the-right-provider"},"When DI can't find the right provider"),(0,o.kt)("p",null,"Remember that when DI cannot find the right provider, there are only three possible reasons:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"you did not transfer the required provider to DI in the metadata of the module or controller (well, or in the case of testing - in ",(0,o.kt)("inlineCode",{parentName:"li"},"Injector.resolveAndCreate()"),");"),(0,o.kt)("li",{parentName:"ol"},"you did not import the module where the provider you need is transferred, or this provider is not exported;"),(0,o.kt)("li",{parentName:"ol"},"you ask the parent injector for the provider from the child injector.")))}d.isMDXComponent=!0},3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(n),h=o,m=u["".concat(l,".").concat(h)]||u[h]||d[h]||i;return n?r.createElement(m,a(a({ref:t},p),{},{components:n})):r.createElement(m,a({ref:t},p))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,a=new Array(i);a[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,a[1]=s;for(var c=2;c<i;c++)a[c]=n[c];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);