"use strict";(self.webpackChunkditsmod_github_io=self.webpackChunkditsmod_github_io||[]).push([[227],{186:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"basic-components-of-the-app/dependency-injection","title":"Dependency Injection","description":"Prerequisites","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/00-basic-components-of-the-app/01-dependency-injection.md","sourceDirName":"00-basic-components-of-the-app","slug":"/basic-components-of-the-app/dependency-injection","permalink":"/en/basic-components-of-the-app/dependency-injection","draft":false,"unlisted":false,"editUrl":"https://github.com/ditsmod/ditsmod/edit/main/website/i18n/en/docusaurus-plugin-content-docs/current/00-basic-components-of-the-app/01-dependency-injection.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Decorators and Reflector","permalink":"/en/basic-components-of-the-app/decorators-and-reflector"},"next":{"title":"Modules","permalink":"/en/basic-components-of-the-app/module"}}');var i=t(4848),o=t(8453);const s={sidebar_position:1},c="Dependency Injection",a={},d=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Injector, tokens and providers",id:"injector-and-providers",level:2},{value:"Short and long forms of declaring dependencies in class methods",id:"short-and-long-forms-of-declaring-dependencies-in-class-methods",level:3},{value:"Provider",id:"provider",level:3},{value:"Hierarchy and encapsulation of injectors",id:"hierarchy-and-encapsulation-of-injectors",level:2},{value:"Chain of dependencies at different levels",id:"chain-of-dependencies-at-different-levels",level:3},{value:"Method <code>injector.pull()</code>",id:"method-injector-pull",level:3},{value:"Hierarchy of injectors in the Ditsmod application",id:"hierarchy-of-injectors-in-the-ditsmod-application",level:3},{value:"Current injector",id:"current-injector",level:3},{value:"Multi-providers",id:"multi-providers",level:2},{value:"Multi-provider substitution",id:"multi-provider-substitution",level:3},{value:"Editing values in the DI register",id:"editing-values-in-the-di-register",level:2},{value:"Decorators <code>optional</code>, <code>fromSelf</code> and <code>skipSelf</code>",id:"optional-fromSelf-skipSelf-decorators",level:2},{value:"optional",id:"optional",level:3},{value:"fromSelf",id:"fromSelf",level:3},{value:"skipSelf",id:"skipSelf",level:3},{value:"When DI can&#39;t find the right provider",id:"when-di-cant-find-the-right-provider",level:2}];function l(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"dependency-injection",children:"Dependency Injection"})}),"\n",(0,i.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,i.jsxs)(n.p,{children:["In the following examples of this section, it is assumed that you have cloned the ",(0,i.jsx)(n.a,{href:"../../#installation",children:"ditsmod/rest-starter"})," repository. This will allow you to get a basic configuration for the application and experiment in the ",(0,i.jsx)(n.code,{children:"src/app"})," folder of that repository."]}),"\n",(0,i.jsxs)(n.p,{children:['Additionally, if you don\'t yet know what exactly reflector does and what "dependency resolution" is, we recommend that you first read the previous section ',(0,i.jsx)(n.a,{href:"/basic-components-of-the-app/decorators-and-reflector/",children:"Decorators and Reflector"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"injector-and-providers",children:"Injector, tokens and providers"}),"\n",(0,i.jsxs)(n.p,{children:["In the ",(0,i.jsx)(n.a,{href:"/basic-components-of-the-app/decorators-and-reflector/",children:"previous section"}),", we saw how a constructor can specify the dependency of one class on another class, and how a dependency chain can be automatically determined using a reflector. Now let's get acquainted with the ",(0,i.jsx)(n.strong,{children:"injector"})," \u2014 a mechanism that, in particular, allows obtaining class instances while considering their dependencies. The injector works very simply: it takes a ",(0,i.jsx)(n.strong,{children:"token"})," and returns a value for that token. Obviously, such functionality requires instructions linking what is requested from the injector to what it provides. These instructions are supplied by so-called ",(0,i.jsx)(n.strong,{children:"providers"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Let's look at the following example, which slightly expands on the last example from the ",(0,i.jsx)(n.a,{href:"/basic-components-of-the-app/decorators-and-reflector/",children:"Decorators and Reflector"})," section:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:"{15-19}",children:"import { Injector, injectable } from '@ditsmod/core';\n\nclass Service1 {}\n\n@injectable()\nclass Service2 {\n  constructor(service1: Service1) {}\n}\n\n@injectable()\nclass Service3 {\n  constructor(service2: Service2) {}\n}\n\nconst injector = Injector.resolveAndCreate([\n  { token: Service1, useClass: Service1 },\n  { token: Service2, useClass: Service2 },\n  { token: Service3, useClass: Service3 }\n]);\nconst service3 = injector.get(Service3); // Instance of Service3\nservice3 === injector.get(Service3); // true\n"})}),"\n",(0,i.jsxs)(n.p,{children:["As you can see, the ",(0,i.jsx)(n.code,{children:"Injector.resolveAndCreate()"})," method takes an array of providers as input and outputs an ",(0,i.jsx)(n.strong,{children:"injector"})," that can create an instance of each provided class using the ",(0,i.jsx)(n.code,{children:"injector.get()"})," method, taking into account the entire dependency chain (",(0,i.jsx)(n.code,{children:"Service3"})," -> ",(0,i.jsx)(n.code,{children:"Service2"})," -> ",(0,i.jsx)(n.code,{children:"Service1"}),")."]}),"\n",(0,i.jsxs)(n.p,{children:["So, what tasks does the injector handle, and what does its ",(0,i.jsx)(n.code,{children:"injector.get()"})," method do:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"When the injector is created, it receives an array of providers \u2014 that is, an array of instructions defining what is requested from it (by token) and what it should return (the value). This stage is very important for the further operation of the injector. If you do not provide all required providers, the injector will not have the appropriate instructions when you request a particular token."}),"\n",(0,i.jsxs)(n.li,{children:["After the injector is created, when the token ",(0,i.jsx)(n.code,{children:"Service3"})," is requested, it scans the provider array and sees the instruction ",(0,i.jsx)(n.code,{children:"{ token: Service3, useClass: Service3 }"}),', so it "understands" that for the ',(0,i.jsx)(n.code,{children:"Service3"})," token it must return an instance of the ",(0,i.jsx)(n.code,{children:"Service3"})," class."]}),"\n",(0,i.jsxs)(n.li,{children:["It then inspects the constructor of the ",(0,i.jsx)(n.code,{children:"Service3"})," class and sees the dependency on ",(0,i.jsx)(n.code,{children:"Service2"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["In the previous step, essentially, the ",(0,i.jsx)(n.code,{children:"Service2"})," token is being requested, so the injector scans the providers and finds the instruction ",(0,i.jsx)(n.code,{children:"{ token: Service2, useClass: Service2 }"}),', so it "understands" that for the ',(0,i.jsx)(n.code,{children:"Service2"})," token it must return an instance of the ",(0,i.jsx)(n.code,{children:"Service2"})," class."]}),"\n",(0,i.jsxs)(n.li,{children:["It then inspects the constructor of ",(0,i.jsx)(n.code,{children:"Service2"})," and sees the dependency on ",(0,i.jsx)(n.code,{children:"Service1"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["In the previous step, the ",(0,i.jsx)(n.code,{children:"Service1"})," token is being requested, so the injector scans the providers and finds the instruction ",(0,i.jsx)(n.code,{children:"{ token: Service1, useClass: Service1 }"}),', so it "understands" that for the ',(0,i.jsx)(n.code,{children:"Service1"})," token it must return an instance of the ",(0,i.jsx)(n.code,{children:"Service1"})," class."]}),"\n",(0,i.jsxs)(n.li,{children:["It then inspects the constructor of ",(0,i.jsx)(n.code,{children:"Service1"}),", finds no dependencies, and therefore creates the ",(0,i.jsx)(n.code,{children:"Service1"})," instance first."]}),"\n",(0,i.jsxs)(n.li,{children:["Next, it creates the ",(0,i.jsx)(n.code,{children:"Service2"})," instance using the ",(0,i.jsx)(n.code,{children:"Service1"})," instance."]}),"\n",(0,i.jsxs)(n.li,{children:["And finally, it creates the ",(0,i.jsx)(n.code,{children:"Service3"})," instance using the ",(0,i.jsx)(n.code,{children:"Service2"})," instance."]}),"\n",(0,i.jsxs)(n.li,{children:["If later the ",(0,i.jsx)(n.code,{children:"Service3"})," instance is requested again, the ",(0,i.jsx)(n.code,{children:"injector.get()"})," method will return the previously created ",(0,i.jsx)(n.code,{children:"Service3"})," instance from the injector\u2019s cache."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["In conclusion, we can state that ",(0,i.jsx)(n.code,{children:"injector.get()"})," indeed works very simply: it receives the ",(0,i.jsx)(n.code,{children:"Service3"})," token and returns its value \u2014 the instance of the ",(0,i.jsx)(n.code,{children:"Service3"})," class. But to operate this way, the injector first takes into account the array of providers supplied to it. Second, it considers the dependency chain of each provider."]}),"\n",(0,i.jsxs)(n.p,{children:["Now let\u2019s break rule 1 and try to pass an empty array when creating the injector. In that case, calling ",(0,i.jsx)(n.code,{children:"injector.get()"})," will throw an error:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"const injector = Injector.resolveAndCreate([]);\nconst service3 = injector.get(Service3); // Error: No provider for Service3!\n"})}),"\n",(0,i.jsxs)(n.p,{children:["As expected, when we pass an empty array instead of a provider array, and then request the ",(0,i.jsx)(n.code,{children:"Service3"})," token from the injector, the injector throws an error, requiring a ",(0,i.jsx)(n.strong,{children:"provider"})," for that token."]}),"\n",(0,i.jsx)(n.p,{children:"By the way, the following two injectors receive equivalent providers:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"const injector1 = Injector.resolveAndCreate([\n  { token: Service1, useClass: Service1 },\n  { token: Service2, useClass: Service2 },\n  { token: Service3, useClass: Service3 }\n]);\nconst injector2 = Injector.resolveAndCreate([\n  Service1,\n  Service2,\n  Service3\n]);\n"})}),"\n",(0,i.jsx)(n.p,{children:"To better understand what providers can look like, let\u2019s pass the injector an array of providers in the following form:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:"{9-12}",children:"import { Injector } from '@ditsmod/core';\n\nclass Service1 {}\nclass Service2 {}\nclass Service3 {}\nclass Service4 {}\n\nconst injector = Injector.resolveAndCreate([\n  { token: Service1, useValue: 'value for Service1' },\n  { token: Service2, useClass: Service2 },\n  { token: Service3, useFactory: () => 'value for Service3' },\n  { token: Service4, useToken: Service3 },\n]);\ninjector.get(Service1); // value for Service1\ninjector.get(Service2); // instance of Service2\ninjector.get(Service3); // value for Service3\ninjector.get(Service4); // value for Service3\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Note that in this example, the ",(0,i.jsx)(n.code,{children:"injectable"})," decorator is not used, since each class shown here does not have a constructor where dependencies could be specified."]}),"\n",(0,i.jsx)(n.p,{children:"As you can see, during injector creation we have now passed an array of providers of four types. Later, each of these types will be formally described, but even without that, it is easy to guess what instructions these providers convey to the injector:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["If the token ",(0,i.jsx)(n.code,{children:"Service1"})," is requested, return the text ",(0,i.jsx)(n.code,{children:"value for Service1"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["If the token ",(0,i.jsx)(n.code,{children:"Service2"})," is requested, first create an instance of ",(0,i.jsx)(n.code,{children:"Service2"}),", and then return it."]}),"\n",(0,i.jsxs)(n.li,{children:["If the token ",(0,i.jsx)(n.code,{children:"Service3"})," is requested, execute the provided function that returns the text ",(0,i.jsx)(n.code,{children:"value for Service3"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["If the token ",(0,i.jsx)(n.code,{children:"Service4"})," is requested, return the value for the ",(0,i.jsx)(n.code,{children:"Service3"})," token, meaning the text ",(0,i.jsx)(n.code,{children:"value for Service3"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"short-and-long-forms-of-declaring-dependencies-in-class-methods",children:"Short and long forms of declaring dependencies in class methods"}),"\n",(0,i.jsx)(n.p,{children:"If a class is used as the constructor parameter type, it can also be used as a token:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:"{7}",children:"import { injectable } from '@ditsmod/core';\n\nclass Service1 {}\n\n@injectable()\nclass Service2 {\n  constructor(service1: Service1) {} // Short form of declaring a dependency\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["It is very important to understand that the token mechanism is needed for the JavaScript runtime, so you cannot use types declared in TypeScript with the keywords ",(0,i.jsx)(n.code,{children:"interface"}),", ",(0,i.jsx)(n.code,{children:"type"}),", ",(0,i.jsx)(n.code,{children:"enum"}),", ",(0,i.jsx)(n.code,{children:"declare"}),", etc. as tokens, because they do not exist in the JavaScript code. Additionally, tokens cannot be imported using the ",(0,i.jsx)(n.code,{children:"type"})," keyword, because such an import will not appear in the JavaScript code."]}),"\n",(0,i.jsx)(n.p,{children:"Unlike a class, an array cannot be used simultaneously as a TypeScript type and as a token. On the other hand, a token may have a type completely unrelated to the dependency it is associated with, so, for example, a string-type token can be associated with a dependency that has any TypeScript type, including arrays, interfaces, enums, etc."}),"\n",(0,i.jsxs)(n.p,{children:["A dependency can be declared in either a short or a long form. In the last example, the ",(0,i.jsx)(n.strong,{children:"short form"})," of declaring a dependency is used, and it has significant limitations because in this way you can specify a dependency only on a particular ",(0,i.jsx)(n.em,{children:"class"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["There is also a ",(0,i.jsx)(n.strong,{children:"long form"})," of declaring a dependency using the ",(0,i.jsx)(n.code,{children:"inject"})," decorator, which allows you to use an alternative token:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:"{10}",children:"import { injectable, inject } from '@ditsmod/core';\n\ninterface InterfaceOfItem {\n  one: string;\n  two: number;\n}\n\n@injectable()\nexport class Service1 {\n  constructor(@inject('some-string') private someArray: InterfaceOfItem[]) {} // Long form of declaring a dependency\n  // ...\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["When ",(0,i.jsx)(n.code,{children:"inject"})," is used, DI considers only the token passed to it. In this case, DI ignores the variable type ",(0,i.jsx)(n.code,{children:"InterfaceOfItem[]"})," and uses the string ",(0,i.jsx)(n.code,{children:"some-string"})," as the token. In other words, DI uses ",(0,i.jsx)(n.code,{children:"some-string"})," as the key to look up the corresponding value for the dependency, and the parameter\u2019s type \u2014 ",(0,i.jsx)(n.code,{children:"InterfaceOfItem[]"})," \u2014 has no significance for DI at all. Thus, DI makes it possible to separate the token from the variable type, allowing the constructor to receive any type of dependency, including various array types or enums."]}),"\n",(0,i.jsxs)(n.p,{children:["A token can be a reference to a class, object, or function; you can also use string or numeric values, as well as symbols, as tokens. For the long form of specifying dependencies, we recommend using an instance of the ",(0,i.jsx)(n.code,{children:"InjectionToken<T>"})," class as the token, since the ",(0,i.jsx)(n.code,{children:"InjectionToken<T>"})," class has a parameterized type ",(0,i.jsx)(n.code,{children:"T"})," that allows specifying the type of data associated with the given token:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:"{5,14}",children:"// tokens.ts\nimport { InjectionToken } from '@ditsmod/core';\nimport { InterfaceOfItem } from './types.js';\n\nconst SOME_TOKEN = new InjectionToken<InterfaceOfItem[]>('SOME_TOKEN');\n\n// second-service.ts\nimport { injectable, inject } from '@ditsmod/core';\nimport { InterfaceOfItem } from './types.js';\nimport { SOME_TOKEN } from './tokens.js';\n\n@injectable()\nexport class Service1 {\n  constructor(@inject(SOME_TOKEN) private someArray: InterfaceOfItem[]) {}\n  // ...\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"provider",children:"Provider"}),"\n",(0,i.jsx)(n.p,{children:"Formally, the provider type is represented by the following declaration:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"import { Class } from '@ditsmod/core';\n\ntype Provider = Class<any> |\n{ token: any, useValue?: any, multi?: boolean } |\n{ token: any, useClass: Class<any>, multi?: boolean } |\n{ token?: any, useFactory: [Class<any>, Class<any>.prototype.methodName], multi?: boolean } |\n{ token?: any, useFactory: (...args: any[]) => any, deps: any[], multi?: boolean } |\n{ token: any, useToken: any, multi?: boolean }\n"})}),"\n",(0,i.jsxs)(n.p,{children:["*",(0,i.jsxs)(n.em,{children:["note that the token for a provider with the ",(0,i.jsx)(n.code,{children:"useFactory"})," property is optional, because DI can use the function or the method of the specified class as a token."]})]}),"\n",(0,i.jsxs)(n.p,{children:["If the provider is represented as an object, its types can be imported from ",(0,i.jsx)(n.code,{children:"@ditsmod/core"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"import { ValueProvider, ClassProvider, FactoryProvider, TokenProvider } from '@ditsmod/core';\n"})}),"\n",(0,i.jsx)(n.p,{children:"More details about each of these types:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"ValueProvider"})," - this type of provider has the ",(0,i.jsx)(n.code,{children:"useValue"})," property which receives any value except ",(0,i.jsx)(n.code,{children:"undefined"}),"; DI will return it unchanged. Example of such provider:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"{ token: 'token1', useValue: 'some value' }\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"ClassProvider"})," - this type of provider has the ",(0,i.jsx)(n.code,{children:"useClass"})," property which receives a class whose instance will be used as the value of this provider. Example of such provider:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"{ token: 'token2', useClass: SomeService }\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"FactoryProvider"})," - this type of provider has the ",(0,i.jsx)(n.code,{children:"useFactory"})," property which can accept arguments of two types:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"ClassFactoryProvider"})," (recommended, due to its better encapsulation) implies that a ",(0,i.jsx)(n.a,{href:"https://www.typescriptlang.org/docs/handbook/2/objects.html#tuple-types",children:"tuple"})," is passed to ",(0,i.jsx)(n.code,{children:"useFactory"}),", where the first element must be a class and the second element must be a method of that class which should return some value for the given token. For example, if the class is:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"import { factoryMethod } from '@ditsmod/core';\n\nexport class ClassWithFactory {\n  @factoryMethod()\n  method1(dependecy1: Dependecy1, dependecy2: Dependecy2) {\n    // ...\n    return '...';\n  }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Then the provider should be passed to the DI registry in the following format:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"{ token: 'token3', useFactory: [ClassWithFactory, ClassWithFactory.prototype.method1] }\n"})}),"\n",(0,i.jsxs)(n.p,{children:["First DI will create an instance of that class, then call its method and get the result, which will be associated with the specified token. The method of the specified class may return any value except ",(0,i.jsx)(n.code,{children:"undefined"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"FunctionFactoryProvider"})," implies that a function can be passed to ",(0,i.jsx)(n.code,{children:"useFactory"}),", which may have parameters \u2014 i.e., it may have dependencies. These dependencies must be explicitly specified in the ",(0,i.jsx)(n.code,{children:"deps"})," property as an array of tokens, and the order of tokens is important:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:"{6}",children:"function fn(service1: Service1, service2: Service2) {\n  // ...\n  return 'some value';\n}\n\n{ token: 'token3', deps: [Service1, Service2], useFactory: fn }\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Note that the ",(0,i.jsx)(n.code,{children:"deps"})," property should contain the ",(0,i.jsx)(n.em,{children:"tokens"})," of providers, and DI interprets them as tokens, not as providers. That is, for these tokens you will still need to provide the corresponding providers in the DI registry. Also note that decorators for parameters (for example ",(0,i.jsx)(n.code,{children:"optional"}),", ",(0,i.jsx)(n.code,{children:"skipSelf"}),", etc.) are not passed in ",(0,i.jsx)(n.code,{children:"deps"}),". If your factory requires parameter decorators, you need to use the ",(0,i.jsx)(n.code,{children:"ClassFactoryProvider"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"TokenProvider"})," \u2014 this provider type has a ",(0,i.jsx)(n.code,{children:"useToken"})," property, into which another token is passed. If you write something like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"{ token: Service2, useToken: Service1 }\n"})}),"\n",(0,i.jsxs)(n.p,{children:["You are telling DI: \u201cWhen provider consumers request the ",(0,i.jsx)(n.code,{children:"Service2"})," token, the value for the ",(0,i.jsx)(n.code,{children:"Service1"})," token should be used\u201d. In other words, this directive creates an alias ",(0,i.jsx)(n.code,{children:"Service2"})," that points to ",(0,i.jsx)(n.code,{children:"Service1"}),". Therefore, a ",(0,i.jsx)(n.code,{children:"TokenProvider"})," is not self-sufficient, unlike other provider types, and it must ultimately point to another provider type \u2014 a ",(0,i.jsx)(n.code,{children:"TypeProvider"}),", ",(0,i.jsx)(n.code,{children:"ValueProvider"}),", ",(0,i.jsx)(n.code,{children:"ClassProvider"}),", or ",(0,i.jsx)(n.code,{children:"FactoryProvider"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:"{4}",children:"import { Injector } from '@ditsmod/core';\n\nconst injector = Injector.resolveAndCreate([\n  { token: 'token1', useValue: 'some value for token1' }, // <-- non TokenProvider\n  { token: 'token2', useToken: 'token1' },\n]);\nconsole.log(injector.get('token1')); // some value for token1\nconsole.log(injector.get('token2')); // some value for token1\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Here, when creating the injector, a ",(0,i.jsx)(n.code,{children:"TokenProvider"})," is passed that points to a ",(0,i.jsx)(n.code,{children:"ValueProvider"}),", which is why this code will work. If you don\u2019t do this, DI will throw an error:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"import { Injector } from '@ditsmod/core';\n\nconst injector = Injector.resolveAndCreate([\n  { token: 'token1', useToken: 'token2' },\n]);\ninjector.get('token1'); // Error! No provider for token2! (token1 -> token2)\n// OR\ninjector.get('token2'); // Error! No provider for token2!\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This happens because you are telling DI: \u201cIf someone requests ",(0,i.jsx)(n.code,{children:"token1"}),", use the value for ",(0,i.jsx)(n.code,{children:"token2"}),"\u201d, but you do not provide a value for ",(0,i.jsx)(n.code,{children:"token2"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["On the other hand, your ",(0,i.jsx)(n.code,{children:"TokenProvider"})," may point to another ",(0,i.jsx)(n.code,{children:"TokenProvider"})," as an intermediate value, but ultimately a ",(0,i.jsx)(n.code,{children:"TokenProvider"})," must always point to a provider of a different type:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:"{4}",children:"import { Injector } from '@ditsmod/core';\n\nconst injector = Injector.resolveAndCreate([\n  { token: 'token1', useValue: 'some value for token1' }, // <-- non TokenProvider\n  { token: 'token2', useToken: 'token1' },\n  { token: 'token3', useToken: 'token2' },\n  { token: 'token4', useToken: 'token3' },\n]);\nconsole.log(injector.get('token4')); // some value for token1\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Now that you are familiar with the concept of a ",(0,i.jsx)(n.strong,{children:"provider"}),", it can be clarified that a ",(0,i.jsx)(n.strong,{children:"dependency"})," is a dependency on the ",(0,i.jsx)(n.strong,{children:"value of a provider"}),". Such a dependency is held by ",(0,i.jsx)(n.strong,{children:"consumers"})," of provider values either in service constructors, or in controllers' constructors or methods, or in the ",(0,i.jsx)(n.code,{children:"get()"})," method of ",(0,i.jsx)(n.a,{href:"#injector-and-providers",children:"injectors"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"hierarchy-and-encapsulation-of-injectors",children:"Hierarchy and encapsulation of injectors"}),"\n",(0,i.jsx)(n.p,{children:"DI provides the ability to create a hierarchy and encapsulation of injectors, involving parent and child injectors. It is thanks to hierarchy and encapsulation that the structure and modularity of an application are built. On the other hand, when encapsulation exists, there are rules that need to be learned to understand when one service can access a certain provider and when it cannot."}),"\n",(0,i.jsx)(n.p,{children:"Let\u2019s consider the following situation. Imagine that you need to create a default configuration for a logger that will be used throughout the entire application. However, for a specific module, you need to increase the log level, for example, to debug that particular module. This means that at the module level, you will modify the configuration, and you need to ensure that it does not affect the default value or other modules. This is exactly what the injector hierarchy is designed for. The highest level in the hierarchy is the application-level injector, from which the injectors for each module branch out. An important feature is that the higher-level injector does not have access to the lower-level injectors in the hierarchy. However, lower-level injectors can access higher-level ones. That\u2019s why module-level injectors can, for example, obtain the logger configuration from the application-level injector if they do not receive an overridden configuration at the module level."}),"\n",(0,i.jsx)(n.p,{children:"Let's look at the following example. For simplicity, decorators are not used at all here, because none of the classes has dependencies:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:"{8-9}",children:"import { Injector } from '@ditsmod/core';\n\nclass Service1 {}\nclass Service2 {}\nclass Service3 {}\nclass Service4 {}\n\nconst parent = Injector.resolveAndCreate([Service1, Service2]); // Parent injector\nconst child = parent.resolveAndCreateChild([Service2, Service3]); // Child injector\n\nchild.get(Service1); // OK\nparent.get(Service1); // OK\n\nparent.get(Service1) === child.get(Service1); // true\n\nchild.get(Service2); // OK\nparent.get(Service2); // OK\n\nparent.get(Service2) === child.get(Service2); // false\n\nchild.get(Service3); // OK\nparent.get(Service3); // Error - No provider for Service3!\n\nchild.get(Service4); // Error - No provider for Service4!\nparent.get(Service4); // Error - No provider for Service4!\n"})}),"\n",(0,i.jsxs)(n.p,{children:["As you can see, when creating the child injector, ",(0,i.jsx)(n.code,{children:"Service1"})," was not passed to it, so when it is asked for the value of this token, it will take it from the parent injector. By the way, there is one non-obvious but very important point here: through the ",(0,i.jsx)(n.code,{children:"get()"})," method, child injectors can request token values from parent injectors if necessary, and they do not create them on their own. That is why this expression returns ",(0,i.jsx)(n.code,{children:"true"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"parent.get(Service1) === child.get(Service1); // true\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Since this is a very important characteristic of the injector hierarchy, let's describe it again: the value of a particular provider is stored in the injector to which the corresponding provider is passed. That is, if during the creation of the child injector the provider with the ",(0,i.jsx)(n.code,{children:"Service1"})," token is not passed to it, then when ",(0,i.jsx)(n.code,{children:"child.get(Service1)"})," is requested, the child injector will not create the value for the ",(0,i.jsx)(n.code,{children:"Service1"})," token. Instead, the child injector will turn to the parent injector, where the provider with the ",(0,i.jsx)(n.code,{children:"Service1"})," token was passed, and therefore the parent injector will be able to create the value for this token. And after the ",(0,i.jsx)(n.code,{children:"Service1"})," instance is created in the parent injector, this same instance will be returned (from the cache) when requested again either through ",(0,i.jsx)(n.code,{children:"child.get(Service1)"})," or through ",(0,i.jsx)(n.code,{children:"parent.get(Service1)"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["When we look at the behavior of injectors when requesting ",(0,i.jsx)(n.code,{children:"Service2"}),", they will behave differently because both injectors were provided with the ",(0,i.jsx)(n.code,{children:"Service2"})," provider during their creation, so each will create its own local version of this service; this is precisely why the expression below returns ",(0,i.jsx)(n.code,{children:"false"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"parent.get(Service2) === child.get(Service2); // false\n"})}),"\n",(0,i.jsxs)(n.p,{children:["When we request ",(0,i.jsx)(n.code,{children:"Service3"})," from the parent injector, it cannot create an instance of ",(0,i.jsx)(n.code,{children:"Service3"})," because it has no connection to the child injector where ",(0,i.jsx)(n.code,{children:"Service3"})," is present."]}),"\n",(0,i.jsxs)(n.p,{children:["And neither injector can return an instance of ",(0,i.jsx)(n.code,{children:"Service4"}),", because this class was not passed to any of them during their creation."]}),"\n",(0,i.jsx)(n.h3,{id:"chain-of-dependencies-at-different-levels",children:"Chain of dependencies at different levels"}),"\n",(0,i.jsxs)(n.p,{children:["The dependency chain of providers can be quite complex, and the injector hierarchy adds even more complexity. Let\u2019s start with a simple case and then make it more complex. In the following example, ",(0,i.jsx)(n.code,{children:"Service"})," depends on ",(0,i.jsx)(n.code,{children:"Config"}),", and both providers are passed to the same injector:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:"{14-15,19}",children:"import { injectable, Injector } from '@ditsmod/core';\n\nclass Config {\n  one: any;\n  two: any;\n}\n\n@injectable()\nclass Service {\n  constructor(public config: Config) {}\n}\n\nconst parent = Injector.resolveAndCreate([\n  Service,\n  { token: Config, useValue: { one: 1, two: 2 } }\n]);\n\nconst child = parent.resolveAndCreateChild([\n  // Empty array\n]);\n\nparent.get(Service).config; // returns { one: 1, two: 2 }\nchild.get(Service).config; // returns { one: 1, two: 2 } from parent injector\n"})}),"\n",(0,i.jsxs)(n.p,{children:["As you can see, in this example both the parent and child injectors are created, and both ",(0,i.jsx)(n.code,{children:"Service"})," and its dependency ",(0,i.jsx)(n.code,{children:"Config"})," are provided only to the parent injector. In this case, when the parent injector is asked for the value of the provider with the ",(0,i.jsx)(n.code,{children:"Service"})," token, it will operate according to the following logic:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["First, it scans its provider array and finds ",(0,i.jsx)(n.code,{children:"Service"}),', so it "knows" that when ',(0,i.jsx)(n.code,{children:"Service"})," is requested, it must return an instance of this class."]}),"\n",(0,i.jsxs)(n.li,{children:["Then it scans the list of dependencies of ",(0,i.jsx)(n.code,{children:"Service"})," and finds ",(0,i.jsx)(n.code,{children:"Config"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Next, it scans its provider array and finds ",(0,i.jsx)(n.code,{children:"{ token: Config, useValue: { one: 1, two: 2 } }"}),', so it "knows" that when ',(0,i.jsx)(n.code,{children:"Config"})," is requested, it must return ",(0,i.jsx)(n.code,{children:"{ one: 1, two: 2 }"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["It then scans the list of dependencies in the provider with the ",(0,i.jsx)(n.code,{children:"Config"})," token and finds none."]}),"\n",(0,i.jsxs)(n.li,{children:["Therefore, to create the ",(0,i.jsx)(n.code,{children:"Service"})," instance, it will use the value ",(0,i.jsx)(n.code,{children:"{ one: 1, two: 2 }"}),". Note that when creating the ",(0,i.jsx)(n.code,{children:"Service"})," instance, the injector does not create an instance of ",(0,i.jsx)(n.code,{children:"Config"}),"; instead, it uses the ready-made object ",(0,i.jsx)(n.code,{children:"{ one: 1, two: 2 }"}),", because these instructions were provided in the provider array when the parent injector was created."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"When the child injector is created with an empty provider array, it will always delegate requests to the parent injector:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"First, the child injector scans its provider array and finds no instructions."}),"\n",(0,i.jsxs)(n.li,{children:["Then the child injector forwards the request to the parent injector and receives the already-created ",(0,i.jsx)(n.code,{children:"Service"})," instance."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["So far, everything is simple. Now let\u2019s complicate the example by passing different values for the ",(0,i.jsx)(n.code,{children:"Config"})," token to the parent and child injectors:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:"{14-15,19}",children:"import { injectable, Injector } from '@ditsmod/core';\n\nclass Config {\n  one: any;\n  two: any;\n}\n\n@injectable()\nclass Service {\n  constructor(public config: Config) {}\n}\n\nconst parent = Injector.resolveAndCreate([\n  Service,\n  { token: Config, useValue: { one: 1, two: 2 } }\n]);\n\nconst child = parent.resolveAndCreateChild([\n  { token: Config, useValue: { one: 11, two: 22 } }\n]);\n"})}),"\n",(0,i.jsx)(n.p,{children:"When examining this example, remember that the parent injector cannot see its child injectors, so any change in the child injector does not affect the parent injector. In other words, for the parent injector, nothing changes here, because it receives exactly the same providers as in the previous example."}),"\n",(0,i.jsxs)(n.p,{children:["But what about the child injector? Now it has its own version of the provider with the ",(0,i.jsx)(n.code,{children:"Config"})," token, which differs from the parent\u2019s version. So how will the child injector behave when the following is requested?"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"child.get(Service).config;\n"})}),"\n",(0,i.jsx)(n.p,{children:"It\u2019s useful to think about this first on your own to better reinforce this behavior. Thought about it? Okay, the logic of this injector will be as follows:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["first it will look through its providers array and will not find a provider with the token ",(0,i.jsx)(n.code,{children:"Service"}),";"]}),"\n",(0,i.jsxs)(n.li,{children:["then it will contact the parent injector and receive a ready-made ",(0,i.jsx)(n.code,{children:"Service"})," instance from it. Therefore, this expression will return ",(0,i.jsx)(n.code,{children:"{ one: 1, two: 2 }"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["A bit unexpected, isn't it? Many would probably assume that the child injector would use its local version of ",(0,i.jsx)(n.code,{children:"Config"})," (that is, ",(0,i.jsx)(n.code,{children:"{ one: 11, two: 22 }"}),") when creating the ",(0,i.jsx)(n.code,{children:"Service"})," instance. But note that in the expression ",(0,i.jsx)(n.code,{children:"child.get(Service).config"}),", the child injector is being asked specifically for ",(0,i.jsx)(n.code,{children:"Service"}),", and this token was not provided in its list of providers. Therefore, it must delegate the request to the parent injector. And because the parent injector resolves the dependencies of ",(0,i.jsx)(n.code,{children:"Service"})," within its own context, it uses its own local version of ",(0,i.jsx)(n.code,{children:"Config"}),", which has the value ",(0,i.jsx)(n.code,{children:"{ one: 1, two: 2 }"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["However, when we request ",(0,i.jsx)(n.code,{children:"Config"})," from the child injector instead of ",(0,i.jsx)(n.code,{children:"Service"}),", it returns its own local value as expected:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"child.get(Config); // { one: 11, two: 22 }\n"})}),"\n",(0,i.jsxs)(n.p,{children:["You can probably guess what needs to be done so that when ",(0,i.jsx)(n.code,{children:"Service"})," is requested from the child injector, the DI resolves its dependency using the child injector\u2019s local provider for the ",(0,i.jsx)(n.code,{children:"Config"})," token. \u2014 Exactly: when creating the child injector, we can include ",(0,i.jsx)(n.code,{children:"Service"})," in its provider array as well."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:"{19}",children:"import { injectable, Injector } from '@ditsmod/core';\n\nclass Config {\n  one: any;\n  two: any;\n}\n\n@injectable()\nclass Service {\n  constructor(public config: Config) {}\n}\n\nconst parent = Injector.resolveAndCreate([\n  Service,\n  { token: Config, useValue: { one: 1, two: 2 } }\n]);\n\nconst child = parent.resolveAndCreateChild([\n  Service,\n  { token: Config, useValue: { one: 11, two: 22 } }\n]);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Now the child injector has both ",(0,i.jsx)(n.code,{children:"Service"})," and ",(0,i.jsx)(n.code,{children:"Config"}),", so it will not refer to the parent injector:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"child.get(Service).config; // { one: 11, two: 22 }\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"method-injector-pull",children:["Method ",(0,i.jsx)(n.code,{children:"injector.pull()"})]}),"\n",(0,i.jsx)(n.p,{children:"This method makes sense to use only in a child injector when it lacks a certain provider that exists in the parent injector, and that provider depends on another provider that exists in the child injector."}),"\n",(0,i.jsxs)(n.p,{children:["For example, when ",(0,i.jsx)(n.code,{children:"Service"})," depends on ",(0,i.jsx)(n.code,{children:"Config"}),", and ",(0,i.jsx)(n.code,{children:"Service"})," exists only in the parent injector, while ",(0,i.jsx)(n.code,{children:"Config"})," exists both in the parent and in the child injector:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:"{16}",children:"import { injectable, Injector } from '@ditsmod/core';\n\nclass Config {\n  one: any;\n  two: any;\n}\n\n@injectable()\nclass Service {\n  constructor(public config: Config) {}\n}\n\nconst parent = Injector.resolveAndCreate([Service, { token: Config, useValue: { one: 1, two: 2 } }]);\nconst child = parent.resolveAndCreateChild([{ token: Config, useValue: { one: 11, two: 22 } }]);\nchild.get(Service).config; // returns from parent injector: { one: 1, two: 2 }\nchild.pull(Service).config; // pulls Service in current injector: { one: 11, two: 22 }\n"})}),"\n",(0,i.jsxs)(n.p,{children:["As you can see, if you use ",(0,i.jsx)(n.code,{children:"child.get(Service)"})," in this case, ",(0,i.jsx)(n.code,{children:"Service"})," will be created with the ",(0,i.jsx)(n.code,{children:"Config"})," from the parent injector. If you use ",(0,i.jsx)(n.code,{children:"child.pull(Service)"}),", it will first pull the required provider into the child injector and then create it in the context of the child injector without adding its value to the injector cache (i.e., ",(0,i.jsx)(n.code,{children:"child.pull(Service)"})," will return a new instance each time)."]}),"\n",(0,i.jsxs)(n.p,{children:["But if the requested provider exists in the child injector, then ",(0,i.jsx)(n.code,{children:"child.pull(Service)"})," will work identically to ",(0,i.jsx)(n.code,{children:"child.get(Service)"})," (with the addition that the provider's value is added to the injector's cache):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:"{14-15}",children:"import { injectable, Injector } from '@ditsmod/core';\n\nclass Config {\n  one: any;\n  two: any;\n}\n\n@injectable()\nclass Service {\n  constructor(public config: Config) {}\n}\n\nconst parent = Injector.resolveAndCreate([]);\nconst child = parent.resolveAndCreateChild([Service, { token: Config, useValue: { one: 11, two: 22 } }]);\nchild.get(Service).config; // { one: 11, two: 22 }\n"})}),"\n",(0,i.jsx)(n.h3,{id:"hierarchy-of-injectors-in-the-ditsmod-application",children:"Hierarchy of injectors in the Ditsmod application"}),"\n",(0,i.jsx)(n.p,{children:"Later in the documentation, you will encounter the following object properties that are passed through module metadata:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"providersPerApp"})," - providers at the application level;"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"providersPerMod"})," - providers at the module level;"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"providersPerRou"})," - providers at the route level;"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"providersPerReq"})," - providers at the HTTP-request level."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Using these arrays, Ditsmod forms different injectors that are related by a hierarchical connection. Such a hierarchy can be simulated as follows:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"import { Injector } from '@ditsmod/core';\n\nconst providersPerApp = [];\nconst providersPerMod = [];\nconst providersPerRou = [];\nconst providersPerReq = [];\n\nconst injectorPerApp = Injector.resolveAndCreate(providersPerApp);\nconst injectorPerMod = injectorPerApp.resolveAndCreateChild(providersPerMod);\nconst injectorPerRou = injectorPerMod.resolveAndCreateChild(providersPerRou);\nconst injectorPerReq = injectorPerRou.resolveAndCreateChild(providersPerReq);\n"})}),"\n",(0,i.jsx)(n.p,{children:"Under the hood, Ditsmod performs a similar procedure many times for different modules, routes, and requests. For example, if a Ditsmod application has two modules and ten routes, there will be one injector at the application level, one injector for each module (2 total), one injector for each route (10 total), and one injector for each request. Injectors at the request level are removed automatically after each request is processed."}),"\n",(0,i.jsxs)(n.p,{children:["Recall that higher-level injectors in the hierarchy have no access to lower-level injectors. This means that ",(0,i.jsx)(n.strong,{children:"when passing a class to a specific injector, it\u2019s necessary to know the lowest level in the hierarchy of its dependencies"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["For example, if you write a class that depends on the HTTP request, you will be able to pass it only to the ",(0,i.jsx)(n.code,{children:"providersPerReq"})," array, because only from this array Ditsmod forms the injector to which Ditsmod will automatically add a provider with the HTTP-request object. On the other hand, an instance of this class will have access to all its parent injectors: at the route level, module level, and application level. Therefore, the class passed to the ",(0,i.jsx)(n.code,{children:"providersPerReq"})," array can depend on providers at any level."]}),"\n",(0,i.jsxs)(n.p,{children:["You can also write a class and pass it into the ",(0,i.jsx)(n.code,{children:"providersPerMod"})," array; in that case it can depend only on providers at the module level or at the application level. If it depends on providers that you passed into ",(0,i.jsx)(n.code,{children:"providersPerRou"})," or ",(0,i.jsx)(n.code,{children:"providersPerReq"}),", you will get an error that these providers are not found."]}),"\n",(0,i.jsx)(n.h3,{id:"current-injector",children:"Current injector"}),"\n",(0,i.jsx)(n.p,{children:"You will rarely need the injector of a service or controller itself, but you can obtain it in a constructor just like any other provider value:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:"{6}",children:"import { injectable, Injector } from '@ditsmod/core';\nimport { FirstService } from './first.service.js';\n\n@injectable()\nexport class SecondService {\n  constructor(private injector: Injector) {}\n\n  someMethod() {\n    const firstService = this.injector.get(FirstService);  // Lazy loading of dependency\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Keep in mind that in this way you get the injector that created the instance of this service. The hierarchy level of that injector depends only on the registry in which ",(0,i.jsx)(n.code,{children:"SecondService"})," was passed."]}),"\n",(0,i.jsx)(n.h2,{id:"multi-providers",children:"Multi-providers"}),"\n",(0,i.jsxs)(n.p,{children:["This kind of providers exist only in the object form and differ from regular DI providers by having the ",(0,i.jsx)(n.code,{children:"multi: true"})," property. Such providers are appropriate when you need to pass several providers with the same token to DI at once so that DI returns the same number of values for these providers in a single array:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"import { Injector } from '@ditsmod/core';\nimport { LOCAL } from './tokens.js';\n\nconst injector = Injector.resolveAndCreate([\n  { token: LOCAL, useValue: 'uk', multi: true },\n  { token: LOCAL, useValue: 'en', multi: true },\n]);\n\nconst locals = injector.get(LOCAL); // ['uk', 'en']\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Essentially, multi-providers allow creating groups of providers that share the same token. This capability is used, for example, to create groups of ",(0,i.jsx)(n.code,{children:"HTTP_INTERCEPTORS"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"It is not allowed for the same token to be both a regular provider and a multi-provider in the same injector:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:"{5-6}",children:"import { Injector } from '@ditsmod/core';\nimport { LOCAL } from './tokens.js';\n\nconst injector = Injector.resolveAndCreate([\n  { token: LOCAL, useValue: 'uk' },\n  { token: LOCAL, useValue: 'en', multi: true },\n]);\n\nconst locals = injector.get(LOCAL); // Error: Cannot mix multi providers and regular providers\n"})}),"\n",(0,i.jsx)(n.p,{children:"Child injectors can return values of multi-providers from the parent injector only if, during their creation, they were not passed providers with the same tokens:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"import { InjectionToken, Injector } from '@ditsmod/core';\n\nconst LOCAL = new InjectionToken('LOCAL');\n\nconst parent = Injector.resolveAndCreate([\n  { token: LOCAL, useValue: 'uk', multi: true },\n  { token: LOCAL, useValue: 'en', multi: true },\n]);\n\nconst child = parent.resolveAndCreateChild([]);\n\nconst locals = child.get(LOCAL); // ['uk', 'en']\n"})}),"\n",(0,i.jsx)(n.p,{children:"If both the child and the parent injector have multi-providers with the same token, the child injector will return only the values from its own array:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"import { Injector } from '@ditsmod/core';\nimport { LOCAL } from './tokens.js';\n\nconst parent = Injector.resolveAndCreate([\n  { token: LOCAL, useValue: 'uk', multi: true },\n  { token: LOCAL, useValue: 'en', multi: true },\n]);\n\nconst child = parent.resolveAndCreateChild([\n  { token: LOCAL, useValue: '\u0430\u0430', multi: true }\n]);\n\nconst locals = child.get(LOCAL); // ['\u0430\u0430']\n"})}),"\n",(0,i.jsx)(n.h3,{id:"multi-provider-substitution",children:"Multi-provider substitution"}),"\n",(0,i.jsx)(n.p,{children:"To make it possible to substitute a specific multi-provider, you can do the following:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["pass a class to the multi-provider object using the ",(0,i.jsx)(n.code,{children:"useToken"})," property;"]}),"\n",(0,i.jsxs)(n.li,{children:["then pass that class as ",(0,i.jsx)(n.code,{children:"ClassProvider"})," or ",(0,i.jsx)(n.code,{children:"TypeProvider"}),";"]}),"\n",(0,i.jsx)(n.li,{children:"next in the providers array add a provider that substitutes that class."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"import { Injector, HTTP_INTERCEPTORS } from '@ditsmod/core';\n\nimport { DefaultInterceptor } from './default.interceptor.js';\nimport { MyInterceptor } from './my.interceptor.js';\n\nconst injector = Injector.resolveAndCreate([\n  { token: HTTP_INTERCEPTORS, useToken: DefaultInterceptor, multi: true },\n  DefaultInterceptor,\n  { token: DefaultInterceptor, useClass: MyInterceptor }\n]);\n\nconst locals = injector.get(HTTP_INTERCEPTORS); // [MyInterceptor]\n"})}),"\n",(0,i.jsx)(n.p,{children:"This construction makes sense, for example, if the first two points are executed in an external module that you cannot edit, and the third point is executed by the user of the current module."}),"\n",(0,i.jsx)(n.h2,{id:"editing-values-in-the-di-register",children:"Editing values in the DI register"}),"\n",(0,i.jsxs)(n.p,{children:["As mentioned earlier, ",(0,i.jsx)(n.em,{children:"providers"})," are passed to the DI registry, from which ",(0,i.jsx)(n.em,{children:"values"})," are then formed, so that ultimately there is a mapping between token and its value:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"token1 -> value15\ntoken2 -> value100\n...\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In addition, it is possible to edit ready ",(0,i.jsx)(n.em,{children:"values"})," in the DI registry:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:"{4}",children:"import { Injector } from '@ditsmod/core';\n\nconst injector = Injector.resolveAndCreate([{ token: 'token1', useValue: undefined }]);\ninjector.setByToken('token1', 'value1');\ninjector.get('token1'); // value1\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Note that in this case a provider with ",(0,i.jsx)(n.code,{children:"token1"})," and the value ",(0,i.jsx)(n.code,{children:"undefined"})," is first passed to the registry, and only then do we change the value for this token. If you try to edit the value for a token that is not present in the registry, DI will throw an error similar to:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:'DiError: Setting value by token failed: cannot find token in register: "token1". Try adding a provider with the same token to the current injector via module or controller metadata.\n'})}),"\n",(0,i.jsxs)(n.p,{children:["In most cases, editing values is used by ",(0,i.jsx)(n.a,{href:"/native-modules/rest/http-interceptors/",children:"interceptors"})," or ",(0,i.jsx)(n.a,{href:"/native-modules/rest/guards/",children:"guards"}),", as they thus pass the result of their work into the registry:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://github.com/ditsmod/ditsmod/blob/core-2.54.0/packages/body-parser/src/body-parser.interceptor.ts#L15",children:"BodyParserInterceptor"}),";"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://github.com/ditsmod/ditsmod/blob/core-2.54.0/examples/14-auth-jwt/src/app/modules/services/auth/bearer.guard.ts#L24",children:"BearerGuard"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["As an alternative to the ",(0,i.jsx)(n.code,{children:"injector.setByToken()"})," method, you can use the equivalent expression:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:"{5}",children:"import { KeyRegistry } from '@ditsmod/core';\n\n// ...\nconst { id } = KeyRegistry.get('token1');\ninjector.setById(id, 'value1');\n// ...\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The advantage of using the ",(0,i.jsx)(n.code,{children:"injector.setById()"})," method is that it is faster than ",(0,i.jsx)(n.code,{children:"injector.setByToken()"}),", but only if you get the ID from the ",(0,i.jsx)(n.code,{children:"KeyRegistry"})," once and then call ",(0,i.jsx)(n.code,{children:"injector.setById()"})," many times."]}),"\n",(0,i.jsxs)(n.h2,{id:"optional-fromSelf-skipSelf-decorators",children:["Decorators ",(0,i.jsx)(n.code,{children:"optional"}),", ",(0,i.jsx)(n.code,{children:"fromSelf"})," and ",(0,i.jsx)(n.code,{children:"skipSelf"})]}),"\n",(0,i.jsx)(n.p,{children:"These decorators are used to control the behavior of the injector when searching for values for a given token."}),"\n",(0,i.jsx)(n.h3,{id:"optional",children:"optional"}),"\n",(0,i.jsxs)(n.p,{children:["Sometimes you may need to mark a dependency in the constructor as optional. Let's look at the following example where a question mark is placed after the ",(0,i.jsx)(n.code,{children:"firstService"})," property, indicating to TypeScript that this property is optional:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:"{6}",children:"import { injectable } from '@ditsmod/core';\nimport { FirstService } from './first.service.js';\n\n@injectable()\nexport class SecondService {\n  constructor(private firstService?: FirstService) {}\n  // ...\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["But DI will ignore this optionality and will throw an error if it cannot create ",(0,i.jsx)(n.code,{children:"FirstService"}),". For this code to work you need to use the ",(0,i.jsx)(n.code,{children:"optional"})," decorator:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:"{6}",children:"import { injectable, optional } from '@ditsmod/core';\nimport { FirstService } from './first.service.js';\n\n@injectable()\nexport class SecondService {\n  constructor(@optional() private firstService?: FirstService) {}\n  // ...\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"fromSelf",children:"fromSelf"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"fromSelf"})," and ",(0,i.jsx)(n.code,{children:"skipSelf"})," decorators make sense when there is some hierarchy of injectors. The ",(0,i.jsx)(n.code,{children:"fromSelf"})," decorator is used very rarely."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"import { injectable, fromSelf, Injector } from '@ditsmod/core';\n\nclass Service1 {}\n\n@injectable()\nclass Service2 {\n  constructor(@fromSelf() public service1: Service1) {}\n}\n\nconst parent = Injector.resolveAndCreate([Service1, Service2]);\nconst child = parent.resolveAndCreateChild([Service2]);\n\nconst service2 = parent.get(Service2) as Service2;\nservice2.service1 instanceof Service1; // true\n\nchild.get(Service2); // Error - Service1 not found\n"})}),"\n",(0,i.jsxs)(n.p,{children:["As you can see, ",(0,i.jsx)(n.code,{children:"Service2"})," depends on ",(0,i.jsx)(n.code,{children:"Service1"}),", and the ",(0,i.jsx)(n.code,{children:"fromSelf"}),' decorator tells DI: "When creating an instance of ',(0,i.jsx)(n.code,{children:"Service1"}),", use only the same injector that creates the instance of ",(0,i.jsx)(n.code,{children:"Service2"}),', and do not refer to the parent injector". When the parent injector is created, it is given both required services, so when requesting the token ',(0,i.jsx)(n.code,{children:"Service2"})," it will successfully resolve the dependency and return an instance of that class."]}),"\n",(0,i.jsxs)(n.p,{children:["But when creating the child injector, ",(0,i.jsx)(n.code,{children:"Service1"})," was not passed to it, so when requesting the token ",(0,i.jsx)(n.code,{children:"Service2"})," it will not be able to resolve that service's dependency. If you remove the ",(0,i.jsx)(n.code,{children:"fromSelf"})," decorator from the constructor, then the child injector will successfully resolve the dependency for ",(0,i.jsx)(n.code,{children:"Service2"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"skipSelf",children:"skipSelf"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"skipSelf"})," decorator is used more often than ",(0,i.jsx)(n.code,{children:"fromSelf"}),", but still rarely."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"import { injectable, skipSelf, Injector } from '@ditsmod/core';\n\nclass Service1 {}\n\n@injectable()\nclass Service2 {\n  constructor(@skipSelf() public service1: Service1) {}\n}\n\nconst parent = Injector.resolveAndCreate([Service1, Service2]);\nconst child = parent.resolveAndCreateChild([Service2]);\n\nparent.get(Service2); // Error - Service1 not found\n\nconst service2 = child.get(Service2) as Service2;\nservice2.service1 instanceof Service1; // true\n"})}),"\n",(0,i.jsxs)(n.p,{children:["As you can see, ",(0,i.jsx)(n.code,{children:"Service2"})," depends on ",(0,i.jsx)(n.code,{children:"Service1"}),", and the ",(0,i.jsx)(n.code,{children:"skipSelf"}),' decorator tells DI: "When creating an instance of ',(0,i.jsx)(n.code,{children:"Service1"}),", skip the injector that will create the instance of ",(0,i.jsx)(n.code,{children:"Service2"}),' and immediately refer to the parent injector". When the parent injector is created, it is given both necessary services, but due to ',(0,i.jsx)(n.code,{children:"skipSelf"})," it cannot use the value for ",(0,i.jsx)(n.code,{children:"Service1"})," from its own registry, therefore it will not be able to resolve the specified dependency."]}),"\n",(0,i.jsxs)(n.p,{children:["When creating the child injector, it was not passed ",(0,i.jsx)(n.code,{children:"Service1"}),", but it can refer to the parent injector for it. Therefore the child injector successfully resolves the dependency for ",(0,i.jsx)(n.code,{children:"Service2"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"when-di-cant-find-the-right-provider",children:"When DI can't find the right provider"}),"\n",(0,i.jsx)(n.p,{children:"Remember that when DI cannot find the required provider, there are only three possible reasons:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["you did not pass the required provider to DI in module or controller metadata (or, in testing, to ",(0,i.jsx)(n.code,{children:"Injector.resolveAndCreate()"}),");"]}),"\n",(0,i.jsx)(n.li,{children:"you did not import the module that provides the required provider, or that provider is not exported;"}),"\n",(0,i.jsx)(n.li,{children:"you are requesting a provider from the parent injector that exists only in a child injector."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>c});var r=t(6540);const i={},o=r.createContext(i);function s(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);