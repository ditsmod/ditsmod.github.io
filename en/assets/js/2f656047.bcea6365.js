"use strict";(self.webpackChunkditsmod_github_io=self.webpackChunkditsmod_github_io||[]).push([[793],{3139:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"components-of-ditsmod-app/dependency-injection","title":"Dependency Injection","description":"Decorators and reflector","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/00-components-of-ditsmod-app/02-dependency-injection.md","sourceDirName":"00-components-of-ditsmod-app","slug":"/components-of-ditsmod-app/dependency-injection","permalink":"/en/components-of-ditsmod-app/dependency-injection","draft":false,"unlisted":false,"editUrl":"https://github.com/ditsmod/ditsmod/edit/main/website/i18n/en/docusaurus-plugin-content-docs/current/00-components-of-ditsmod-app/02-dependency-injection.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Router, controllers and services","permalink":"/en/components-of-ditsmod-app/controllers-and-services"},"next":{"title":"HTTP Interceptors","permalink":"/en/components-of-ditsmod-app/http-interceptors"}}');var i=n(4848),o=n(8453);const s={sidebar_position:2},c="Dependency Injection",a={},d=[{value:"Decorators and reflector",id:"decorators-and-reflector",level:2},{value:"Injector and providers",id:"injector-and-providers",level:2},{value:"Hierarchy and encapsulation of injectors",id:"hierarchy-and-encapsulation-of-injectors",level:2},{value:"Hierarchy of injectors in the Ditsmod application",id:"hierarchy-of-injectors-in-the-ditsmod-application",level:3},{value:"Controller injector hierarchy",id:"controller-injector-hierarchy",level:3},{value:"Service injector hierarchy",id:"service-injector-hierarchy",level:3},{value:"Method <code>injector.pull()</code>",id:"method-injector-pull",level:3},{value:"Current injector",id:"current-injector",level:3},{value:"Multi-providers",id:"multi-providers",level:2},{value:"Multi-provider substitution",id:"multi-provider-substitution",level:3},{value:"Transfer of providers to the DI registry",id:"transfer-of-providers-to-the-di-registry",level:2},{value:"Re-adding providers",id:"re-adding-providers",level:2},{value:"Editing values in the DI register",id:"editing-values-in-the-di-register",level:2},{value:"Decorators <code>optional</code>, <code>fromSelf</code> and <code>skipSelf</code>",id:"optional-fromSelf-skipSelf-decorators",level:2},{value:"optional",id:"optional",level:3},{value:"fromSelf",id:"fromself",level:3},{value:"skipSelf",id:"skipself",level:3},{value:"When DI can&#39;t find the right provider",id:"when-di-cant-find-the-right-provider",level:2}];function l(e){const r={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.header,{children:(0,i.jsx)(r.h1,{id:"dependency-injection",children:"Dependency Injection"})}),"\n",(0,i.jsx)(r.h2,{id:"decorators-and-reflector",children:"Decorators and reflector"}),"\n",(0,i.jsx)(r.p,{children:"Let's start with the obvious \u2014 TypeScript syntax partially differs from JavaScript syntax because it provides capabilities for static typing. JavaScript has no static typing at all, but during compilation of TypeScript code to JavaScript the compiler can emit additional JavaScript code that can be used to obtain information about a given static type."}),"\n",(0,i.jsxs)(r.p,{children:["Let's do a quick experiment. In the following code the constructor of ",(0,i.jsx)(r.code,{children:"Service2"})," specifies a static type for the parameter ",(0,i.jsx)(r.code,{children:"service1"}),":"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",children:"class Service1 {}\n\nclass Service2 {\n  constructor(service1: Service1) {}\n}\n"})}),"\n",(0,i.jsx)(r.p,{children:"After compilation this code will look like:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",children:"class Service1 {\n}\nclass Service2 {\n    constructor(service1) { }\n}\n"})}),"\n",(0,i.jsxs)(r.p,{children:["That is, the information about the parameter type in the constructor of ",(0,i.jsx)(r.code,{children:"Service2"})," is lost. But if we configure the TypeScript compiler in a certain way and use a class decorator, the TypeScript compiler will emit more JavaScript code with information about the static typing. For example, let's use the ",(0,i.jsx)(r.code,{children:"injectable"})," decorator:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",metastring:"{1,5}",children:"import { injectable } from '@ditsmod/core';\n\nclass Service1 {}\n\n@injectable()\nclass Service2 {\n  constructor(service1: Service1) {}\n}\n"})}),"\n",(0,i.jsx)(r.p,{children:"Now the TypeScript compiler transforms this code into the following JavaScript code:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-js",metastring:"{18}",children:'var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);\n};\nimport { injectable } from \'@ditsmod/core\';\nclass Service1 {\n}\nlet Service2 = class Service2 {\n    constructor(service1) { }\n};\nService2 = __decorate([\n    injectable(),\n    __metadata("design:paramtypes", [Service1])\n], Service2);\n'})}),"\n",(0,i.jsxs)(r.p,{children:["Fortunately, you will rarely need to analyze compiled code, but to get a general idea of the mechanism of transferring static typing into JavaScript code, it can sometimes be useful to look at it. The most interesting part is located in the last four lines. Obviously, the TypeScript compiler now associates the array ",(0,i.jsx)(r.code,{children:"[Service1]"})," with ",(0,i.jsx)(r.code,{children:"Service2"}),". This array is the information about the static types of the parameters that the compiler found in the constructor of ",(0,i.jsx)(r.code,{children:"Service2"}),"."]}),"\n",(0,i.jsxs)(r.p,{children:["Further analysis of the compiled code indicates that the ",(0,i.jsx)(r.code,{children:"Reflect"})," class is used to preserve metadata about static typing. It is assumed that this class is imported from the ",(0,i.jsx)(r.a,{href:"https://github.com/ditsmod/ditsmod/blob/core-2.54.0/packages/core/package.json#L53",children:"reflect-metadata"})," library. The API of that library is then used by Ditsmod to read the metadata shown above. This is handled by the so-called ",(0,i.jsx)(r.strong,{children:"reflector"}),"."]}),"\n",(0,i.jsxs)(r.p,{children:["Let's see what tools Ditsmod has for working with the reflector. Let's complicate the previous example to see how metadata can be extracted and complex dependency chains formed. Consider three classes with the following dependency chain ",(0,i.jsx)(r.code,{children:"Service3"})," -> ",(0,i.jsx)(r.code,{children:"Service2"})," -> ",(0,i.jsx)(r.code,{children:"Service1"}),":"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",children:"import { injectable, getDependencies } from '@ditsmod/core';\n\nclass Service1 {}\n\n@injectable()\nclass Service2 {\n  constructor(service1: Service1) {}\n}\n\n@injectable()\nclass Service3 {\n  constructor(service2: Service2) {}\n}\n\nconsole.log(getDependencies(Service3)); // [ { token: [class Service2], required: true } ]\n"})}),"\n",(0,i.jsxs)(r.p,{children:["The ",(0,i.jsx)(r.code,{children:"getDependencies()"})," function uses the reflector and returns the array of direct dependencies of ",(0,i.jsx)(r.code,{children:"Service3"}),". You probably guess that if you pass ",(0,i.jsx)(r.code,{children:"Service2"})," to ",(0,i.jsx)(r.code,{children:"getDependencies()"})," you'll see the dependency on ",(0,i.jsx)(r.code,{children:"Service1"}),". Thus you can ",(0,i.jsx)(r.strong,{children:"automatically"})," compose the whole dependency chain ",(0,i.jsx)(r.code,{children:"Service3"})," -> ",(0,i.jsx)(r.code,{children:"Service2"})," -> ",(0,i.jsx)(r.code,{children:"Service1"}),'. This process in DI is called "dependency resolution". And the word "automatically" is purposely bolded here because it\'s a very important feature supported by DI. Users pass only ',(0,i.jsx)(r.code,{children:"Service3"})," to the DI, and they don't need to manually investigate what this class depends on \u2014 DI can resolve the dependency automatically. By the way, even the ",(0,i.jsx)(r.code,{children:"getDependencies()"})," function itself will rarely be used by users, except in some rare special cases."]}),"\n",(0,i.jsx)(r.p,{children:"Strictly speaking, the mechanism of saving and obtaining metadata from the reflector via decorators is not Dependency Injection. But Dependency Injection heavily uses decorators and the reflector in its operation, so sometimes this documentation may say that DI receives information about a class's dependencies, while in fact the reflector is responsible for that."}),"\n",(0,i.jsx)(r.h2,{id:"injector-and-providers",children:"Injector and providers"}),"\n",(0,i.jsx)(r.p,{children:"Let's look at the following example with an injector and providers:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",metastring:"{15-19}",children:"import { Injector, injectable } from '@ditsmod/core';\n\nclass Service1 {}\n\n@injectable()\nclass Service2 {\n  constructor(service1: Service1) {}\n}\n\n@injectable()\nclass Service3 {\n  constructor(service2: Service2) {}\n}\n\nconst injector = Injector.resolveAndCreate([\n  Service1,\n  Service2,\n  Service3\n]);\nconst service3 = injector.get(Service3); // Instance of Service3\nservice3 === injector.get(Service3); // true\n"})}),"\n",(0,i.jsxs)(r.p,{children:["As you can see, the ",(0,i.jsx)(r.code,{children:"Injector.resolveAndCreate()"})," method takes an array of classes as input and returns an injector that can create an instance of each provided class via the ",(0,i.jsx)(r.code,{children:"injector.get()"})," method, taking into account the entire dependency chain (",(0,i.jsx)(r.code,{children:"Service3"})," -> ",(0,i.jsx)(r.code,{children:"Service2"})," -> ",(0,i.jsx)(r.code,{children:"Service1"}),")."]}),"\n",(0,i.jsxs)(r.p,{children:["What ",(0,i.jsx)(r.code,{children:"injector.get()"})," does:"]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["when ",(0,i.jsx)(r.code,{children:"Service3"})," is requested, it inspects the constructor of that class and sees a dependency on ",(0,i.jsx)(r.code,{children:"Service2"}),";"]}),"\n",(0,i.jsxs)(r.li,{children:["then it inspects the constructor of ",(0,i.jsx)(r.code,{children:"Service2"})," and sees a dependency on ",(0,i.jsx)(r.code,{children:"Service1"}),";"]}),"\n",(0,i.jsxs)(r.li,{children:["then it inspects the constructor of ",(0,i.jsx)(r.code,{children:"Service1"}),", finds no dependencies there, and therefore creates an instance of ",(0,i.jsx)(r.code,{children:"Service1"})," first;"]}),"\n",(0,i.jsxs)(r.li,{children:["then it creates an instance of ",(0,i.jsx)(r.code,{children:"Service2"})," using the instance of ",(0,i.jsx)(r.code,{children:"Service1"}),";"]}),"\n",(0,i.jsxs)(r.li,{children:["and finally it creates an instance of ",(0,i.jsx)(r.code,{children:"Service3"})," using the instance of ",(0,i.jsx)(r.code,{children:"Service2"}),";"]}),"\n",(0,i.jsxs)(r.li,{children:["if the instance ",(0,i.jsx)(r.code,{children:"Service3"})," is requested again later, ",(0,i.jsx)(r.code,{children:"injector.get()"})," will return the previously created ",(0,i.jsx)(r.code,{children:"Service3"})," instance from this injector's cache."]}),"\n"]}),"\n",(0,i.jsxs)(r.p,{children:["An important feature here is that DI can read the dependency chain of ",(0,i.jsx)(r.code,{children:"Service3"})," using the reflector without passing an array of the specified classes to the injector, but ",(0,i.jsx)(r.code,{children:"injector.get()"})," will throw an error in such a case if you try to obtain an instance of a class:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",children:"const injector = Injector.resolveAndCreate([]);\nconst service3 = injector.get(Service3); // Error: No provider for Service3!\n"})}),"\n",(0,i.jsx)(r.p,{children:"Why does this happen? To better understand this, let's rewrite the previous example by passing providers to the injector in another form:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",metastring:"{16-18}",children:"import { Injector, injectable } from '@ditsmod/core';\n\nclass Service1 {}\n\n@injectable()\nclass Service2 {\n  constructor(service1: Service1) {}\n}\n\n@injectable()\nclass Service3 {\n  constructor(service2: Service2) {}\n}\n\nconst injector = Injector.resolveAndCreate([\n  { token: Service1, useClass: Service1 },\n  { token: Service2, useClass: Service2 },\n  { token: Service3, useClass: Service3 },\n]);\nconst service1 = injector.get(Service1); // instance of Service1\nconst service2 = injector.get(Service2); // instance of Service2\nconst service3 = injector.get(Service3); // instance of Service3\n"})}),"\n",(0,i.jsxs)(r.p,{children:["As you can see, now when creating the injector, instead of classes we passed an array of objects. These objects are also called ",(0,i.jsx)(r.strong,{children:"providers"}),". Each provider is an instruction for the DI:"]}),"\n",(0,i.jsxs)(r.ol,{children:["\n",(0,i.jsxs)(r.li,{children:["If the token ",(0,i.jsx)(r.code,{children:"Service1"})," is requested, create an instance of ",(0,i.jsx)(r.code,{children:"Service1"})," first and then return it."]}),"\n",(0,i.jsxs)(r.li,{children:["If the token ",(0,i.jsx)(r.code,{children:"Service2"})," is requested, create an instance of ",(0,i.jsx)(r.code,{children:"Service2"})," first and then return it."]}),"\n",(0,i.jsxs)(r.li,{children:["If the token ",(0,i.jsx)(r.code,{children:"Service3"})," is requested, create an instance of ",(0,i.jsx)(r.code,{children:"Service3"})," first and then return it."]}),"\n"]}),"\n",(0,i.jsxs)(r.p,{children:["Now that we passed providers to the injector as instructions, it becomes clearer that the injector needs instructions for mapping between what is requested (the token) and what it returns (the value). In the documentation this mapping may also be called the ",(0,i.jsx)(r.strong,{children:"provider registry"}),", because the instructions for mapping are supplied by providers. As for tokens \u2014 for the injector a token is an identifier used to find a value in the provider registry."]}),"\n",(0,i.jsx)(r.p,{children:"By the way, in the previous example, when we passed an array of classes, the injector treated them as providers as well. That is, providers can be in two forms: either a class, or an object with instructions for creating a particular value. This means both of the following injectors receive configurations with equivalent instructions:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",children:"const injector1 = Injector.resolveAndCreate([\n  Service1,\n  Service2,\n  Service3,\n]);\nconst injector2 = Injector.resolveAndCreate([\n  { token: Service1, useClass: Service1 },\n  { token: Service2, useClass: Service2 },\n  { token: Service3, useClass: Service3 },\n]);\n"})}),"\n",(0,i.jsx)(r.p,{children:"Formally, the provider type is represented by the following declaration:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",children:"import { Class } from '@ditsmod/core';\n\ntype Provider = Class<any> |\n{ token: any, useValue?: any, multi?: boolean } |\n{ token: any, useClass: Class<any>, multi?: boolean } |\n{ token?: any, useFactory: [Class<any>, Class<any>.prototype.methodName], multi?: boolean } |\n{ token?: any, useFactory: (...args: any[]) => any, deps: any[], multi?: boolean } |\n{ token: any, useToken: any, multi?: boolean }\n"})}),"\n",(0,i.jsxs)(r.p,{children:["*",(0,i.jsxs)(r.em,{children:["note that the token for a provider with the ",(0,i.jsx)(r.code,{children:"useFactory"})," property is optional, because DI can use the function or the method of the specified class as a token."]})]}),"\n",(0,i.jsx)(r.p,{children:"If a provider is represented as an object, its properties may be of the following types:"}),"\n",(0,i.jsxs)(r.ol,{children:["\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"ValueProvider"})," - this type of provider has the ",(0,i.jsx)(r.code,{children:"useValue"})," property which receives any value except ",(0,i.jsx)(r.code,{children:"undefined"}),"; DI will return it unchanged. Example of such provider:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",children:"{ token: 'token2', useValue: 'some value' }\n"})}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"ClassProvider"})," - this type of provider has the ",(0,i.jsx)(r.code,{children:"useClass"})," property which receives a class whose instance will be used as the value of this provider. Example of such provider:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",children:"{ token: 'token1', useClass: SomeService }\n"})}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"FactoryProvider"})," - this type of provider has the ",(0,i.jsx)(r.code,{children:"useFactory"})," property which can accept arguments of two types:"]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"ClassFactoryProvider"})," (recommended, due to its better encapsulation) implies that a ",(0,i.jsx)(r.a,{href:"https://www.typescriptlang.org/docs/handbook/2/objects.html#tuple-types",children:"tuple"})," is passed to ",(0,i.jsx)(r.code,{children:"useFactory"}),", where the first element must be a class and the second element must be a method of that class which should return some value for the given token. For example, if the class is:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",children:"import { factoryMethod } from '@ditsmod/core';\n\nexport class ClassWithFactory {\n  @factoryMethod()\n  method1(dependecy1: Dependecy1, dependecy2: Dependecy2) {\n    // ...\n    return '...';\n  }\n}\n"})}),"\n",(0,i.jsx)(r.p,{children:"Then the provider should be passed to the DI registry in the following format:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",children:"{ token: 'token3', useFactory: [ClassWithFactory, ClassWithFactory.prototype.method1] }\n"})}),"\n",(0,i.jsxs)(r.p,{children:["First DI will create an instance of that class, then call its method and get the result, which will be associated with the specified token. The method of the specified class may return any value except ",(0,i.jsx)(r.code,{children:"undefined"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"FunctionFactoryProvider"})," implies that a function can be passed to ",(0,i.jsx)(r.code,{children:"useFactory"}),", which may have parameters \u2014 i.e., it may have dependencies. These dependencies must be explicitly specified in the ",(0,i.jsx)(r.code,{children:"deps"})," property as an array of tokens, and the order of tokens is important:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",metastring:"{6}",children:"function fn1(service1: Service1, service2: Service2) {\n  // ...\n  return 'some value';\n}\n\n{ token: 'token3', deps: [Service1, Service2], useFactory: fn1 }\n"})}),"\n",(0,i.jsxs)(r.p,{children:["Note that the ",(0,i.jsx)(r.code,{children:"deps"})," property should contain the ",(0,i.jsx)(r.em,{children:"tokens"})," of providers, and DI interprets them as tokens, not as providers. That is, for these tokens you will still need to ",(0,i.jsx)(r.a,{href:"#transfer-of-providers-to-the-di-registry",children:"provide the corresponding providers"})," in the DI registry. Also note that decorators for parameters (for example ",(0,i.jsx)(r.code,{children:"optional"}),", ",(0,i.jsx)(r.code,{children:"skipSelf"}),", etc.) are not passed in ",(0,i.jsx)(r.code,{children:"deps"}),". If your factory requires parameter decorators, you need to use the ",(0,i.jsx)(r.code,{children:"ClassFactoryProvider"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"TokenProvider"})," - this type of provider has the ",(0,i.jsx)(r.code,{children:"useToken"})," property which receives another token. If you write:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",children:"{ token: SecondService, useToken: FirstService }\n"})}),"\n",(0,i.jsxs)(r.p,{children:['you are telling DI: "When consumers request the token ',(0,i.jsx)(r.code,{children:"SecondService"}),", use the value for the token ",(0,i.jsx)(r.code,{children:"FirstService"}),'". In other words, this directive creates an alias ',(0,i.jsx)(r.code,{children:"SecondService"})," that points to ",(0,i.jsx)(r.code,{children:"FirstService"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(r.p,{children:["Now that you are familiar with the concept of a ",(0,i.jsx)(r.strong,{children:"provider"}),", it can be clarified that a ",(0,i.jsx)(r.strong,{children:"dependency"})," is a dependency on the ",(0,i.jsx)(r.strong,{children:"value of a provider"}),". Such a dependency is held by ",(0,i.jsx)(r.strong,{children:"consumers"})," of provider values either in service constructors, or in controllers' constructors or methods, or in the ",(0,i.jsx)(r.code,{children:"get()"})," method of ",(0,i.jsx)(r.a,{href:"#injector-and-providers",children:"injectors"})," (this will be mentioned later)."]}),"\n",(0,i.jsx)(r.h2,{id:"hierarchy-and-encapsulation-of-injectors",children:"Hierarchy and encapsulation of injectors"}),"\n",(0,i.jsx)(r.p,{children:"DI provides the ability to create a hierarchy and encapsulation of injectors, involving parent and child injectors. It is thanks to hierarchy and encapsulation that the structure and modularity of an application are built. On the other hand, when encapsulation exists, there are rules that need to be learned to understand when one service can access a certain provider and when it cannot."}),"\n",(0,i.jsx)(r.p,{children:"Let's consider the following situation. Imagine you need to create a default configuration for the entire application and a custom configuration for certain modules. This means that at the level of some modules you will change the configuration, and you need it not to affect the default value and other modules. The following pseudo-code shows the basic concept that provides such behavior:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",children:"// Parent injector\nclass PerApplicationInjector {\n  locale = 'en'\n  token1 = 'value1'\n  token2 = 'value2'\n  // ...\n}\n\n// Child injector\nclass PerModuleInjector {\n  parent: perApplicationInjector;\n  locale = 'uk'\n}\n"})}),"\n",(0,i.jsxs)(r.p,{children:["A child injector can refer to a parent injector because it has the corresponding ",(0,i.jsx)(r.code,{children:"parent"})," property with an instance of the parent injector. On the other hand, a parent injector has no access to a child injector, so it can only find values for those providers that were passed directly to it. This is a very important feature in the injector hierarchy, so we'll repeat it once more: child injectors can refer to parent injectors, and parent injectors cannot refer to child injectors."]}),"\n",(0,i.jsx)(r.p,{children:"Let's look at the following example. For simplicity, decorators are not used at all here, because none of the classes has dependencies:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",metastring:"{8-9}",children:"import { Injector } from '@ditsmod/core';\n\nclass Service1 {}\nclass Service2 {}\nclass Service3 {}\nclass Service4 {}\n\nconst parent = Injector.resolveAndCreate([Service1, Service2]); // Parent injector\nconst child = parent.resolveAndCreateChild([Service2, Service3]); // Child injector\n\nchild.get(Service1); // OK\nparent.get(Service1); // OK\n\nparent.get(Service1) === child.get(Service1); // true\n\nchild.get(Service2); // OK\nparent.get(Service2); // OK\n\nparent.get(Service2) === child.get(Service2); // false\n\nchild.get(Service3); // OK\nparent.get(Service3); // Error - No provider for Service3!\n\nchild.get(Service4); // Error - No provider for Service4!\nparent.get(Service4); // Error - No provider for Service4!\n"})}),"\n",(0,i.jsxs)(r.p,{children:["As you can see, when creating the child injector, ",(0,i.jsx)(r.code,{children:"Service1"})," was not passed to it, so when requesting an instance of this class it will refer to the parent. By the way, there is one non-obvious but very important point here: through the ",(0,i.jsx)(r.code,{children:"get()"})," method, child injectors only request certain instances of classes from parent injectors \u2014 they do not create them by themselves. That's why this expression returns ",(0,i.jsx)(r.code,{children:"true"}),":"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",children:"parent.get(Service1) === child.get(Service1); // true\n"})}),"\n",(0,i.jsxs)(r.p,{children:["Because this is a very important feature in the injector hierarchy, let's describe it again: the value of a given provider is stored in the injector to which that provider was passed. That is, if ",(0,i.jsx)(r.code,{children:"Service1"})," was not passed to the child injector when it was created, then ",(0,i.jsx)(r.code,{children:"child.get(Service1)"})," may return an instance of ",(0,i.jsx)(r.code,{children:"Service1"}),", but it will be created in the parent injector. And after the instance of ",(0,i.jsx)(r.code,{children:"Service1"})," is created in the parent injector, the same instance will be returned (from the cache) on subsequent requests either via ",(0,i.jsx)(r.code,{children:"child.get(Service1)"})," or via ",(0,i.jsx)(r.code,{children:"parent.get(Service1)"}),". This is also an important feature because it determines where the state of a particular provider will be stored."]}),"\n",(0,i.jsxs)(r.p,{children:["When we look at the behavior of injectors when requesting ",(0,i.jsx)(r.code,{children:"Service2"}),", they will behave differently because both injectors were provided with the ",(0,i.jsx)(r.code,{children:"Service2"})," provider during their creation, so each will create its own local version of this service; this is precisely why the expression below returns ",(0,i.jsx)(r.code,{children:"false"}),":"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",children:"parent.get(Service2) === child.get(Service2); // false\n"})}),"\n",(0,i.jsxs)(r.p,{children:["When we request ",(0,i.jsx)(r.code,{children:"Service3"})," from the parent injector, it cannot create an instance of ",(0,i.jsx)(r.code,{children:"Service3"})," because it has no connection to the child injector where ",(0,i.jsx)(r.code,{children:"Service3"})," is present."]}),"\n",(0,i.jsxs)(r.p,{children:["And neither injector can return an instance of ",(0,i.jsx)(r.code,{children:"Service4"}),", because this class was not passed to any of them during their creation."]}),"\n",(0,i.jsx)(r.h3,{id:"hierarchy-of-injectors-in-the-ditsmod-application",children:"Hierarchy of injectors in the Ditsmod application"}),"\n",(0,i.jsx)(r.p,{children:"Previously in the documentation you might have encountered the following properties of the object that is passed via module metadata:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"providersPerApp"})," - providers at the application level;"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"providersPerMod"})," - providers at the module level;"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"providersPerRou"})," - providers at the route level;"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"providersPerReq"})," - providers at the HTTP-request level."]}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"Using these arrays, Ditsmod forms different injectors that are related by a hierarchical connection. Such a hierarchy can be simulated as follows:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",children:"import { Injector } from '@ditsmod/core';\n\nconst providersPerApp = [];\nconst providersPerMod = [];\nconst providersPerRou = [];\nconst providersPerReq = [];\n\nconst injectorPerApp = Injector.resolveAndCreate(providersPerApp);\nconst injectorPerMod = injectorPerApp.resolveAndCreateChild(providersPerMod);\nconst injectorPerRou = injectorPerMod.resolveAndCreateChild(providersPerRou);\nconst injectorPerReq = injectorPerRou.resolveAndCreateChild(providersPerReq);\n"})}),"\n",(0,i.jsx)(r.p,{children:"Under the hood, Ditsmod performs a similar procedure many times for different modules, routes, and requests. For example, if a Ditsmod application has two modules and ten routes, there will be one injector at the application level, one injector for each module (2 total), one injector for each route (10 total), and one injector for each request. Injectors at the request level are removed automatically after each request is processed."}),"\n",(0,i.jsxs)(r.p,{children:["Recall that higher-level injectors in the hierarchy have no access to lower-level injectors. This means that ",(0,i.jsx)(r.strong,{children:"when passing a class to a given injector, you must take into account the minimum hierarchy level of its dependencies"}),"."]}),"\n",(0,i.jsxs)(r.p,{children:["For example, if you write a class that depends on the HTTP request, you will be able to pass it only to the ",(0,i.jsx)(r.code,{children:"providersPerReq"})," array, because only from this array Ditsmod forms the injector to which Ditsmod will automatically add a provider with the HTTP-request object. On the other hand, an instance of this class will have access to all its parent injectors: at the route level, module level, and application level. Therefore this class can depend on providers at any level."]}),"\n",(0,i.jsxs)(r.p,{children:["You can also write a class and pass it into the ",(0,i.jsx)(r.code,{children:"providersPerMod"})," array; in that case it can depend only on providers at the module level or at the application level. If it depends on providers that you passed into ",(0,i.jsx)(r.code,{children:"providersPerRou"})," or ",(0,i.jsx)(r.code,{children:"providersPerReq"}),", you will get an error that these providers are not found."]}),"\n",(0,i.jsx)(r.h3,{id:"controller-injector-hierarchy",children:"Controller injector hierarchy"}),"\n",(0,i.jsxs)(r.p,{children:["A controller ",(0,i.jsx)(r.a,{href:"/components-of-ditsmod-app/controllers-and-services/#what-is-a-controller",children:"in injector-scoped mode"}),", besides its own injector at the request level, also has three parent injectors: at the route level, module level and application level. These injectors are also formed based on the providers that you pass into the following arrays:"]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"providersPerApp"}),";"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"providersPerMod"}),";"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"providersPerRou"}),";"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"providersPerReq"})," (this array forms the injector for a controller in injector-scoped mode)."]}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"Thus a controller in injector-scoped mode can depend on services at any level."}),"\n",(0,i.jsxs)(r.p,{children:["If a controller is ",(0,i.jsx)(r.a,{href:"/components-of-ditsmod-app/controllers-and-services/#what-is-a-controller",children:"in context-scoped mode"}),", its own injector is located at the module level, and it has one parent injector at the application level:"]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"providersPerApp"}),";"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"providersPerMod"})," (this array forms the injector for a controller in context-scoped mode)."]}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"service-injector-hierarchy",children:"Service injector hierarchy"}),"\n",(0,i.jsxs)(r.p,{children:["Unlike a controller, the injector of a given service can be at any level: at the application level, module level, route level, or request level. In practice this means that the provider for this service is passed into one (or several) of the above arrays. For example, in the following example ",(0,i.jsx)(r.code,{children:"SomeService"})," is passed into the injector at the route level, and ",(0,i.jsx)(r.code,{children:"OtherService"})," \u2014 into the module level:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",metastring:"{5-6}",children:"import { Injector } from '@ditsmod/core';\n// ...\n\nconst providersPerApp = [];\nconst providersPerMod = [OtherService];\nconst providersPerRou = [SomeService];\nconst providersPerReq = [];\n\nconst injectorPerApp = Injector.resolveAndCreate(providersPerApp);\nconst injectorPerMod = injectorPerApp.resolveAndCreateChild(providersPerMod);\nconst injectorPerRou = injectorPerMod.resolveAndCreateChild(providersPerRou);\nconst injectorPerReq = injectorPerRou.resolveAndCreateChild(providersPerReq);\n"})}),"\n",(0,i.jsxs)(r.p,{children:["In this case, if ",(0,i.jsx)(r.code,{children:"SomeService"})," has a dependency on ",(0,i.jsx)(r.code,{children:"OtherService"}),", DI will be able to create an instance of ",(0,i.jsx)(r.code,{children:"SomeService"}),", because the injector at the route level can obtain an instance of ",(0,i.jsx)(r.code,{children:"OtherService"})," from its parent injector at the module level. However, if ",(0,i.jsx)(r.code,{children:"OtherService"})," depends on ",(0,i.jsx)(r.code,{children:"SomeService"}),", DI will not be able to create an instance of ",(0,i.jsx)(r.code,{children:"OtherService"}),", because the injector at the module level does not see its child injector at the route level."]}),"\n",(0,i.jsxs)(r.p,{children:["The following example shows four different ways to request an instance of ",(0,i.jsx)(r.code,{children:"SomeService"})," using ",(0,i.jsx)(r.code,{children:"injectorPer*.get()"})," directly or via class method parameters:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",children:"injectorPerRou.get(SomeService); // Injector per route.\n// OR\ninjectorPerReq.get(SomeService); // Injector per request.\n// OR\n@injectable()\nclass Service1 {\n  constructor(private someService: SomeService) {} // Constructor's parameters.\n}\n// OR\n@controller()\nclass controller1 {\n  @route('GET', 'some-path')\n  method1(someService: SomeService) {} // Method's parameters.\n}\n"})}),"\n",(0,i.jsxs)(r.p,{children:["Here it is important to remember the following rule: the value for ",(0,i.jsx)(r.code,{children:"SomeService"})," is created in the injector where the provider was passed, and this value is created only once on the first request. In our example, the ",(0,i.jsx)(r.code,{children:"SomeService"})," class is actually passed to ",(0,i.jsx)(r.code,{children:"injectorPerRou"}),", so the instance of the class ",(0,i.jsx)(r.code,{children:"SomeService"})," will be created in ",(0,i.jsx)(r.code,{children:"injectorPerRou"}),", even if this instance is requested in the child ",(0,i.jsx)(r.code,{children:"injectorPerReq"}),"."]}),"\n",(0,i.jsx)(r.p,{children:"This rule is very important because it clearly shows:"}),"\n",(0,i.jsxs)(r.ol,{children:["\n",(0,i.jsx)(r.li,{children:"in which injector the value for a given provider is created;"}),"\n",(0,i.jsx)(r.li,{children:"that if you take a single injector, the value for a given provider (for a given token) is created only once in it;"}),"\n",(0,i.jsxs)(r.li,{children:["that if the child injector lacks a provider, it can ask the parent injector for the ",(0,i.jsx)(r.em,{children:"value"})," of that provider (i.e., the child injector asks the parent injector for the ",(0,i.jsx)(r.em,{children:"value"}),", not for the provider itself)."]}),"\n"]}),"\n",(0,i.jsxs)(r.p,{children:["This rule applies to the ",(0,i.jsx)(r.code,{children:"injector.get()"})," method, but not to ",(0,i.jsx)(r.code,{children:"injector.pull()"})," or ",(0,i.jsx)(r.code,{children:"injector.resolveAndInstantiate()"}),"."]}),"\n",(0,i.jsxs)(r.h3,{id:"method-injector-pull",children:["Method ",(0,i.jsx)(r.code,{children:"injector.pull()"})]}),"\n",(0,i.jsx)(r.p,{children:"This method makes sense to use only in a child injector when it lacks a certain provider that exists in the parent injector, and that provider depends on another provider that exists in the child injector."}),"\n",(0,i.jsxs)(r.p,{children:["For example, when ",(0,i.jsx)(r.code,{children:"Service"})," depends on ",(0,i.jsx)(r.code,{children:"Config"}),", and ",(0,i.jsx)(r.code,{children:"Service"})," exists only in the parent injector, while ",(0,i.jsx)(r.code,{children:"Config"})," exists both in the parent and in the child injector:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",metastring:"{16}",children:"import { injectable, Injector } from '@ditsmod/core';\n\nclass Config {\n  one: any;\n  two: any;\n}\n\n@injectable()\nclass Service {\n  constructor(public config: Config) {}\n}\n\nconst parent = Injector.resolveAndCreate([Service, { token: Config, useValue: { one: 1, two: 2 } }]);\nconst child = parent.resolveAndCreateChild([{ token: Config, useValue: { one: 11, two: 22 } }]);\nchild.get(Service).config; // returns from parent injector: { one: 1, two: 2 }\nchild.pull(Service).config; // pulls Service in current injector: { one: 11, two: 22 }\n"})}),"\n",(0,i.jsxs)(r.p,{children:["As you can see, if you use ",(0,i.jsx)(r.code,{children:"child.get(Service)"})," in this case, ",(0,i.jsx)(r.code,{children:"Service"})," will be created with the ",(0,i.jsx)(r.code,{children:"Config"})," from the parent injector. If you use ",(0,i.jsx)(r.code,{children:"child.pull(Service)"}),", it will first pull the required provider into the child injector and then create it in the context of the child injector without adding its value to the injector cache (i.e., ",(0,i.jsx)(r.code,{children:"child.pull(Service)"})," will return a new instance each time)."]}),"\n",(0,i.jsxs)(r.p,{children:["But if the requested provider exists in the child injector, then ",(0,i.jsx)(r.code,{children:"child.pull(Service)"})," will work identically to ",(0,i.jsx)(r.code,{children:"child.get(Service)"})," (with the addition that the provider's value is added to the injector's cache):"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",metastring:"{14-15}",children:"import { injectable, Injector } from '@ditsmod/core';\n\nclass Config {\n  one: any;\n  two: any;\n}\n\n@injectable()\nclass Service {\n  constructor(public config: Config) {}\n}\n\nconst parent = Injector.resolveAndCreate([]);\nconst child = parent.resolveAndCreateChild([Service, { token: Config, useValue: { one: 11, two: 22 } }]);\nchild.get(Service).config; // { one: 11, two: 22 }\n"})}),"\n",(0,i.jsx)(r.h3,{id:"current-injector",children:"Current injector"}),"\n",(0,i.jsx)(r.p,{children:"You will rarely need the injector of a service or controller itself, but you can obtain it in a constructor just like any other provider value:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",metastring:"{6}",children:"import { injectable, Injector } from '@ditsmod/core';\nimport { FirstService } from './first.service.js';\n\n@injectable()\nexport class SecondService {\n  constructor(private injector: Injector) {}\n\n  someMethod() {\n    const firstService = this.injector.get(FirstService);  // Lazy loading of dependency\n  }\n}\n"})}),"\n",(0,i.jsxs)(r.p,{children:["Keep in mind that in this way you get the injector that created the instance of this service. The hierarchy level of that injector depends only on the registry in which ",(0,i.jsx)(r.code,{children:"SecondService"})," was passed."]}),"\n",(0,i.jsx)(r.h2,{id:"multi-providers",children:"Multi-providers"}),"\n",(0,i.jsxs)(r.p,{children:["This kind of providers exist only in the object form and differ from regular DI providers by having the ",(0,i.jsx)(r.code,{children:"multi: true"})," property. Such providers are appropriate when you need to pass several providers with the same token to DI at once so that DI returns the same number of values for these providers in a single array:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",children:"import { Injector } from '@ditsmod/core';\nimport { LOCAL } from './tokens.js';\n\nconst injector = Injector.resolveAndCreate([\n  { token: LOCAL, useValue: 'uk', multi: true },\n  { token: LOCAL, useValue: 'en', multi: true },\n]);\n\nconst locals = injector.get(LOCAL); // ['uk', 'en']\n"})}),"\n",(0,i.jsxs)(r.p,{children:["Essentially, multi-providers allow creating groups of providers that share the same token. This capability is used, for example, to create groups of ",(0,i.jsx)(r.code,{children:"HTTP_INTERCEPTORS"}),", and also for creating various ",(0,i.jsx)(r.a,{href:"/components-of-ditsmod-app/extensions/#group-of-extensions",children:"extension groups"}),"."]}),"\n",(0,i.jsx)(r.p,{children:"It is not allowed for the same token to be both a regular provider and a multi-provider in the same injector:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",metastring:"{5-6}",children:"import { Injector } from '@ditsmod/core';\nimport { LOCAL } from './tokens.js';\n\nconst injector = Injector.resolveAndCreate([\n  { token: LOCAL, useValue: 'uk' },\n  { token: LOCAL, useValue: 'en', multi: true },\n]);\n\nconst locals = injector.get(LOCAL); // Error: Cannot mix multi providers and regular providers\n"})}),"\n",(0,i.jsx)(r.p,{children:"Child injectors can return values of multi-providers from the parent injector only if, during their creation, they were not passed providers with the same tokens:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",children:"import { Injector } from '@ditsmod/core';\nimport { LOCAL } from './tokens.js';\n\nconst parent = Injector.resolveAndCreate([\n  { token: LOCAL, useValue: 'uk', multi: true },\n  { token: LOCAL, useValue: 'en', multi: true },\n]);\n\nconst child = parent.resolveAndCreateChild([]);\n\nconst locals = child.get(LOCAL); // ['uk', 'en']\n"})}),"\n",(0,i.jsx)(r.p,{children:"If both the child and the parent injector have multi-providers with the same token, the child injector will return only the values from its own array:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",children:"import { Injector } from '@ditsmod/core';\nimport { LOCAL } from './tokens.js';\n\nconst parent = Injector.resolveAndCreate([\n  { token: LOCAL, useValue: 'uk', multi: true },\n  { token: LOCAL, useValue: 'en', multi: true },\n]);\n\nconst child = parent.resolveAndCreateChild([\n  { token: LOCAL, useValue: '\u0430\u0430', multi: true }\n]);\n\nconst locals = child.get(LOCAL); // ['\u0430\u0430']\n"})}),"\n",(0,i.jsx)(r.h3,{id:"multi-provider-substitution",children:"Multi-provider substitution"}),"\n",(0,i.jsx)(r.p,{children:"To make it possible to substitute a specific multi-provider, you can do the following:"}),"\n",(0,i.jsxs)(r.ol,{children:["\n",(0,i.jsxs)(r.li,{children:["pass a class to the multi-provider object using the ",(0,i.jsx)(r.code,{children:"useToken"})," property;"]}),"\n",(0,i.jsx)(r.li,{children:"then pass that class as a regular provider;"}),"\n",(0,i.jsx)(r.li,{children:"next in the providers array add a provider that substitutes that class."}),"\n"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",children:"import { Injector, HTTP_INTERCEPTORS } from '@ditsmod/core';\n\nimport { DefaultInterceptor } from './default.interceptor.js';\nimport { MyInterceptor } from './my.interceptor.js';\n\nconst injector = Injector.resolveAndCreate([\n  { token: HTTP_INTERCEPTORS, useToken: DefaultInterceptor, multi: true },\n  DefaultInterceptor,\n  { token: DefaultInterceptor, useClass: MyInterceptor }\n]);\n\nconst locals = injector.get(HTTP_INTERCEPTORS); // [MyInterceptor]\n"})}),"\n",(0,i.jsx)(r.p,{children:"This construction makes sense, for example, if the first two points are executed in an external module that you cannot edit, and the third point is executed by the user of the current module."}),"\n",(0,i.jsxs)(r.p,{children:["The ",(0,i.jsx)(r.code,{children:"useClass"})," instruction differs from the ",(0,i.jsx)(r.code,{children:"useValue"})," instruction in that for ",(0,i.jsx)(r.code,{children:"useClass"})," the injector will try to create an instance of the class, while for ",(0,i.jsx)(r.code,{children:"useValue"})," it will return the unchanged value."]}),"\n",(0,i.jsx)(r.h2,{id:"transfer-of-providers-to-the-di-registry",children:"Transfer of providers to the DI registry"}),"\n",(0,i.jsxs)(r.p,{children:["For a single dependency, one or more providers must be passed to the DI registry. Usually providers are passed to the DI registry via module metadata, although sometimes they are passed via controller metadata or even directly to ",(0,i.jsx)(r.a,{href:"#injector-and-providers",children:"injectors"}),". In the following example ",(0,i.jsx)(r.code,{children:"SomeService"})," is passed into the ",(0,i.jsx)(r.code,{children:"providersPerMod"})," array:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",metastring:"{9}",children:"import { featureModule } from '@ditsmod/core';\n\nimport { SomeService } from './some.service.js';\nimport { SomeController } from './some.controller.js';\n\n@featureModule({\n  controllers: [SomeController],\n  providersPerMod: [\n    SomeService\n  ],\n})\nexport class SomeModule {}\n"})}),"\n",(0,i.jsxs)(r.p,{children:["After such a transfer, consumers of providers can use ",(0,i.jsx)(r.code,{children:"SomeService"})," within ",(0,i.jsx)(r.code,{children:"SomeModule"}),". The result will be identical if we pass the same provider in the object format:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",metastring:"{9}",children:"import { featureModule } from '@ditsmod/core';\n\nimport { SomeService } from './some.service.js';\nimport { SomeController } from './some.controller.js';\n\n@featureModule({\n  controllers: [SomeController],\n  providersPerMod: [\n    { token: SomeService, useClass: SomeService }\n  ],\n})\nexport class SomeModule {}\n"})}),"\n",(0,i.jsx)(r.p,{children:"And now let's additionally pass another provider with the same token, but this time in the controller metadata:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",metastring:"{8}",children:"import { controller } from '@ditsmod/core';\n\nimport { SomeService } from './some.service.js';\nimport { OtherService } from './other.service.js';\n\n@controller({\n  providersPerReq: [\n    { token: SomeService, useClass: OtherService }\n  ]\n})\nexport class SomeController {\n  constructor(private someService: SomeService) {}\n  // ...\n}\n"})}),"\n",(0,i.jsxs)(r.p,{children:['Pay attention to the highlighted line. Thus we tell DI: "If this controller has a dependency on the provider with the token ',(0,i.jsx)(r.code,{children:"SomeService"}),", it should be substituted with an instance of the class ",(0,i.jsx)(r.code,{children:"OtherService"}),'". This substitution will apply only to this controller. All other controllers in ',(0,i.jsx)(r.code,{children:"SomeModule"})," will receive instances of ",(0,i.jsx)(r.code,{children:"SomeService"})," for the ",(0,i.jsx)(r.code,{children:"SomeService"})," token."]}),"\n",(0,i.jsx)(r.p,{children:"You can perform a similar substitution at the application or module level. This can sometimes be useful, for example when you want to have default configuration values at the application level but custom values for that configuration at a specific module level. In that case, first pass the default configuration in the root module:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",metastring:"{6}",children:"import { rootModule } from '@ditsmod/core';\nimport { ConfigService } from './config.service.js';\n\n@rootModule({\n  providersPerApp: [\n    ConfigService\n  ],\n})\nexport class AppModule {}\n"})}),"\n",(0,i.jsxs)(r.p,{children:["And then in some module substitute ",(0,i.jsx)(r.code,{children:"ConfigService"})," with an arbitrary value:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",metastring:"{6}",children:"import { featureModule } from '@ditsmod/core';\nimport { ConfigService } from './config.service.js';\n\n@featureModule({\n  providersPerMod: [\n    { token: ConfigService, useValue: { propery1: 'some value' } }\n  ],\n})\nexport class SomeModule {}\n"})}),"\n",(0,i.jsx)(r.h2,{id:"re-adding-providers",children:"Re-adding providers"}),"\n",(0,i.jsx)(r.p,{children:"Different providers with the same token can be added many times in module or controller metadata, but DI will choose the provider that was added last (exceptions to this rule apply only for multi-providers):"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",children:"import { featureModule } from '@ditsmod/core';\n\n@featureModule({\n  providersPerMod: [\n    { token: 'token1', useValue: 'value1' },\n    { token: 'token1', useValue: 'value2' },\n    { token: 'token1', useValue: 'value3' },\n  ],\n})\nexport class SomeModule {}\n"})}),"\n",(0,i.jsxs)(r.p,{children:["In this case, within ",(0,i.jsx)(r.code,{children:"SomeModule"})," the ",(0,i.jsx)(r.code,{children:"token1"})," will return ",(0,i.jsx)(r.code,{children:"value3"})," at the module, route or request level."]}),"\n",(0,i.jsx)(r.p,{children:"Additionally, different providers with the same token can be provided at multiple different hierarchy levels simultaneously, but DI will always choose the nearest injector (i.e., if a provider value is requested at the request level, the injector at the request level will be inspected first, and only if the required provider is not found there will DI ascend to parent injectors):"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",children:"import { featureModule } from '@ditsmod/core';\n\n@featureModule({\n  providersPerMod: [{ token: 'token1', useValue: 'value1' }],\n  providersPerRou: [{ token: 'token1', useValue: 'value2' }],\n  providersPerReq: [{ token: 'token1', useValue: 'value3' }],\n})\nexport class SomeModule {}\n"})}),"\n",(0,i.jsxs)(r.p,{children:["In this case, within ",(0,i.jsx)(r.code,{children:"SomeModule"})," for ",(0,i.jsx)(r.code,{children:"token1"})," the value ",(0,i.jsx)(r.code,{children:"value3"})," will be returned at the request level, ",(0,i.jsx)(r.code,{children:"value2"})," at the route level, and ",(0,i.jsx)(r.code,{children:"value1"})," at the module level."]}),"\n",(0,i.jsx)(r.p,{children:"Also, if you import a provider from an external module and you have a provider with the same token in your current module, the local provider will have higher priority provided they were passed at the same hierarchy level."}),"\n",(0,i.jsx)(r.h2,{id:"editing-values-in-the-di-register",children:"Editing values in the DI register"}),"\n",(0,i.jsxs)(r.p,{children:["As mentioned earlier, ",(0,i.jsx)(r.em,{children:"providers"})," are passed to the DI registry, from which ",(0,i.jsx)(r.em,{children:"values"})," are then formed, so that ultimately there is a mapping between token and its value:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{children:"token1 -> value15\ntoken2 -> value100\n...\n"})}),"\n",(0,i.jsxs)(r.p,{children:["In addition, it is possible to edit ready ",(0,i.jsx)(r.em,{children:"values"})," in the DI registry:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",metastring:"{4}",children:"import { Injector } from '@ditsmod/core';\n\nconst injector = Injector.resolveAndCreate([{ token: 'token1', useValue: undefined }]);\ninjector.setByToken('token1', 'value1');\ninjector.get('token1'); // value1\n"})}),"\n",(0,i.jsxs)(r.p,{children:["Note that in this case a provider with ",(0,i.jsx)(r.code,{children:"token1"})," and the value ",(0,i.jsx)(r.code,{children:"undefined"})," is first passed to the registry, and only then do we change the value for this token. If you try to edit the value for a token that is not present in the registry, DI will throw an error similar to:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-text",children:'DiError: Setting value by token failed: cannot find token in register: "token1". Try adding a provider with the same token to the current injector via module or controller metadata.\n'})}),"\n",(0,i.jsxs)(r.p,{children:["In most cases, editing values is used by ",(0,i.jsx)(r.a,{href:"/components-of-ditsmod-app/http-interceptors/",children:"interceptors"})," or ",(0,i.jsx)(r.a,{href:"/components-of-ditsmod-app/guards/",children:"guards"}),", as they thus pass the result of their work into the registry:"]}),"\n",(0,i.jsxs)(r.ol,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.a,{href:"https://github.com/ditsmod/ditsmod/blob/core-2.54.0/packages/body-parser/src/body-parser.interceptor.ts#L15",children:"BodyParserInterceptor"}),";"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.a,{href:"https://github.com/ditsmod/ditsmod/blob/core-2.54.0/examples/14-auth-jwt/src/app/modules/services/auth/bearer.guard.ts#L24",children:"BearerGuard"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(r.p,{children:["As an alternative to the ",(0,i.jsx)(r.code,{children:"injector.setByToken()"})," method, you can use the equivalent expression:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",metastring:"{5}",children:"import { KeyRegistry } from '@ditsmod/core';\n\n// ...\nconst { id } = KeyRegistry.get('token1');\ninjector.setById(id, 'value1');\n// ...\n"})}),"\n",(0,i.jsxs)(r.p,{children:["The advantage of using the ",(0,i.jsx)(r.code,{children:"injector.setById()"})," method is that it is faster than ",(0,i.jsx)(r.code,{children:"injector.setByToken()"}),", but only if you get the ID from the ",(0,i.jsx)(r.code,{children:"KeyRegistry"})," once and then call ",(0,i.jsx)(r.code,{children:"injector.setById()"})," many times."]}),"\n",(0,i.jsxs)(r.h2,{id:"optional-fromSelf-skipSelf-decorators",children:["Decorators ",(0,i.jsx)(r.code,{children:"optional"}),", ",(0,i.jsx)(r.code,{children:"fromSelf"})," and ",(0,i.jsx)(r.code,{children:"skipSelf"})]}),"\n",(0,i.jsx)(r.p,{children:"These decorators are used to control the behavior of the injector when searching for values for a given token."}),"\n",(0,i.jsx)(r.h3,{id:"optional",children:"optional"}),"\n",(0,i.jsxs)(r.p,{children:["Sometimes you may need to mark a dependency in the constructor as optional. Let's look at the following example where a question mark is placed after the ",(0,i.jsx)(r.code,{children:"firstService"})," property, indicating to TypeScript that this property is optional:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",metastring:"{6}",children:"import { injectable } from '@ditsmod/core';\nimport { FirstService } from './first.service.js';\n\n@injectable()\nexport class SecondService {\n  constructor(private firstService?: FirstService) {}\n  // ...\n}\n"})}),"\n",(0,i.jsxs)(r.p,{children:["But DI will ignore this optionality and will throw an error if it cannot create ",(0,i.jsx)(r.code,{children:"FirstService"}),". For this code to work you need to use the ",(0,i.jsx)(r.code,{children:"optional"})," decorator:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",metastring:"{6}",children:"import { injectable, optional } from '@ditsmod/core';\nimport { FirstService } from './first.service.js';\n\n@injectable()\nexport class SecondService {\n  constructor(@optional() private firstService?: FirstService) {}\n  // ...\n}\n"})}),"\n",(0,i.jsx)(r.h3,{id:"fromself",children:"fromSelf"}),"\n",(0,i.jsxs)(r.p,{children:["The ",(0,i.jsx)(r.code,{children:"fromSelf"})," and ",(0,i.jsx)(r.code,{children:"skipSelf"})," decorators make sense when there is some hierarchy of injectors. The ",(0,i.jsx)(r.code,{children:"fromSelf"})," decorator is used very rarely."]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",children:"import { injectable, fromSelf, Injector } from '@ditsmod/core';\n\nclass Service1 {}\n\n@injectable()\nclass Service2 {\n  constructor(@fromSelf() public service1: Service1) {}\n}\n\nconst parent = Injector.resolveAndCreate([Service1, Service2]);\nconst child = parent.resolveAndCreateChild([Service2]);\n\nconst service2 = parent.get(Service2) as Service2;\nservice2.service1 instanceof Service1; // true\n\nchild.get(Service2); // Error - Service1 not found\n"})}),"\n",(0,i.jsxs)(r.p,{children:["As you can see, ",(0,i.jsx)(r.code,{children:"Service2"})," depends on ",(0,i.jsx)(r.code,{children:"Service1"}),", and the ",(0,i.jsx)(r.code,{children:"fromSelf"}),' decorator tells DI: "When creating an instance of ',(0,i.jsx)(r.code,{children:"Service1"}),", use only the same injector that creates the instance of ",(0,i.jsx)(r.code,{children:"Service2"}),', and do not refer to the parent injector". When the parent injector is created, it is given both required services, so when requesting the token ',(0,i.jsx)(r.code,{children:"Service2"})," it will successfully resolve the dependency and return an instance of that class."]}),"\n",(0,i.jsxs)(r.p,{children:["But when creating the child injector, ",(0,i.jsx)(r.code,{children:"Service1"})," was not passed to it, so when requesting the token ",(0,i.jsx)(r.code,{children:"Service2"})," it will not be able to resolve that service's dependency. If you remove the ",(0,i.jsx)(r.code,{children:"fromSelf"})," decorator from the constructor, then the child injector will successfully resolve the dependency for ",(0,i.jsx)(r.code,{children:"Service2"}),"."]}),"\n",(0,i.jsx)(r.h3,{id:"skipself",children:"skipSelf"}),"\n",(0,i.jsxs)(r.p,{children:["The ",(0,i.jsx)(r.code,{children:"skipSelf"})," decorator is used more often than ",(0,i.jsx)(r.code,{children:"fromSelf"}),", but still rarely."]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",children:"import { injectable, skipSelf, Injector } from '@ditsmod/core';\n\nclass Service1 {}\n\n@injectable()\nclass Service2 {\n  constructor(@skipSelf() public service1: Service1) {}\n}\n\nconst parent = Injector.resolveAndCreate([Service1, Service2]);\nconst child = parent.resolveAndCreateChild([Service2]);\n\nparent.get(Service2); // Error - Service1 not found\n\nconst service2 = child.get(Service2) as Service2;\nservice2.service1 instanceof Service1; // true\n"})}),"\n",(0,i.jsxs)(r.p,{children:["As you can see, ",(0,i.jsx)(r.code,{children:"Service2"})," depends on ",(0,i.jsx)(r.code,{children:"Service1"}),", and the ",(0,i.jsx)(r.code,{children:"skipSelf"}),' decorator tells DI: "When creating an instance of ',(0,i.jsx)(r.code,{children:"Service1"}),", skip the injector that will create the instance of ",(0,i.jsx)(r.code,{children:"Service2"}),' and immediately refer to the parent injector". When the parent injector is created, it is given both necessary services, but due to ',(0,i.jsx)(r.code,{children:"skipSelf"})," it cannot use the value for ",(0,i.jsx)(r.code,{children:"Service1"})," from its own registry, therefore it will not be able to resolve the specified dependency."]}),"\n",(0,i.jsxs)(r.p,{children:["When creating the child injector, it was not passed ",(0,i.jsx)(r.code,{children:"Service1"}),", but it can refer to the parent injector for it. Therefore the child injector successfully resolves the dependency for ",(0,i.jsx)(r.code,{children:"Service2"}),"."]}),"\n",(0,i.jsx)(r.h2,{id:"when-di-cant-find-the-right-provider",children:"When DI can't find the right provider"}),"\n",(0,i.jsx)(r.p,{children:"Remember that when DI cannot find the required provider, there are only three possible reasons:"}),"\n",(0,i.jsxs)(r.ol,{children:["\n",(0,i.jsxs)(r.li,{children:["you did not pass the required provider to DI in module or controller metadata (or, in testing, to ",(0,i.jsx)(r.code,{children:"Injector.resolveAndCreate()"}),");"]}),"\n",(0,i.jsx)(r.li,{children:"you did not import the module that provides the required provider, or that provider is not exported;"}),"\n",(0,i.jsx)(r.li,{children:"you are requesting a provider from the parent injector that exists only in a child injector."}),"\n"]})]})}function h(e={}){const{wrapper:r}={...(0,o.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>s,x:()=>c});var t=n(6540);const i={},o=t.createContext(i);function s(e){const r=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function c(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(o.Provider,{value:r},e.children)}}}]);