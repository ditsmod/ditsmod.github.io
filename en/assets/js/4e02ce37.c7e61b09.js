"use strict";(self.webpackChunkditsmod_github_io=self.webpackChunkditsmod_github_io||[]).push([[430],{4449:(e,o,r)=>{r.r(o),r.d(o,{assets:()=>l,contentTitle:()=>d,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"basic-components/modules","title":"Modules","description":"One of the key elements of the Ditsmod architecture is its modules. But what exactly makes a modular architecture so advantageous? \u2014 Modularity allows you to compose various autonomous elements and assemble a scalable application from them. Thanks to the autonomy of modules, large projects are easier to develop, test, deploy, and maintain. Modularity also simplifies the transition to a microservices architecture if, in the future, you decide that your Ditsmod application requires horizontal scaling.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/01-basic-components/02-modules.md","sourceDirName":"01-basic-components","slug":"/basic-components/modules","permalink":"/en/basic-components/modules","draft":false,"unlisted":false,"editUrl":"https://github.com/ditsmod/ditsmod/edit/main/website/i18n/en/docusaurus-plugin-content-docs/current/01-basic-components/02-modules.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Dependency Injection","permalink":"/en/basic-components/dependency-injection"},"next":{"title":"Extensions","permalink":"/en/basic-components/extensions"}}');var n=r(4848),t=r(8453);const i={sidebar_position:2},d="Modules",l={},a=[{value:"Root module",id:"root-module",level:2},{value:"Feature module",id:"feature-module",level:2},{value:"Export, import, append",id:"export-import-append",level:2},{value:"Exporting providers from a feature module",id:"exporting-providers-from-a-featuremodule",level:3},{value:"Exporting providers from root module",id:"exporting-providers-from-rootmodule",level:3},{value:"Import module",id:"import-module",level:3},{value:"ModuleWithParams",id:"ModuleWithParams",level:4},{value:"Import classes or class instances?",id:"import-classes-or-class-instances",level:4},{value:"Import and encapsulation",id:"import-and-encapsulation",level:4},{value:"Appending of the module",id:"appending-of-the-module",level:3},{value:"Re-export of the module",id:"re-export-of-the-module",level:3},{value:"Provider Collisions",id:"provider-collisions",level:2},{value:"Collision resolution",id:"collision-resolution",level:3}];function c(e){const o={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(o.header,{children:(0,n.jsx)(o.h1,{id:"modules",children:"Modules"})}),"\n",(0,n.jsx)(o.p,{children:"One of the key elements of the Ditsmod architecture is its modules. But what exactly makes a modular architecture so advantageous? \u2014 Modularity allows you to compose various autonomous elements and assemble a scalable application from them. Thanks to the autonomy of modules, large projects are easier to develop, test, deploy, and maintain. Modularity also simplifies the transition to a microservices architecture if, in the future, you decide that your Ditsmod application requires horizontal scaling."}),"\n",(0,n.jsxs)(o.p,{children:["A modular architecture makes it possible to isolate ",(0,n.jsx)(o.strong,{children:"several code files"})," within a single module that may have different roles but a ",(0,n.jsx)(o.strong,{children:"shared specialization"}),". A module can be compared to an orchestra, where there are different instruments, but all of them create a shared piece of music. On the other hand, the need to isolate different modules arises because they may have different specializations and, as a result, may interfere with one another. Continuing the analogy with people, if you place police officers and musicians, or brokers and translators, in the same office, they will most likely interfere with each other. That is why ",(0,n.jsx)(o.strong,{children:"narrow specialization"})," is important for a module."]}),"\n",(0,n.jsx)(o.p,{children:"Modules are the largest building blocks of an application, and their metadata can declare components such as:"}),"\n",(0,n.jsxs)(o.ul,{children:["\n",(0,n.jsx)(o.li,{children:"controllers that accept HTTP requests and send HTTP responses;"}),"\n",(0,n.jsx)(o.li,{children:"services where the business logic of the application is described;"}),"\n",(0,n.jsx)(o.li,{children:"interceptors and guards that allow you to automate the processing of HTTP requests according to typical patterns;"}),"\n",(0,n.jsx)(o.li,{children:"decorators and extensions that allow you to add new rules and behaviors to the application;"}),"\n",(0,n.jsx)(o.li,{children:"other classes, interfaces, helpers, data types intended for the operation of the current module."}),"\n"]}),"\n",(0,n.jsx)(o.p,{children:"There are two types of modules:"}),"\n",(0,n.jsxs)(o.ol,{children:["\n",(0,n.jsx)(o.li,{children:"Root module."}),"\n",(0,n.jsx)(o.li,{children:"Feature module. Most often, this type of module is used for publishing on npmjs.com."}),"\n"]}),"\n",(0,n.jsx)(o.h2,{id:"root-module",children:"Root module"}),"\n",(0,n.jsxs)(o.p,{children:["Other modules are attached to the root module; it is the only one for the entire application, and its class is recommended to be named ",(0,n.jsx)(o.code,{children:"AppModule"}),". A TypeScript class becomes a Ditsmod root module by using one of the decorators such as ",(0,n.jsx)(o.code,{children:"rootModule"}),", ",(0,n.jsx)(o.code,{children:"restRootModule"}),", ",(0,n.jsx)(o.code,{children:"trpcRootModule"}),", etc., depending on the architectural style you are using. For example, if you are using REST, the root module is declared as follows:"]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"import { restRootModule } from '@ditsmod/rest';\n\n@restRootModule()\nexport class AppModule {}\n"})}),"\n",(0,n.jsxs)(o.p,{children:["In general, an object with the following properties can be passed to the ",(0,n.jsx)(o.code,{children:"restRootModule"})," decorator:"]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"import { restRootModule } from '@ditsmod/rest';\n\n@restRootModule({\n  imports: [], // Imported modules\n  appends: [], // Appending modules that have controllers\n  providersPerApp: [], // Providers at the application level\n  providersPerMod: [], //         ...at the module level\n  providersPerRou: [], //         ...at the route level\n  providersPerReq: [], //         ...at the HTTP request level\n  exports: [], // Exported modules and providers from the current module\n  extensions: [], // Extensions\n  extensionsMeta: {}, // Data for extensions\n  resolvedCollisionsPerApp: [], // Resolution of imported class collisions at the application level\n  resolvedCollisionsPerMod: [], //                                   ...at the module level\n  resolvedCollisionsPerRou: [], //                                   ...at the route level\n  resolvedCollisionsPerReq: [], //                                   ...at the HTTP request level\n  controllers: [], // List of controllers in the current module\n})\nexport class AppModule {}\n"})}),"\n",(0,n.jsx)(o.h2,{id:"feature-module",children:"Feature module"}),"\n",(0,n.jsxs)(o.p,{children:["A TypeScript class becomes a Ditsmod feature module thanks to one of the following decorators: ",(0,n.jsx)(o.code,{children:"featureModule"}),", ",(0,n.jsx)(o.code,{children:"restModule"}),", ",(0,n.jsx)(o.code,{children:"trpcModule"}),", etc., depending on the architectural style you are using. For example, if you are using REST, the feature module is declared as follows:"]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"import { restModule } from '@ditsmod/rest';\n\n@restModule()\nexport class SomeModule {}\n"})}),"\n",(0,n.jsxs)(o.p,{children:["It is recommended that module files end with ",(0,n.jsx)(o.code,{children:"*.module.ts"})," and that their class names end with ",(0,n.jsx)(o.code,{children:"*Module"}),"."]}),"\n",(0,n.jsxs)(o.p,{children:["It can contain exactly the same metadata as root modules, except for the ",(0,n.jsx)(o.code,{children:"resolvedCollisionsPerApp"})," property. In addition to being declared directly in the application, feature module can also be published on npmjs.com."]}),"\n",(0,n.jsx)(o.h2,{id:"export-import-append",children:"Export, import, append"}),"\n",(0,n.jsxs)(o.p,{children:["The module where you declare certain ",(0,n.jsx)(o.a,{href:"/basic-components/dependency-injection/#injector-and-providers",children:"providers"})," is called the ",(0,n.jsx)(o.strong,{children:"host module"})," for those providers. And when you use those providers in an external module, that external module is called the ",(0,n.jsx)(o.strong,{children:"consumer module"})," of those providers."]}),"\n",(0,n.jsxs)(o.p,{children:["In order for a consumer module to use providers from a host module, the corresponding provider ",(0,n.jsx)(o.a,{href:"/basic-components/dependency-injection/#injector-and-providers",children:"tokens"})," must first be exported from the host module. This is done in the metadata that is passed to the decorator of the feature module or root module. For example, if you are using REST, this is done as follows:"]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",metastring:"{10}",children:"import { restModule } from '@ditsmod/rest';\n\nimport { Service1 } from './service1.js';\nimport { Service2 } from './service2.js';\nimport { Service3 } from './service3.js';\n\n@restModule({\n  providersPerApp: [Service1],\n  providersPerMod: [Service2, { token: Service3, useValue: 'some value' }],\n  exports: [Service3],\n})\nexport class Module1 {}\n"})}),"\n",(0,n.jsxs)(o.p,{children:["In this example, taking into account the exported tokens, Ditsmod will look for exported providers in the ",(0,n.jsx)(o.code,{children:"providersPerMod"})," array. It makes no sense to export the providers that are passed to ",(0,n.jsx)(o.code,{children:"providersPerApp"}),", since this array will be used to form the ",(0,n.jsx)(o.a,{href:"/basic-components/dependency-injection/#injector-and-providers",children:"injector"})," at the application level. That is, the providers from the ",(0,n.jsx)(o.code,{children:"providersPerApp"})," array will be available for any module, at any level, and without exporting."]}),"\n",(0,n.jsxs)(o.p,{children:["Since you only need to export provider tokens from the host module, not the providers themselves, you cannot directly pass providers in the form of an object to the ",(0,n.jsx)(o.code,{children:"exports"})," property."]}),"\n",(0,n.jsxs)(o.p,{children:["Keep in mind that you only need to export providers from the host module that will be directly used in the consumer modules. In the example above, ",(0,n.jsx)(o.code,{children:"Service3"})," can depend on ",(0,n.jsx)(o.code,{children:"Service2"}),", but ",(0,n.jsx)(o.code,{children:"Service2"})," does not need to be exported if it is not directly used in the consumer module. This ensures module encapsulation."]}),"\n",(0,n.jsx)(o.p,{children:"Exporting controllers does not make sense, since exporting only applies to providers."}),"\n",(0,n.jsx)(o.h3,{id:"exporting-providers-from-a-featuremodule",children:"Exporting providers from a feature module"}),"\n",(0,n.jsx)(o.p,{children:"By exporting tokens from a host module, you are declaring that the corresponding providers can be used in consumer modules if they import this host module."}),"\n",(0,n.jsx)(o.h3,{id:"exporting-providers-from-rootmodule",children:"Exporting providers from root module"}),"\n",(0,n.jsx)(o.p,{children:"Exporting providers from the root module means that these providers will automatically be added to every module in the application. For example, if you are using REST, this is done as follows:"}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",metastring:"{9}",children:"import { restRootModule } from '@ditsmod/rest';\n\nimport { Service1 } from './service1.js';\nimport { Module1 } from './module1.js';\n\n@restRootModule({\n  imports: [Module1],\n  providersPerMod: [Service1],\n  exports: [Service1, Module1],\n})\nexport class AppModule {}\n"})}),"\n",(0,n.jsxs)(o.p,{children:["In this case, ",(0,n.jsx)(o.code,{children:"Service1"})," will be added to all application modules at the module level. As you can see, you can also export entire modules. In this case, all providers exported from ",(0,n.jsx)(o.code,{children:"Module1"})," will also be added to each application module."]}),"\n",(0,n.jsx)(o.h3,{id:"import-module",children:"Import module"}),"\n",(0,n.jsxs)(o.p,{children:["You cannot import a single provider into a module, but you can import an entire module with all the providers and ",(0,n.jsx)(o.a,{href:"/basic-components/extensions",children:"extensions"})," exported from it. For example, if you are using REST, this is done as follows:"]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",metastring:"{6}",children:"import { restModule } from '@ditsmod/rest';\nimport { Module1 } from './module1.js';\n\n@restModule({\n  imports: [\n    Module1\n  ]\n})\nexport class Module2 {}\n"})}),"\n",(0,n.jsxs)(o.p,{children:["For example, if ",(0,n.jsx)(o.code,{children:"Service1"})," is exported from the ",(0,n.jsx)(o.code,{children:"Module1"}),", then this service can now be used in the ",(0,n.jsx)(o.code,{children:"Module2"}),". However, if ",(0,n.jsx)(o.code,{children:"Module1"})," has controllers, they will be ignored in this import form. For Ditsmod to take into account controllers from an imported module, the module must be imported with a prefix passed in ",(0,n.jsx)(o.code,{children:"path"}),":"]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",metastring:"{6}",children:"import { restModule } from '@ditsmod/rest';\nimport { Module1 } from './module1.js';\n\n@restModule({\n  imports: [\n    { module: Module1, path: '' }\n  ]\n})\nexport class Module2 {}\n"})}),"\n",(0,n.jsxs)(o.p,{children:["Although ",(0,n.jsx)(o.code,{children:"path"})," is an empty string here, for Ditsmod, the presence of ",(0,n.jsx)(o.code,{children:"path"})," means:"]}),"\n",(0,n.jsxs)(o.ol,{children:["\n",(0,n.jsx)(o.li,{children:"to consider controllers from the imported module as well;"}),"\n",(0,n.jsxs)(o.li,{children:["to use ",(0,n.jsx)(o.code,{children:"path"})," as a prefix for all controllers imported from ",(0,n.jsx)(o.code,{children:"Module1"}),"."]}),"\n"]}),"\n",(0,n.jsx)(o.p,{children:"As you can see, in the previous example, this time neither the provider nor the module is imported, but the object. This object has the following interface:"}),"\n",(0,n.jsx)(o.h4,{id:"ModuleWithParams",children:"ModuleWithParams"}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"interface ModuleWithParams {\n  id?: string;\n  module: ModuleType<M>;\n  /**\n   * Providers per the application.\n   */\n  providersPerApp?: Providers | Provider[] = [];\n  /**\n   * Providers per a module.\n   */\n  providersPerMod?: Providers | Provider[] = [];\n  /**\n   * Providers per a route.\n   */\n  providersPerRou?: Providers | Provider[] = [];\n  /**\n   * Providers per a request.\n   */\n  providersPerReq?: Providers | Provider[] = [];\n  /**\n   * List of modules, `ModuleWithParams` or tokens of providers exported by this\n   * module.\n   */\n  exports?: any[];\n  /**\n   * This property allows you to pass any information to extensions.\n   *\n   * You must follow this rule: data for one extension - one key in `extensionsMeta` object.\n   */\n  extensionsMeta?: E;\n}\n"})}),"\n",(0,n.jsx)(o.p,{children:"To reduce the length of the code when importing an object of this type, it is sometimes advisable to write a static method in the importing module. To see this clearly, let's take the previous example again:"}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",metastring:"{6}",children:"import { restModule } from '@ditsmod/rest';\nimport { Module1 } from './module1.js';\n\n@restModule({\n  imports: [\n    { module: Module1, path: '' }\n  ]\n})\nexport class Module2 {}\n"})}),"\n",(0,n.jsxs)(o.p,{children:["If you declare ",(0,n.jsx)(o.code,{children:"Module1"})," and knew that this module would make sense to be imported many times into different modules with different prefixes, then in this case you could write a static method in this class that returns an object specially designed for import:"]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"// ...\nexport class Module1 {\n  static withPrefix(path: string) {\n    return {\n      module: this,\n      path,\n    };\n  }\n}\n"})}),"\n",(0,n.jsx)(o.p,{children:"Now the object returned by this method can be imported as follows:"}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",metastring:"{4}",children:"// ...\n@restModule({\n  imports: [\n    Module1.withPrefix('some-prefix')\n  ]\n})\nexport class Module2 {}\n"})}),"\n",(0,n.jsx)(o.p,{children:"Static methods make it easier to pass module parameters."}),"\n",(0,n.jsxs)(o.p,{children:["In order for TypeScript to control exactly what the static import method returns, it is recommended to use the ",(0,n.jsx)(o.code,{children:"ModuleWithParams"})," interface:"]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"import { ModuleWithParams } from '@ditsmod/core';\n// ...\nexport class Module1 {\n  static withParams(someParams: SomeParams): ModuleWithParams<Module1> {\n    return {\n      module: this,\n      // ...\n    }\n  }\n}\n"})}),"\n",(0,n.jsx)(o.h4,{id:"import-classes-or-class-instances",children:"Import classes or class instances?"}),"\n",(0,n.jsx)(o.p,{children:"Let's consider a specific situation. In the following example, each provider is a class. Note what arrays these providers are passed to and what exactly is exported."}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"// ...\n@restModule({\n  providersPerMod: [Provider1],\n  exports: [Provider1],\n})\nexport class Module1 {}\n"})}),"\n",(0,n.jsxs)(o.p,{children:["Suppose we import this module into ",(0,n.jsx)(o.code,{children:"Module2"}),", which has no providers of its own:"]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"// ...\n@restModule({\n  imports: [Module1]\n  // ...\n})\nexport class Module2 {}\n"})}),"\n",(0,n.jsxs)(o.p,{children:["As a result of this import, the consumer module (",(0,n.jsx)(o.code,{children:"Module2"}),") will now have ",(0,n.jsx)(o.code,{children:"Provider1"})," at the module level, because it is declared at that level in the host module (",(0,n.jsx)(o.code,{children:"Module1"}),"). When working with ",(0,n.jsx)(o.code,{children:"Provider1"}),", its instances will be created separately in both modules. ",(0,n.jsx)(o.a,{href:"https://en.wikipedia.org/wiki/Singleton_pattern",children:"Singleton"})," can be shared between modules only if its provider is declared at the application level. In our example, the provider is declared at the module level, so ",(0,n.jsx)(o.code,{children:"Module1"})," and ",(0,n.jsx)(o.code,{children:"Module2"})," will not have instances of ",(0,n.jsx)(o.code,{children:"Provider1"})," shared at either level."]}),"\n",(0,n.jsx)(o.p,{children:"So it can be argued that classes are imported, not their instances."}),"\n",(0,n.jsx)(o.h4,{id:"import-and-encapsulation",children:"Import and encapsulation"}),"\n",(0,n.jsxs)(o.p,{children:["Let's consider a situation where only ",(0,n.jsx)(o.code,{children:"Provider3"})," is exported from ",(0,n.jsx)(o.code,{children:"Module1"}),", since only this provider is directly used in external modules:"]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"// ...\n@restModule({\n  providersPerMod: [Provider3, Provider2, Provider1],\n  exports: [Provider3],\n})\nexport class Module1 {}\n"})}),"\n",(0,n.jsxs)(o.p,{children:["Suppose ",(0,n.jsx)(o.code,{children:"Provider3"})," has a dependency on ",(0,n.jsx)(o.code,{children:"Provider1"})," and ",(0,n.jsx)(o.code,{children:"Provider2"}),". What will Ditsmod do when importing this module into other modules? Ditsmod will import all three providers, since ",(0,n.jsx)(o.code,{children:"Provider3"})," depends on the other two providers."]}),"\n",(0,n.jsx)(o.h3,{id:"appending-of-the-module",children:"Appending of the module"}),"\n",(0,n.jsxs)(o.p,{children:["If you don't need to import providers and ",(0,n.jsx)(o.a,{href:"/basic-components/extensions",children:"extensions"})," into the current module, but just append the external module to the path prefix of the current module, you can use the ",(0,n.jsx)(o.code,{children:"appends"})," array:"]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",metastring:"{5}",children:"import { restModule } from '@ditsmod/rest';\nimport { Module1 } from './module1.js';\n\n@restModule({\n  appends: [Module1]\n})\nexport class Module2 {}\n"})}),"\n",(0,n.jsxs)(o.p,{children:["In this case, if ",(0,n.jsx)(o.code,{children:"Module2"})," has a path prefix, it will be used as a prefix for all routes contained in ",(0,n.jsx)(o.code,{children:"Module1"}),". Only those modules with controllers can be appended."]}),"\n",(0,n.jsxs)(o.p,{children:["You can also attach an additional path prefix to ",(0,n.jsx)(o.code,{children:"Module1"}),":"]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",metastring:"{3}",children:"// ...\n@restModule({\n  appends: [{ path: 'some-path', module: Module1 }]\n})\nexport class Module2 {}\n"})}),"\n",(0,n.jsx)(o.p,{children:"In this example, an object was used, in which the module is passed for appending, it has the following interface:"}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"interface AppendsWithParams<T extends AnyObj = AnyObj> {\n  id?: string;\n  path: string;\n  module: ModuleType<T>;\n  guards?: GuardItem[];\n}\n"})}),"\n",(0,n.jsx)(o.h3,{id:"re-export-of-the-module",children:"Re-export of the module"}),"\n",(0,n.jsx)(o.p,{children:"In addition to importing a specific module, the same module can be simultaneously exported:"}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"import { restModule } from '@ditsmod/rest';\nimport { Module1 } from './module1.js';\n\n@restModule({\n  imports: [Module1],\n  exports: [Module1],\n})\nexport class Module2 {}\n"})}),"\n",(0,n.jsxs)(o.p,{children:["What is the meaning of this? - Now if you import ",(0,n.jsx)(o.code,{children:"Module2"})," into some other module, you will actually have ",(0,n.jsx)(o.code,{children:"Module1"})," imported as well."]}),"\n",(0,n.jsxs)(o.p,{children:["Pay attention! If during re-export you import an object with ",(0,n.jsx)(o.code,{children:"ModuleWithParams"})," interface, the same object must also be exported:"]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"import { ModuleWithParams } from '@ditsmod/core';\nimport { restModule, RestModuleParams } from '@ditsmod/rest';\n\nimport { Module1 } from './module1.js';\n\nconst firstModuleWithParams: ModuleWithParams & RestModuleParams = { path: 'some-path', module: Module1 };\n\n@restModule({\n  imports: [firstModuleWithParams],\n  exports: [firstModuleWithParams],\n})\nexport class Module2 {}\n"})}),"\n",(0,n.jsx)(o.h2,{id:"provider-collisions",children:"Provider Collisions"}),"\n",(0,n.jsx)(o.p,{children:"Provider collisions occur when different providers that offer the same service are imported into the current module."}),"\n",(0,n.jsxs)(o.p,{children:["Let's take a closer look at a specific example. Imagine you have ",(0,n.jsx)(o.code,{children:"Module3"}),", where you import ",(0,n.jsx)(o.code,{children:"Module2"})," and ",(0,n.jsx)(o.code,{children:"Module1"}),". You made these imports because you need ",(0,n.jsx)(o.code,{children:"Service2"})," and ",(0,n.jsx)(o.code,{children:"Service1"})," from these modules, respectively. You review the results of these services operations, but for some reason, ",(0,n.jsx)(o.code,{children:"Service1"})," does not behave as expected. You start debugging and discover that ",(0,n.jsx)(o.code,{children:"Service1"})," is exported from both ",(0,n.jsx)(o.code,{children:"Module2"})," and ",(0,n.jsx)(o.code,{children:"Module1"}),". You expected ",(0,n.jsx)(o.code,{children:"Service1"})," to be exported only from ",(0,n.jsx)(o.code,{children:"Module1"}),", but in reality, the version exported by ",(0,n.jsx)(o.code,{children:"Module2"})," is being used:"]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",metastring:"{8,14,19}",children:"import { restModule, restRootModule } from '@ditsmod/rest';\n\nclass Service1 {}\nclass Service2 {}\n\n@restModule({\n  providersPerMod: [Service1],\n  exports: [Service1]\n})\nclass Module1 {}\n\n@restModule({\n  providersPerMod: [{ token: Service1, useValue: 'some value' }, Service2],\n  exports: [Service1, Service2],\n})\nclass Module2 {}\n\n@restRootModule({\n  imports: [Module1, Module2],\n})\nclass Module3 {}\n"})}),"\n",(0,n.jsx)(o.p,{children:"To prevent this, if you import two or more modules that export non-identical providers with the same token, Ditsmod will throw an error similar to this:"}),"\n",(0,n.jsxs)(o.blockquote,{children:["\n",(0,n.jsx)(o.p,{children:"Error: Importing providers to Module3 failed: exports from Module1, Module2 causes collision with Service1. You should add Service1 to resolvedCollisionsPerMod in this module. For example: resolvedCollisionsPerMod: [ [Service1, Module1] ]."}),"\n"]}),"\n",(0,n.jsx)(o.p,{children:"In this specific scenario:"}),"\n",(0,n.jsxs)(o.ol,{children:["\n",(0,n.jsxs)(o.li,{children:[(0,n.jsx)(o.code,{children:"Module1"})," exports a provider with the token ",(0,n.jsx)(o.code,{children:"Service1"}),"."]}),"\n",(0,n.jsxs)(o.li,{children:[(0,n.jsx)(o.code,{children:"Module2"})," overrides and then exports a provider with the token ",(0,n.jsx)(o.code,{children:"Service1"}),"."]}),"\n",(0,n.jsxs)(o.li,{children:["The providers with the token ",(0,n.jsx)(o.code,{children:"Service1"})," in ",(0,n.jsx)(o.code,{children:"Module1"})," and ",(0,n.jsx)(o.code,{children:"Module2"})," are not identical."]}),"\n"]}),"\n",(0,n.jsxs)(o.p,{children:["And because both of these modules are imported into ",(0,n.jsx)(o.code,{children:"Module3"}),', a "provider collision" occurs, leaving the developer uncertain about which provider will be used in ',(0,n.jsx)(o.code,{children:"Module3"}),"."]}),"\n",(0,n.jsx)(o.h3,{id:"collision-resolution",children:"Collision resolution"}),"\n",(0,n.jsxs)(o.p,{children:["If ",(0,n.jsx)(o.code,{children:"Module3"})," is declared in your application (it is not imported from ",(0,n.jsx)(o.code,{children:"node_modules"}),"), the collision is resolved by adding to ",(0,n.jsx)(o.code,{children:"resolvedCollisionsPer*"})," an array of two elements, with the provider's token in the first place and the module from which the provider needs to be taken in the second place:"]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",metastring:"{20}",children:"import { restModule, restRootModule } from '@ditsmod/rest';\n\nclass Service1 {}\nclass Service2 {}\n\n@restModule({\n  providersPerMod: [Service1],\n  exports: [Service1]\n})\nclass Module1 {}\n\n@restModule({\n  providersPerMod: [{ token: Service1, useValue: 'some value' }, Service2],\n  exports: [Service1, Service2],\n})\nclass Module2 {}\n\n@restRootModule({\n  imports: [Module1, Module2],\n  resolvedCollisionsPerMod: [ [Service1, Module1] ]\n})\nclass Module3 {}\n"})}),"\n",(0,n.jsxs)(o.p,{children:["If you have installed ",(0,n.jsx)(o.code,{children:"Module3"})," using packages manager (npm, yarn, etc.), there is no point in modifying this module locally to resolve the collision. This situation can only occur if ",(0,n.jsx)(o.code,{children:"Module2"})," and ",(0,n.jsx)(o.code,{children:"Module1"})," are exported from the root module, so you need to remove one of these modules from there. And, of course, after that you will have to explicitly import the deleted module into those modules where it is needed."]})]})}function h(e={}){const{wrapper:o}={...(0,t.R)(),...e.components};return o?(0,n.jsx)(o,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},8453:(e,o,r)=>{r.d(o,{R:()=>i,x:()=>d});var s=r(6540);const n={},t=s.createContext(n);function i(e){const o=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function d(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),s.createElement(t.Provider,{value:o},e.children)}}}]);