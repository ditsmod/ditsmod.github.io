"use strict";(self.webpackChunkditsmod_github_io=self.webpackChunkditsmod_github_io||[]).push([[715],{4981:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>d,contentTitle:()=>c,default:()=>p,frontMatter:()=>i,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"native-modules/trpc","title":"@ditsmod/trpc","description":"The @ditsmod/trpc module provides integration with @trpc/server. A ready-made example of an application with @ditsmod/trpc can be found in the Ditsmod repository. There you can find examples of using guards and interceptors.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/02-native-modules/01-trpc.md","sourceDirName":"02-native-modules","slug":"/native-modules/trpc","permalink":"/en/native-modules/trpc","draft":false,"unlisted":false,"editUrl":"https://github.com/ditsmod/ditsmod/edit/main/website/i18n/en/docusaurus-plugin-content-docs/current/02-native-modules/01-trpc.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"@ditsmod/rest","permalink":"/en/native-modules/rest"},"next":{"title":"@ditsmod/authjs","permalink":"/en/native-modules/authjs"}}');var n=o(4848),s=o(8453);const i={sidebar_position:1},c="@ditsmod/trpc",d={},l=[{value:"Quick start",id:"quick-start",level:2},{value:"How client types are formed at the module level",id:"how-client-types-are-formed-at-the-module-level",level:2},{value:"How client types are formed at the controller method level",id:"how-client-types-are-formed-at-the-controller-method-level",level:2},{value:"How to use router types on the client",id:"how-to-use-router-types-on-the-client",level:2},{value:"Using DI for Providers at the HTTP Request Level",id:"using-di-for-providers-at-the-http-request-level",level:2},{value:"Step One",id:"step-one",level:3},{value:"Step Two",id:"step-two",level:3},{value:"Step Three",id:"step-three",level:3}];function a(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"ditsmodtrpc",children:"@ditsmod/trpc"})}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"@ditsmod/trpc"})," module provides integration with ",(0,n.jsx)(t.a,{href:"https://trpc.io/docs/quickstart",children:"@trpc/server"}),". A ready-made example of an application with ",(0,n.jsx)(t.code,{children:"@ditsmod/trpc"})," can be ",(0,n.jsx)(t.a,{href:"https://github.com/ditsmod/ditsmod/tree/main/examples/18-trpc-server",children:"found in the Ditsmod repository"}),". There you can find examples of using guards and interceptors."]}),"\n",(0,n.jsx)(t.h2,{id:"quick-start",children:"Quick start"}),"\n",(0,n.jsx)(t.p,{children:"You can also use the monorepository, which contains minimal code for a quick start:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-bash",children:"git clone --depth 1 https://github.com/ditsmod/trpc-monorepo-starter.git\n"})}),"\n",(0,n.jsx)(t.h2,{id:"how-client-types-are-formed-at-the-module-level",children:"How client types are formed at the module level"}),"\n",(0,n.jsxs)(t.p,{children:["Ditsmod strives to be transparent for ",(0,n.jsx)(t.code,{children:"@trpc/client"}),", allowing TypeScript to infer types from static code without the need for additional compilation for the client. Each module that provides configuration for the tRPC router must do so in the ",(0,n.jsx)(t.code,{children:"getRouterConfig()"})," method:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",metastring:"{9,18-23}",children:"import { featureModule } from '@ditsmod/core';\nimport { initTrpcModule, ModuleWithTrpcRoutes } from '@ditsmod/trpc';\nimport { RouterOf } from '@ditsmod/trpc/client';\n\nimport { CommentModule } from './comments/comment.module.js';\nimport { PostController } from './post.controller.js';\n\n// For TRPCClient\nexport type PostRouter = RouterOf<typeof PostModule>;\n\n@initTrpcModule({\n  imports: [CommentModule],\n  controllers: [PostController],\n})\n@featureModule()\nexport class PostModule implements ModuleWithTrpcRoutes {\n  getRouterConfig() {\n    return {\n      post: {\n        createPost: PostController.prototype.createPost, // Pointed to a controller\n        comments: CommentModule.prototype.getRouterConfig, // Pointed to a module\n      },\n    };\n  }\n}\n"})}),"\n",(0,n.jsxs)(t.p,{children:["Here, ",(0,n.jsx)(t.code,{children:"ModuleWithTrpcRoutes"})," is an interface that guarantees the presence of the ",(0,n.jsx)(t.code,{children:"getRouterConfig()"})," method in the module."]}),"\n",(0,n.jsx)(t.p,{children:"In this example, the config is shown, based on which the following will be created:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["the route ",(0,n.jsx)(t.code,{children:"post.createPost"}),", which will be handled by the controller method - ",(0,n.jsx)(t.code,{children:"PostController.prototype.createPost"}),";"]}),"\n",(0,n.jsxs)(t.li,{children:["the route group ",(0,n.jsx)(t.code,{children:"post.comments"}),", which will be handled by the imported module - ",(0,n.jsx)(t.code,{children:"CommentModule.prototype.getRouterConfig"}),". One can assume that ",(0,n.jsx)(t.code,{children:"CommentModule"})," has its own ",(0,n.jsx)(t.code,{children:"getRouterConfig()"})," method, where it specifies which controllers create certain routes."]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["Note that here the ",(0,n.jsx)(t.code,{children:"PostRouter"})," type is created for the tRPC client. It is recommended to do this for each non-nested (!) module to mitigate ",(0,n.jsx)(t.a,{href:"https://github.com/trpc/trpc/discussions/2448",children:"TypeScript performance issues"})," when it infers types from complex models. But remember that such types will not work correctly for nested modules. In this example, ",(0,n.jsx)(t.code,{children:"CommentModule"})," is nested, so it is not advisable to create ",(0,n.jsx)(t.code,{children:"export type CommentsRouter = RouterOf<typeof CommentsModule>"})," for it."]}),"\n",(0,n.jsxs)(t.p,{children:["You can also centrally infer a single type for the merged tRPC router at the application level, but this is recommended only if you do not plan to create complex models that would cause TypeScript to \u201cstruggle\u201d when analyzing them. To centrally infer a single router for the entire application, you should use ",(0,n.jsx)(t.code,{children:"AppRouterHelper"}),":"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",metastring:"{9-10,13}",children:"import { rootModule } from '@ditsmod/core';\nimport type { SetAppRouterOptions, TrpcCreateOptions, TrpcRootModule } from '@ditsmod/trpc';\nimport type { AppRouterHelper } from '@ditsmod/trpc/client';\n\nimport { PostModule } from '#post/post.module.js';\nimport { AuthModule } from '#auth/auth.module.js';\nimport { MessageModule } from '#message/message.module.js';\n\nconst modulesWithTrpcRoutes = [AuthModule, PostModule, MessageModule] as const;\nexport type AppRouter = AppRouterHelper<typeof modulesWithTrpcRoutes>;\n\n@rootModule({\n  imports: [...modulesWithTrpcRoutes],\n})\nexport class AppModule implements TrpcRootModule {\n  setTrpcCreateOptions(): TrpcCreateOptions {\n    return {\n      // Passing options for initTRPC.create()\n    };\n  }\n\n  setAppRouterOptions(): SetAppRouterOptions {\n    return {\n      basePath: '/trpc/',\n    };\n  }\n}\n"})}),"\n",(0,n.jsxs)(t.p,{children:["Note that in ",(0,n.jsx)(t.code,{children:"AppRouterHelper"}),", not just an array of imported modules is passed, but the array is also marked with ",(0,n.jsx)(t.code,{children:"as const"})," \u2014 this is an important condition without which ",(0,n.jsx)(t.code,{children:"AppRouterHelper"})," will not work correctly."]}),"\n",(0,n.jsxs)(t.p,{children:["Also note the ",(0,n.jsx)(t.code,{children:"TrpcRootModule"})," interface, which requires mandatory implementation of the ",(0,n.jsx)(t.code,{children:"setAppRouterOptions()"})," method, and optionally you can implement ",(0,n.jsx)(t.code,{children:"setTrpcCreateOptions()"}),". When your ",(0,n.jsx)(t.code,{children:"setAppRouterOptions()"})," method returns a router config, you cannot pass the ",(0,n.jsx)(t.code,{children:"createContext"})," option, because Ditsmod automatically creates the context as an object ",(0,n.jsx)(t.code,{children:"{ req, res }"})," to guarantee availability of these variables in the context. Of course, in procedures you can add any other context properties."]}),"\n",(0,n.jsx)(t.h2,{id:"how-client-types-are-formed-at-the-controller-method-level",children:"How client types are formed at the controller method level"}),"\n",(0,n.jsxs)(t.p,{children:["Each controller method that creates a route must have the ",(0,n.jsx)(t.code,{children:"trpcRoute"})," decorator and must return a tRPC procedure:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",metastring:"{8-10}",children:"import { trpcController, TrpcRouteService, trpcRoute } from '@ditsmod/trpc';\nimport { z } from 'zod';\n\n@trpcController()\nexport class PostController {\n  @trpcRoute()\n  createPost(routeService: TrpcRouteService) {\n    return routeService.procedure.input(z.object({ title: z.string() })).mutation(({ input }) => {\n      return { ...input, id: 1, body: 'post text' };\n    });\n  }\n}\n"})}),"\n",(0,n.jsxs)(t.p,{children:["That is, if you only need to use the benefits of DI at the route level (and not at the HTTP request level), your code will differ little from native tRPC code. The only practical difference is that you must take the initial procedure from ",(0,n.jsx)(t.code,{children:"TrpcRouteService"}),", as shown in this example. By the way, ",(0,n.jsx)(t.code,{children:"TrpcRouteService"})," can specify the context and input type \u2014 ",(0,n.jsx)(t.code,{children:"TrpcRouteService<SomeContext, SomeInput>"}),". Keep in mind that if you plan to write ",(0,n.jsx)(t.code,{children:"routeService.procedure.input(...)"}),", you do not need to pass the second generic, because input types will conflict. The second generic makes sense to use in combination with ",(0,n.jsx)(t.code,{children:"routeService.procedureAfterInput"}),", which should be used in case you perform validation automatically in interceptors rather than directly in the route code."]}),"\n",(0,n.jsxs)(t.p,{children:["In addition to ",(0,n.jsx)(t.code,{children:"TrpcRouteService"}),", you can request any other service at the route level in the controller method parameters, and the order of parameters does not matter:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",metastring:"{4}",children:"@trpcController()\nexport class PostController {\n  @trpcRoute()\n  createPost(service1: Service1, service2: Service2, routeService: TrpcRouteService) {\n    // ...\n  }\n}\n"})}),"\n",(0,n.jsxs)(t.p,{children:["If you need to use guards or interceptors, you just need to add them to the first and second arrays in the ",(0,n.jsx)(t.code,{children:"trpcRoute"})," decorator, respectively:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",metastring:"{9}",children:"import { trpcController, TrpcRouteService, trpcRoute } from '@ditsmod/trpc';\nimport { z } from 'zod';\n\nimport { BearerGuard } from '../auth/bearer.guard.js';\nimport { MyInterceptor } from './my.interceptor.js';\n\n@trpcController()\nexport class PostController {\n  @trpcRoute([BearerGuard], [MyInterceptor])\n  createPost(routeService: TrpcRouteService) {\n    return routeService.procedure.input(z.object({ title: z.string() })).mutation(({ input }) => {\n      return { ...input, id: 1, body: 'post text' };\n    });\n  }\n}\n"})}),"\n",(0,n.jsx)(t.h2,{id:"how-to-use-router-types-on-the-client",children:"How to use router types on the client"}),"\n",(0,n.jsxs)(t.p,{children:["As mentioned above, to mitigate ",(0,n.jsx)(t.a,{href:"https://github.com/trpc/trpc/discussions/2448",children:"TypeScript performance issues"}),', it is recommended to infer the type for each non-nested (!) module. A "non-nested module" means a module that is directly imported into the root module. Therefore, when creating a client, it is recommended to use a generic type for the router \u2014 ',(0,n.jsx)(t.code,{children:"createTRPCClient<AnyTRPCRouter>()"}),", and then refine the type for each specific module:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:"import type { AnyTRPCRouter } from '@trpc/server';\nimport { createTRPCClient, TRPCClient } from '@trpc/client';\nimport type { PostRouter } from 'server'; // You can give this name in your monorepo\n\nconst trpc = createTRPCClient<AnyTRPCRouter>({\n  // ...\n});\n\nconst postClient = trpc as TRPCClient<PostRouter>;\nconst post = await postClient.post.createPost.mutate({ title: 'hello client' });\n"})}),"\n",(0,n.jsx)(t.h2,{id:"using-di-for-providers-at-the-http-request-level",children:"Using DI for Providers at the HTTP Request Level"}),"\n",(0,n.jsx)(t.p,{children:"When you write the following code, DI will provide route-level providers for you:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:"@trpcController()\nexport class PostController {\n  constructor(service1: Service1) {}\n\n  @trpcRoute()\n  listPosts(service2: Service2, routeService: TrpcRouteService) {\n    return routeService.procedure.query(() => this.service1.messages);\n  }\n}\n"})}),"\n",(0,n.jsxs)(t.p,{children:["In this example, DI will resolve the dependencies for ",(0,n.jsx)(t.code,{children:"Service1"}),", ",(0,n.jsx)(t.code,{children:"Service2"}),", and ",(0,n.jsx)(t.code,{children:"TrpcRouteService"})," at the route level. However, if you want DI to also work at the HTTP request level, you need to take three steps:"]}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["Create a ",(0,n.jsx)(t.a,{href:"/components-of-ditsmod-app/dependency-injection/#providers",children:"ClassFactoryProvider"})," that works at the request level."]}),"\n",(0,n.jsx)(t.li,{children:"Pass the newly created provider to DI at the request level."}),"\n",(0,n.jsxs)(t.li,{children:["Use the newly created provider with one of the ",(0,n.jsx)(t.code,{children:"TrpcRouteService"})," methods whose name has the ",(0,n.jsx)(t.code,{children:"di"})," prefix (for example, ",(0,n.jsx)(t.code,{children:"diQuery"}),", ",(0,n.jsx)(t.code,{children:"diMutation"}),", etc.)."]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"Let\u2019s go through these steps together."}),"\n",(0,n.jsx)(t.h3,{id:"step-one",children:"Step One"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:"import { injectable, factoryMethod } from '@ditsmod/core';\nimport { opts, TrpcOpts } from '@ditsmod/trpc';\n\nimport { DbService } from '#db/db.service.js';\nimport { InputPost } from '#models/post.js';\n\n\n@injectable()\nexport class PostService {\n  @factoryMethod()\n  method1(@opts opts: TrpcOpts<any, InputPost>, db: DbService) {\n    // ...\n    return posts;\n  }\n}\n"})}),"\n",(0,n.jsx)(t.p,{children:"Note that at the method level, this provider has a decorator, and it doesn\u2019t matter which one specifically \u2014 the important part is that it is created using the appropriate Ditsmod helpers."}),"\n",(0,n.jsx)(t.h3,{id:"step-two",children:"Step Two"}),"\n",(0,n.jsxs)(t.p,{children:["The easiest way to pass a ",(0,n.jsx)(t.code,{children:"ClassFactoryProvider"})," to DI is by using the ",(0,n.jsx)(t.code,{children:"Providers"})," helper:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",metastring:"{6}",children:"import { trpcController } from '@ditsmod/trpc';\nimport { Providers } from '@ditsmod/core';\nimport { PostService } from '#post/post.service.js';\n// ...\n@trpcController({\n  providersPerReq: new Providers().useFactories(PostService),\n})\nexport class PostController {\n  // ...\n}\n"})}),"\n",(0,n.jsx)(t.p,{children:"By the way, in this example, the providers are passed into the controller metadata, but they can also be passed into the module metadata at the request level."}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"providers.useFactories()"})," method automatically scans for methods with decorators in the given class and creates a provider for each such method. For example, if you pass ",(0,n.jsx)(t.code,{children:"providers.useFactories(PostService)"})," and ",(0,n.jsx)(t.code,{children:"PostService"})," has three methods with method-level decorators, then ",(0,n.jsx)(t.code,{children:"providers.useFactories(PostService)"})," will pass to DI approximately the following providers:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:"[\n  { useFactory: [PostService, PostService.prototype.method1] },\n  { useFactory: [PostService, PostService.prototype.method2] },\n  { useFactory: [PostService, PostService.prototype.method3] },\n]\n"})}),"\n",(0,n.jsx)(t.h3,{id:"step-three",children:"Step Three"}),"\n",(0,n.jsx)(t.p,{children:"Once the providers are passed to DI, they can be used in the following form:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",metastring:"{7}",children:"import { TrpcRouteService, trpcRoute } from '@ditsmod/trpc';\nimport { PostService } from '#post/post.service.js';\n//...\nexport class PostController {\n  @trpcRoute()\n  listPosts(routeService: TrpcRouteService) {\n    return routeService.diQuery(PostService.prototype.method1);\n  }\n}\n"})}),"\n",(0,n.jsxs)(t.p,{children:["That is, the ",(0,n.jsx)(t.code,{children:"routeService.diQuery()"})," method takes the controller method, and DI looks up a provider with that token in the registry and returns its value. In this case, for each request, an instance of ",(0,n.jsx)(t.code,{children:"PostService"})," will be created, and its ",(0,n.jsx)(t.code,{children:"method1"})," will be called."]})]})}function p(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(a,{...e})}):a(e)}},8453:(e,t,o)=>{o.d(t,{R:()=>i,x:()=>c});var r=o(6540);const n={},s=r.createContext(n);function i(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);