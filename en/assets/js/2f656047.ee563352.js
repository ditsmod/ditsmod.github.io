"use strict";(self.webpackChunkditsmod_github_io=self.webpackChunkditsmod_github_io||[]).push([[793],{4368:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>c,toc:()=>d});var t=r(4848),s=r(8453);const i={sidebar_position:2},o="Dependency Injection",c={id:"components-of-ditsmod-app/dependency-injection",title:"Dependency Injection",description:"Why do you need DI?",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/00-components-of-ditsmod-app/02-dependency-injection.md",sourceDirName:"00-components-of-ditsmod-app",slug:"/components-of-ditsmod-app/dependency-injection",permalink:"/en/components-of-ditsmod-app/dependency-injection",draft:!1,unlisted:!1,editUrl:"https://github.com/ditsmod/ditsmod/edit/main/website/i18n/en/docusaurus-plugin-content-docs/current/00-components-of-ditsmod-app/02-dependency-injection.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Router, controllers and services",permalink:"/en/components-of-ditsmod-app/controllers-and-services"},next:{title:"HTTP Interceptors",permalink:"/en/components-of-ditsmod-app/http-interceptors"}},a={},d=[{value:"Why do you need DI?",id:"why-do-you-need-di",level:2},{value:"The &quot;magic&quot; of working with metadata",id:"the-magic-of-working-with-metadata",level:2},{value:"Dependency",id:"dependency",level:2},{value:"Optional dependency",id:"optional-dependency",level:3},{value:"Dependency token",id:"dependency-token",level:2},{value:"Providers",id:"providers",level:2},{value:"Injector",id:"injector",level:2},{value:"Hierarchy of injectors",id:"hierarchy-of-injectors",level:2},{value:"Hierarchy of injectors in the Ditsmod application",id:"hierarchy-of-injectors-in-the-ditsmod-application",level:3},{value:"Hierarchy of controller injectors",id:"hierarchy-of-controller-injectors",level:3},{value:"Hierarchy of service injectors",id:"hierarchy-of-service-injectors",level:3},{value:"Current injector",id:"current-injector",level:3},{value:"Multi-providers",id:"multi-providers",level:2},{value:"Substinuting multi-providers",id:"substinuting-multi-providers",level:3},{value:"Passing of providers to the DI registry",id:"passing-of-providers-to-the-di-registry",level:2},{value:"Re-adding providers",id:"re-adding-providers",level:2},{value:"Editing values in the DI registry",id:"editing-values-in-the-di-registry",level:2},{value:"The fromSelf and skipSelf decorators",id:"the-fromself-and-skipself-decorators",level:2},{value:"fromSelf",id:"fromself",level:3},{value:"skipSelf",id:"skipself",level:3},{value:"When DI can&#39;t find the right provider",id:"when-di-cant-find-the-right-provider",level:2}];function l(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"dependency-injection",children:"Dependency Injection"}),"\n",(0,t.jsx)(n.h2,{id:"why-do-you-need-di",children:"Why do you need DI?"}),"\n",(0,t.jsxs)(n.p,{children:["Let's first get a general idea of how ",(0,t.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Dependency_injection",children:"Dependency Injection"})," (or just DI) works, and then look at each important component in detail."]}),"\n",(0,t.jsxs)(n.p,{children:["It's probably easiest to understand exactly what DI does by looking at examples. Let's start with examples where DI is not used. In this case, we need an instance of the ",(0,t.jsx)(n.code,{children:"Service3"})," class and its ",(0,t.jsx)(n.code,{children:"doSomething()"})," method:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"title='./services.ts'",children:"export class Service1 {}\n\nexport class Service2 {\n  constructor(private service1: Service1) {}\n  // ...\n  // Using this.service1 in one of the methods.\n}\n\nexport class Service3 {\n  constructor(private service2: Service2) {}\n\n  doSomething(param1: any) {\n    // Using this.service2 in this method.\n  }\n}\n\nexport function getService3() {\n  const service1 = new Service1();\n  const service2 = new Service2(service1);\n  return new Service3(service2);\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["As you can see, ",(0,t.jsx)(n.code,{children:"Service3"})," depends on ",(0,t.jsx)(n.code,{children:"Service2"}),", which depends on ",(0,t.jsx)(n.code,{children:"Service1"}),". While the ",(0,t.jsx)(n.code,{children:"Service3"})," instance is quite easy to get:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"{5} title='./some.service.ts'",children:"import { getService3 } from './services.js';\n\nexport class SomeService {\n  method1() {\n    const service3 = getService3();\n    service3.doSomething(123);\n  }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"getService3"})," function is hard-coded to create an instance of ",(0,t.jsx)(n.code,{children:"Service3"}),", and this is a problem because writing unit tests for this function is problematic, especially in the context of an EcmaScript module, since you cannot substitute ",(0,t.jsx)(n.code,{children:"Service1"})," and ",(0,t.jsx)(n.code,{children:"Service2"})," with mocks. Another serious drawback of the ",(0,t.jsx)(n.code,{children:"getService3"})," function is that it can become quite complex in a real application, since it has to consider the configuration of each of the dependencies. That is, in the first case in the ",(0,t.jsx)(n.code,{children:"getService3"})," body, it can be expected to create new ",(0,t.jsx)(n.code,{children:"Service1"})," and ",(0,t.jsx)(n.code,{children:"Service2"})," instances each time, in the second case - they must be ",(0,t.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Singleton_pattern",children:"singletons"})," for the entire application, and in the third case - only one of them should be singleton..."]}),"\n",(0,t.jsxs)(n.p,{children:["The following example already uses DI, although this example is almost the same as the previous example, where we also declared the ",(0,t.jsx)(n.code,{children:"Service3"})," class, but here we added an ",(0,t.jsx)(n.code,{children:"injectable"})," decorator above each class that has a constructor with parameters, and did not create a ",(0,t.jsx)(n.code,{children:"getService3"})," function:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"{5,12} title='./services.ts'",children:"import { injectable } from '@ditsmod/core';\n\nexport class Service1 {}\n\n@injectable()\nexport class Service2 {\n  constructor(private service1: Service1) {}\n  // ...\n  // Using this.service1 in one of the methods.\n}\n\n@injectable()\nexport class Service3 {\n  constructor(private service2: Service2) {}\n\n  doSomething(param1: any) {\n    // Using this.service2 in one of the methods.\n  }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["It's important to understand that the ",(0,t.jsx)(n.code,{children:"injectable"})," decorator is only needed because there is no way in JavaScript code to specify the type of the parameter in the constructor, as it is done in TypeScript code. As long as this decorator doesn't take any parameters in Ditsmod, it's not used as intended in JavaScript for class-level decorators. The role of the ",(0,t.jsx)(n.code,{children:"injectable"})," decorator is very simple - its presence tells the TypeScript compiler that it is necessary to transfer to the JavaScript code those metadata that are in the TypeScript code in the class constructors. For example, the presence of the ",(0,t.jsx)(n.code,{children:"injectable"})," decorator over the ",(0,t.jsx)(n.code,{children:"Service2"})," class will signal to the TypeScript compiler that it should remember ",(0,t.jsx)(n.code,{children:"Service1"})," as the first parameter in the constructor. This metadata is exported into JavaScript code using the TypeScript compiler and stored using the methods of the ",(0,t.jsx)(n.code,{children:"Reflect"})," class from the ",(0,t.jsx)(n.code,{children:"reflect-metadata"})," library."]}),"\n",(0,t.jsxs)(n.p,{children:["Later, when we pass classes with stored metadata to DI (more on this later), this metadata can be read by DI and used to automatically substitute the corresponding class instances, so we can request an instance of ",(0,t.jsx)(n.code,{children:"Service3"})," in the constructor of any class in our program:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"{4,6,9} title='./some.service.ts'",children:"import { injectable } from '@ditsmod/core';\nimport { Service3 } from './services.js';\n\n@injectable()\nexport class SomeService {\n  constructor(private service3: Service3) {}\n\n  method1() {\n    this.service3.doSomething(123);\n  }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["As you can see, we no longer create an instance of ",(0,t.jsx)(n.code,{children:"Service3"})," using the ",(0,t.jsx)(n.code,{children:"new"})," operator, instead, DI does this and passes the finished instance to the constructor. Even if the parameters in the ",(0,t.jsx)(n.code,{children:"Service3"})," constructor are changed later, nothing will have to be changed in the places where ",(0,t.jsx)(n.code,{children:"Service3"})," is used."]}),"\n",(0,t.jsx)(n.h2,{id:"the-magic-of-working-with-metadata",children:'The "magic" of working with metadata'}),"\n",(0,t.jsxs)(n.p,{children:['From a JavaScript developer\'s point of view, the fact that DI can somehow look through the parameters of class constructors and see other classes there can be called "magic". If you look at the ',(0,t.jsx)(n.code,{children:"@ditsmod/core"})," repository, you can see that:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["in the file ",(0,t.jsx)(n.code,{children:"tsconfig.json"})," is specified ",(0,t.jsx)(n.a,{href:"https://github.com/ditsmod/ditsmod/blob/core-2.51.1/packages/core/tsconfig.json#L30",children:'"emitDecoratorMetadata": true'}),";"]}),"\n",(0,t.jsxs)(n.li,{children:["the ",(0,t.jsx)(n.code,{children:"package.json"})," file specifies the dependency on the ",(0,t.jsx)(n.a,{href:"https://github.com/ditsmod/ditsmod/blob/core-2.51.1/packages/core/package.json#L52",children:"reflect-metadata"})," library;"]}),"\n",(0,t.jsxs)(n.li,{children:["there are a number of decorators (",(0,t.jsx)(n.code,{children:"rootModule"}),", ",(0,t.jsx)(n.code,{children:"featureModule"}),", ",(0,t.jsx)(n.code,{children:"controller"}),", ",(0,t.jsx)(n.code,{children:"injectable"}),"...)."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:'All of these components provide the "magic" of reading and storing the metadata that you write in your classes using decorators. You may not have a deep understanding of exactly how this "magic" works, but you should at least remember what its components are.'}),"\n",(0,t.jsxs)(n.p,{children:["It's also worth noting that Ditsmod doesn't use ",(0,t.jsx)(n.a,{href:"https://github.com/tc39/proposal-decorators",children:"new decorators"})," because they don't yet have an API for handling method parameters."]}),"\n",(0,t.jsx)(n.h2,{id:"dependency",children:"Dependency"}),"\n",(0,t.jsx)(n.p,{children:"If creating an instance of a given class requires first creating instances of other classes, then that class has dependencies. For example, if you write this in the service constructor:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"{6}",children:"import { injectable } from '@ditsmod/core';\nimport { FirstService } from './first.service.js';\n\n@injectable()\nexport class SecondService {\n  constructor(private firstService: FirstService) {}\n  // ...\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["this means that ",(0,t.jsx)(n.code,{children:"SecondService"})," has a dependency on ",(0,t.jsx)(n.code,{children:"FirstService"}),", and you is expected that DI will resolve this dependency as follows:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["DI will first look through the constructor of ",(0,t.jsx)(n.code,{children:"FirstService"}),";"]}),"\n",(0,t.jsxs)(n.li,{children:["if ",(0,t.jsx)(n.code,{children:"FirstService"})," has no dependency, an instance of ",(0,t.jsx)(n.code,{children:"FirstService"})," will be created;"]}),"\n",(0,t.jsxs)(n.li,{children:["instance of ",(0,t.jsx)(n.code,{children:"FirstService"})," will be passed to the ",(0,t.jsx)(n.code,{children:"SecondService"})," constructor."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["If after the first step it turns out that ",(0,t.jsx)(n.code,{children:"FirstService"})," has its own dependencies, then DI will recursively execute these three steps for each given dependency."]}),"\n",(0,t.jsxs)(n.p,{children:["If you forget to write (or intentionally remove) the ",(0,t.jsx)(n.code,{children:"injectable"})," decorator before a class that has dependencies in the constructor, DI will throw an error saying that it cannot resolve the dependency of the given class. This is because ",(0,t.jsx)(n.code,{children:"injectable"})," is involved in reading and saving class metadata."]}),"\n",(0,t.jsx)(n.h3,{id:"optional-dependency",children:"Optional dependency"}),"\n",(0,t.jsxs)(n.p,{children:["Sometimes you may need to specify an optional dependency in the constructor. Let's take a look at the following example, where a question mark is placed after the ",(0,t.jsx)(n.code,{children:"firstService"})," property, thus indicating to TypeScript that this property is optional:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"{6}",children:"import { injectable } from '@ditsmod/core';\nimport { FirstService } from './first.service.js';\n\n@injectable()\nexport class SecondService {\n  constructor(private firstService?: FirstService) {}\n  // ...\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["But DI will ignore this optionality and generate an error if there is no possibility to create ",(0,t.jsx)(n.code,{children:"FirstService"}),". To make this code work, you need use the ",(0,t.jsx)(n.code,{children:"optional"})," decorator:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"{6}",children:"import { injectable, optional } from '@ditsmod/core';\nimport { FirstService } from './first.service.js';\n\n@injectable()\nexport class SecondService {\n  constructor(@optional() private firstService?: FirstService) {}\n  // ...\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"dependency-token",children:"Dependency token"}),"\n",(0,t.jsx)(n.p,{children:"You've seen the dependency token many times in previous examples, but we haven't formally introduced it yet. Let's go back to the previous example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"{6}",children:"import { injectable } from '@ditsmod/core';\nimport { FirstService } from './first.service.js';\n\n@injectable()\nexport class SecondService {\n  constructor(private firstService: FirstService) {}\n  // ...\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This implies that ",(0,t.jsx)(n.code,{children:"FirstService"})," is a class, and because of this it can be used both as a TypeScript type and as a ",(0,t.jsx)(n.strong,{children:"token"}),". Basically, a token is an identifier that is associated with the corresponding dependency. It is very important to understand that the token usage mechanism itself is required for JavaScript runtime, therefore, as tokens, you cannot use the types that we declare in TypeScript code with the keywords ",(0,t.jsx)(n.code,{children:"interface"}),", ",(0,t.jsx)(n.code,{children:"type"}),", ",(0,t.jsx)(n.code,{children:"enum"}),", etc., because they don't exist in JavaScript code."]}),"\n",(0,t.jsx)(n.p,{children:"Unlike a class, an array cannot be used both as a TypeScript type and as a token at the same time. On the other hand, a token can have a completely irrelevant data type relative to the dependency it is associated with, so for example a string token type can be associated with a dependency that has any TypeScript type, including arrays, interfaces, enums, etc."}),"\n",(0,t.jsxs)(n.p,{children:["You can transfer the token in the short or long form of specifying the dependency. In the last example, a ",(0,t.jsx)(n.strong,{children:"short form"})," of specifying the dependency is used, it has significant limitations, because in this way it is possible to specify a dependency only on a certain ",(0,t.jsx)(n.em,{children:"class"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["And there is a ",(0,t.jsx)(n.strong,{children:"long form"})," of specifying a dependency using the ",(0,t.jsx)(n.code,{children:"inject"})," decorator, which allows you to use an alternative token:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"{6}",children:"import { injectable, inject } from '@ditsmod/core';\nimport { InterfaceOfItem } from './types.js';\n\n@injectable()\nexport class SecondService {\n  constructor(@inject('some-string') private someArray: InterfaceOfItem[]) {}\n  // ...\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["When ",(0,t.jsx)(n.code,{children:"inject"})," is used, DI only considers the token passed to it. In this case, DI ignores the variable type - ",(0,t.jsx)(n.code,{children:"InterfaceOfItem[]"})," - and uses the ",(0,t.jsx)(n.code,{children:"some-string"})," as the token. Thus, DI allows you to separate token and variable type, so you can get any kind of dependency in the constructor, including different types of arrays or enums."]}),"\n",(0,t.jsxs)(n.p,{children:["A token can be a reference to a class, object or function, and text, numeric values, and symbols can also be used as a token. For the long form of specifying dependencies, we recommend using an instance of the ",(0,t.jsx)(n.code,{children:"InjectionToken<T>"})," class as the token, since the ",(0,t.jsx)(n.code,{children:"InjectionToken<T>"})," class has a parameterized type ",(0,t.jsx)(n.code,{children:"T"})," that can be used to specify the type of data associated with that token:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"{5,14}",children:"// tokens.ts\nimport { InjectionToken } from '@ditsmod/core';\nimport { InterfaceOfItem } from './types.js';\n\nconst SOME_TOKEN = new InjectionToken<InterfaceOfItem[]>('SOME_TOKEN');\n\n// second-service.ts\nimport { injectable, inject } from '@ditsmod/core';\nimport { InterfaceOfItem } from './types.js';\nimport { SOME_TOKEN } from './tokens.js';\n\n@injectable()\nexport class SecondService {\n  constructor(@inject(SOME_TOKEN) private someArray: InterfaceOfItem[]) {}\n  // ...\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"providers",children:"Providers"}),"\n",(0,t.jsx)(n.p,{children:"DI has a registry, which is essentially a mapping between a token and the value to be issued for that token. Schematically, this registry can be shown as follows:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"token1 -> value15\ntoken2 -> value100\n...\n"})}),"\n",(0,t.jsx)(n.p,{children:"As you might guess, when DI resolves a dependency, it takes tokens from the constructor parameters of a particular class and looks for their values in the DI registry. If all the required tokens are found in the registry, their values are passed to the constructor, successfully resolving the dependency of that class."}),"\n",(0,t.jsxs)(n.p,{children:["DI creates values in the registry for each token using what are called ",(0,t.jsx)(n.strong,{children:"providers"}),". So, in order for DI to resolve a certain dependency, the corresponding provider must first be passed to the DI registry, and then DI will issue the value of that provider by its token. Therefore, if you specified a certain dependency in a class, but did not pass the corresponding provider, DI will not be able to resolve that dependency. The ",(0,t.jsx)(n.a,{href:"#passing-of-providers-to-the-di-registry",children:"next section"})," discusses how providers can be passed to DI. A provider can be either a class or an object:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"{3-8}",children:"import { Class } from '@ditsmod/core';\n\ntype Provider = Class<any> |\n{ token: any, useClass: Class<any>, multi?: boolean } |\n{ token: any, useValue: any, multi?: boolean } |\n{ token?: any, useFactory: [Class<any>, Class<any>.prototype.methodName], multi?: boolean } |\n{ token?: any, useFactory: (...args: any[]) => any, deps: any[], multi?: boolean } |\n{ token: any, useToken: any, multi?: boolean }\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Note that the token for the provider with the ",(0,t.jsx)(n.code,{children:"useFactory"})," property is optional because DI can use a function or method of the specified class as the token."]}),"\n",(0,t.jsx)(n.p,{children:"If the provider is represented as an object, the following values can be passed to its properties:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"useClass"})," - the class whose instance will be used as the value of this provider is passed here. An example of such a provider:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"{ token: 'token1', useClass: SomeService }\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"useValue"})," - any value other than ",(0,t.jsx)(n.code,{children:"undefined"})," is passed here, DI will output it unchanged. An example of such a provider:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"{ token: 'token2', useValue: 'some value' }\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"useFactory"})," - you can pass arguments here in two forms."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.strong,{children:"first form"})," (recommended because of its better encapsulation) assumes that a ",(0,t.jsx)(n.a,{href:"https://www.typescriptlang.org/docs/handbook/2/objects.html#tuple-types",children:"tuple"})," is passed to ",(0,t.jsx)(n.code,{children:"useFactory"}),", where the first place should be a class, and the second place should be a method of this class that must return some value for the specified token. For example, if the class is like this:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"import { methodFactory } from '@ditsmod/core';\n\nexport class ClassWithFactory {\n  @methodFactory()\n  method1(dependecy1: Dependecy1, dependecy2: Dependecy2) {\n    // ...\n    return '...';\n  }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"in this case, the provider must be transferred to the DI registry in the following format:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"{ token: 'token3', useFactory: [ClassWithFactory, ClassWithFactory.prototype.method1] }\n"})}),"\n",(0,t.jsxs)(n.p,{children:["First, DI will create an instance of this class, then call its method and get the result, which will be associated with the specified token. A method of the specified class can return any value except ",(0,t.jsx)(n.code,{children:"undefined"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.strong,{children:"second form"})," implies that you can pass a function to ",(0,t.jsx)(n.code,{children:"useFactory"})," that can have parameters - that is, it can have a dependency. This dependency must be additionally manually specified in the ",(0,t.jsx)(n.code,{children:"deps"})," property as an array of tokens, and the order in which the tokens are passed is important:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"{6}",children:"function fn1(service1: Service1, service2: Service2) {\n  // ...\n  return 'some value';\n}\n\n{ token: 'token3', useFactory: fn1, deps: [Service1, Service2] }\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Please note that it is the provider ",(0,t.jsx)(n.em,{children:"tokens"})," that are passed to the ",(0,t.jsx)(n.code,{children:"deps"})," property, and DI perceives them as tokens, not providers. That is, for these tokens, the DI registry will still need to ",(0,t.jsx)(n.a,{href:"#passing-of-providers-to-the-di-registry",children:"transfer the corresponding providers"}),". Also note that no parameter decorators are passed via ",(0,t.jsx)(n.code,{children:"deps"})," (such as ",(0,t.jsx)(n.code,{children:"fromSelf"})," and ",(0,t.jsx)(n.code,{children:"skipSelf"}),"). If your factory requires parameter decorators, you need to use the first form of passing arguments to ",(0,t.jsx)(n.code,{children:"useFactory"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"useToken"})," - another token is passed to this provider property. If you write the following:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"{ token: SecondService, useToken: FirstService }\n"})}),"\n",(0,t.jsxs)(n.p,{children:['this is how you tell DI: "When consumers of providers request the ',(0,t.jsx)(n.code,{children:"SecondService"})," token, the value for the ",(0,t.jsx)(n.code,{children:"FirstService"}),' token should be used". In other words, this directive makes an alias ',(0,t.jsx)(n.code,{children:"SecondService"})," that points to ",(0,t.jsx)(n.code,{children:"FirstService"}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Now that you are familiar with the concept of ",(0,t.jsx)(n.strong,{children:"provider"}),", you can clarify that ",(0,t.jsx)(n.strong,{children:"dependency"})," means dependency on ",(0,t.jsx)(n.strong,{children:"provider value"}),". Consumers of provider values have such a dependency either in service constructors, in controller constructors or methods, or in the ",(0,t.jsx)(n.code,{children:"get()"})," method of ",(0,t.jsx)(n.a,{href:"#injector",children:"injectors"})," (more on this later)."]}),"\n",(0,t.jsx)(n.h2,{id:"injector",children:"Injector"}),"\n",(0,t.jsxs)(n.p,{children:["In the description of providers it was mentioned about ",(0,t.jsx)(n.em,{children:"DI registers"}),", now let's understand how these registers are formed and where exactly they are located."]}),"\n",(0,t.jsxs)(n.p,{children:["If you greatly simplify the scheme of operation of DI, you can say that DI accepts an array of providers at the input, and at the output produces an ",(0,t.jsx)(n.strong,{children:"injector"})," that is able to create values for each transmitted provider. That is, DI registers are formed based on arrays of providers that are passed to the injector:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"{15}",children:"import { Injector, injectable } from '@ditsmod/core';\n\nclass Service1 {}\n\n@injectable()\nclass Service2 {\n  constructor(service1: Service1) {}\n}\n\n@injectable()\nclass Service3 {\n  constructor(service2: Service2) {}\n}\n\nconst injector = Injector.resolveAndCreate([Service1, Service2, Service3]);\nconst service3 = injector.get(Service3);\nservice3 === injector.get(Service3); // true\nservice3 === injector.resolveAndInstantiate(Service3); // false\n"})}),"\n",(0,t.jsxs)(n.p,{children:["As you can see, the ",(0,t.jsx)(n.code,{children:"Injector.resolveAndCreate()"})," method accepts an array of providers as an input, and outputs an injector that can output the value of each provider by its token using the ",(0,t.jsx)(n.code,{children:"injector.get()"})," method, taking into account the entire chain of dependencies (",(0,t.jsx)(n.code,{children:"Service3"})," -> ",(0,t.jsx)(n.code,{children:"Service2"})," -> ",(0,t.jsx)(n.code,{children:"Service1"}),")."]}),"\n",(0,t.jsxs)(n.p,{children:["What the ",(0,t.jsx)(n.code,{children:"injector.get()"})," does:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["when ",(0,t.jsx)(n.code,{children:"Service3"})," is requested, injector looks at the constructor of this class, sees the dependency on ",(0,t.jsx)(n.code,{children:"Service2"}),";"]}),"\n",(0,t.jsxs)(n.li,{children:["then looks at the constructor in ",(0,t.jsx)(n.code,{children:"Service2"}),", sees the dependency on ",(0,t.jsx)(n.code,{children:"Service1"}),";"]}),"\n",(0,t.jsxs)(n.li,{children:["then looks at the constructor in ",(0,t.jsx)(n.code,{children:"Service1"}),", does not find dependencies there, and therefore first creates an instance of ",(0,t.jsx)(n.code,{children:"Service1"}),";"]}),"\n",(0,t.jsxs)(n.li,{children:["then creates the ",(0,t.jsx)(n.code,{children:"Service2"})," instance using the ",(0,t.jsx)(n.code,{children:"Service1"})," instance;"]}),"\n",(0,t.jsxs)(n.li,{children:["and lastly creates the ",(0,t.jsx)(n.code,{children:"Service3"})," instance using the ",(0,t.jsx)(n.code,{children:"Service2"})," instance;"]}),"\n",(0,t.jsxs)(n.li,{children:["if the ",(0,t.jsx)(n.code,{children:"Service3"})," instance is requested again later, the ",(0,t.jsx)(n.code,{children:"injector.get()"})," method will return the previously created ",(0,t.jsx)(n.code,{children:"Service3"})," instance from the cache of this injector."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Sometimes the last point (when the ",(0,t.jsx)(n.code,{children:"Service3"})," instance is returned from the injector cache) is undesirable. In this case, you can use the ",(0,t.jsx)(n.code,{children:"injector.resolveAndInstantiate()"})," method, which accepts a provider, resolves it in the context of the current injector, and returns a new instance of the given provider each time."]}),"\n",(0,t.jsxs)(n.p,{children:["When automatically resolving a class dependency (when the injector is not used directly), Ditsmod uses the ",(0,t.jsx)(n.code,{children:"injector.get()"})," method under the hood."]}),"\n",(0,t.jsxs)(n.p,{children:["Using DI, you may not know the entire ",(0,t.jsx)(n.code,{children:"Service3"})," dependency chain, entrust this work to the injector, the main thing is to transfer all necessary classes to the DI registry. Keep in mind that you can write unit tests for individual classes this way."]}),"\n",(0,t.jsx)(n.h2,{id:"hierarchy-of-injectors",children:"Hierarchy of injectors"}),"\n",(0,t.jsx)(n.p,{children:"DI also allows you to create a hierarchy of injectors - this is when there are parent and child injectors. At first glance, there is nothing interesting in such a hierarchy, because it is not clear what it is needed for, but in Ditsmod this possibility is used very often, since it allows you to make the application architecture modular. It is worth paying special attention to the study of the specifics of the hierarchy, it will save you more than one hour of time in the future, because you will know how it works and why it does not find this dependency..."}),"\n",(0,t.jsx)(n.p,{children:"When creating a hierarchy, only the child injector holds the connection, it has an object of the parent injector. At the same time, the parent injector knows nothing about its child injectors. That is, the connection between injectors in the hierarchy is one-way. Conditionally, it looks like this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"{6}",children:"interface Parent {\n  // There are certain properties of the parent injector, but no child injector\n}\n\ninterface Child {\n  parent: Parent;\n  // There are other properties of the child injector.\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"By having a parent injector object, a child injector can refer to its parent when the child needs a provider value that it does not have."}),"\n",(0,t.jsx)(n.p,{children:"Let's consider the following example. For simplicity, no decorators are used here at all, since each class is independent:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"{8-9}",children:"import { Injector } from '@ditsmod/core';\n\nclass Service1 {}\nclass Service2 {}\nclass Service3 {}\nclass Service4 {}\n\nconst parent = Injector.resolveAndCreate([Service1, Service2]); // Parent injector\nconst child = parent.resolveAndCreateChild([Service2, Service3]); // Child injector\n\nchild.get(Service1); // \u041e\u041a\nparent.get(Service1); // \u041e\u041a\n\nparent.get(Service1) === child.get(Service1); // true\n\nchild.get(Service2); // \u041e\u041a\nparent.get(Service2); // \u041e\u041a\n\nparent.get(Service2) === child.get(Service2); // false\n\nchild.get(Service3); // \u041e\u041a\nparent.get(Service3); // Error - No provider for Service3!\n\nchild.get(Service4); // Error - No provider for Service4!\nparent.get(Service4); // Error - No provider for Service4!\n"})}),"\n",(0,t.jsxs)(n.p,{children:["As you can see, when the child injector was created, ",(0,t.jsx)(n.code,{children:"Service1"})," was not passed to it, so when an instance of that class is requested, it goes to the parent. By the way, there is one non-obvious but very important point here: through the ",(0,t.jsx)(n.code,{children:"get()"})," method, child injectors only request certain instances of classes from parent injectors, and they do not create them themselves. That is why this expression returns ",(0,t.jsx)(n.code,{children:"true"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"parent.get(Service1) === child.get(Service1); // true\n"})}),"\n",(0,t.jsxs)(n.p,{children:["And ",(0,t.jsx)(n.code,{children:"Service2"})," is in both injectors, so each of them will create its own local version of this service, and that is why this expression returns ",(0,t.jsx)(n.code,{children:"false"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"parent.get(Service2) === child.get(Service2); // false\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The parent injector cannot create an instance of the ",(0,t.jsx)(n.code,{children:"Service3"})," class because the parent injector has no connection to the child injector that contains ",(0,t.jsx)(n.code,{children:"Service3"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Well, both injectors cannot issue ",(0,t.jsx)(n.code,{children:"Service4"})," instance, because they were not given this class when they were created."]}),"\n",(0,t.jsx)(n.h3,{id:"hierarchy-of-injectors-in-the-ditsmod-application",children:"Hierarchy of injectors in the Ditsmod application"}),"\n",(0,t.jsx)(n.p,{children:"Earlier in this documentation, you encountered the following object properties that are passed in module or controller metadata:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"providersPerApp"})," - providers at the application level;"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"providersPerMod"})," - providers at the module level;"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"providersPerRou"})," - providers at the route level;"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"providersPerReq"})," - providers at the HTTP request level."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Using these arrays, Ditsmod creates different injectors that are connected in a hierarchical relationship. Such a hierarchy can be simulated as follows:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"import { Injector } from '@ditsmod/core';\n\nconst providersPerApp = [];\nconst providersPerMod = [];\nconst providersPerRou = [];\nconst providersPerReq = [];\n\nconst injectorPerApp = Injector.resolveAndCreate(providersPerApp);\nconst injectorPerMod = injectorPerApp.resolveAndCreateChild(providersPerMod);\nconst injectorPerRou = injectorPerMod.resolveAndCreateChild(providersPerRou);\nconst injectorPerReq = injectorPerRou.resolveAndCreateChild(providersPerReq);\n"})}),"\n",(0,t.jsx)(n.p,{children:"Under the hood, Ditsmod performs a similar procedure multiple times for different modules, routes, and requests. For example, if the Ditsmod application has two modules and ten routes, one injector will be created at the application level, one injector for each module (2 pcs), one injector for each route (10 pcs), and one injector for each request. Request-level injectors are automatically removed after processing each request."}),"\n",(0,t.jsxs)(n.p,{children:["Recall that injectors higher in the hierarchy do not have access to injectors lower in the hierarchy. This means that ",(0,t.jsx)(n.strong,{children:"when you transfer a class to a particular injector, you need to consider the minimum level of its dependency hierarchy"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["For example, if you write a class that depends on an HTTP request, you can only pass it to the ",(0,t.jsx)(n.code,{children:"providersPerReq"})," array, as only from this array an injector is formed, to which Ditsmod will automatically add the provider with the HTTP request object. On the other hand, an instance of this class will have access to all of its parent injectors: at the route, module, and application levels. Therefore, this class can depend on providers at any level."]}),"\n",(0,t.jsxs)(n.p,{children:["You can also write a certain class and pass it to the ",(0,t.jsx)(n.code,{children:"providersPerMod"})," array. In this case, it can only depend on providers at the module or application level. If it depends on the providers you passed in the ",(0,t.jsx)(n.code,{children:"providersPerRou"})," or ",(0,t.jsx)(n.code,{children:"providersPerReq"})," array, you will get an error saying that those providers were not found."]}),"\n",(0,t.jsx)(n.h3,{id:"hierarchy-of-controller-injectors",children:"Hierarchy of controller injectors"}),"\n",(0,t.jsxs)(n.p,{children:["Any ",(0,t.jsx)(n.a,{href:"/components-of-ditsmod-app/controllers-and-services/#what-is-a-controller",children:"non-singleton"})," controller, in addition to its own injector at the request level, also has three parent injectors: at the route, module, and application levels. These injectors are also generated based on the providers you pass in the following arrays:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"providersPerApp"}),";"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"providersPerMod"}),";"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"providersPerRou"}),";"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"providersPerReq"})," (this is the array from which the injector for the non-singleton controller is formed)."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"That is, the non-singleton controller can depend on services at any level."}),"\n",(0,t.jsxs)(n.p,{children:["If the controller is ",(0,t.jsx)(n.a,{href:"/components-of-ditsmod-app/controllers-and-services/#what-is-a-controller",children:"singleton"}),", its own injector is at the module level, and it has one parent injector at the application levels:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"providersPerApp"}),";"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"providersPerMod"})," (this is the array from which the injector for the singleton controller is formed)."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"hierarchy-of-service-injectors",children:"Hierarchy of service injectors"}),"\n",(0,t.jsxs)(n.p,{children:["Unlike the controller, the injector of a certain service can be at any level: at the application, module, route, or request level. In practice, this means that the provider for this service is transferred to one (or several) of the above-mentioned arrays. For example, in the following example, ",(0,t.jsx)(n.code,{children:"SomeService"})," is passed to the injector at the route level, and ",(0,t.jsx)(n.code,{children:"OtherService"})," is passed to the injector at the module level:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"{5-6}",children:"import { Injector } from '@ditsmod/core';\n// ...\n\nconst providersPerApp = [];\nconst providersPerMod = [OtherService];\nconst providersPerRou = [SomeService];\nconst providersPerReq = [];\n\nconst injectorPerApp = Injector.resolveAndCreate(providersPerApp);\nconst injectorPerMod = injectorPerApp.resolveAndCreateChild(providersPerMod);\nconst injectorPerRou = injectorPerMod.resolveAndCreateChild(providersPerRou);\nconst injectorPerReq = injectorPerRou.resolveAndCreateChild(providersPerReq);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In this case, if ",(0,t.jsx)(n.code,{children:"SomeService"})," has a dependency on ",(0,t.jsx)(n.code,{children:"OtherService"}),", DI will be able to create an instance of ",(0,t.jsx)(n.code,{children:"SomeService"})," because a route-level injector can get an instance of ",(0,t.jsx)(n.code,{children:"OtherService"})," from its parent module-level injector. But if on the contrary - ",(0,t.jsx)(n.code,{children:"OtherService"})," will have a dependency on ",(0,t.jsx)(n.code,{children:"SomeService"})," - DI will not be able to create an instance of ",(0,t.jsx)(n.code,{children:"OtherService"}),", because the injector at the module level does not see its child injector at the route level."]}),"\n",(0,t.jsx)(n.h3,{id:"current-injector",children:"Current injector"}),"\n",(0,t.jsx)(n.p,{children:"You may rarely need the service or controller injector itself, but you can get it in the constructor, just like the values of any other provider:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"{6}",children:"import { injectable, Injector } from '@ditsmod/core';\nimport { FirstService } from './first.service.js';\n\n@injectable()\nexport class SecondService {\n  constructor(private injector: Injector) {}\n\n  someMethod() {\n    const firstService = this.injector.get(FirstService);  // Lazy loading of dependency\n  }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Keep in mind that this way you get an injector that created an instance of this service. The hierarchy level of this injector depends only on the registry of the injector to which ",(0,t.jsx)(n.code,{children:"SecondService"})," was transferred."]}),"\n",(0,t.jsx)(n.h2,{id:"multi-providers",children:"Multi-providers"}),"\n",(0,t.jsxs)(n.p,{children:["This type of provider exists only in the form of an object, and it differs from regular DI providers by the presence of the ",(0,t.jsx)(n.code,{children:"multi: true"})," property. Such providers are advisable to use when there is a need to transfer several providers with the same token to DI at once, so that DI returns the same number of values for these providers in one array:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"import { Injector } from '@ditsmod/core';\nimport { LOCAL } from './tokens.js';\n\nconst injector = Injector.resolveAndCreate([\n  { token: LOCAL, useValue: 'uk', multi: true },\n  { token: LOCAL, useValue: 'en', multi: true },\n]);\n\nconst locals = injector.get(LOCAL); // ['uk', 'en']\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Basically, multi-providers allow you to create groups of providers that share a common token. This feature is particularly used to create the ",(0,t.jsx)(n.code,{children:"HTTP_INTERCEPTORS"})," group, as well as to create various ",(0,t.jsx)(n.a,{href:"/components-of-ditsmod-app/extensions/#extensions-groups",children:"extension groups"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"It is not allowed that both regular and multi-providers have the same token in one injector:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"{5-6}",children:"import { Injector } from '@ditsmod/core';\nimport { LOCAL } from './tokens.js';\n\nconst injector = Injector.resolveAndCreate([\n  { token: LOCAL, useValue: 'uk' },\n  { token: LOCAL, useValue: 'en', multi: true },\n]);\n\nconst locals = injector.get(LOCAL); // Error: Cannot mix multi providers and regular providers\n"})}),"\n",(0,t.jsx)(n.p,{children:"Child injectors can only return multi-provider values from the parent injector if no providers with the same tokens were passed to them when they were created:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"import { Injector } from '@ditsmod/core';\nimport { LOCAL } from './tokens.js';\n\nconst parent = Injector.resolveAndCreate([\n  { token: LOCAL, useValue: 'uk', multi: true },\n  { token: LOCAL, useValue: 'en', multi: true },\n]);\n\nconst child = parent.resolveAndCreateChild([]);\n\nconst locals = child.get(LOCAL); // ['uk', 'en']\n"})}),"\n",(0,t.jsx)(n.p,{children:"If both the child and the parent injector have multi-providers with the same token, the child injector will return values only from its array:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"import { Injector } from '@ditsmod/core';\nimport { LOCAL } from './tokens.js';\n\nconst parent = Injector.resolveAndCreate([\n  { token: LOCAL, useValue: 'uk', multi: true },\n  { token: LOCAL, useValue: 'en', multi: true },\n]);\n\nconst child = parent.resolveAndCreateChild([\n  { token: LOCAL, useValue: '\u0430\u0430', multi: true }\n]);\n\nconst locals = child.get(LOCAL); // ['\u0430\u0430']\n"})}),"\n",(0,t.jsx)(n.h3,{id:"substinuting-multi-providers",children:"Substinuting multi-providers"}),"\n",(0,t.jsx)(n.p,{children:"To make it possible to substinuting a specific multi-provider, you can do the following:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["transfer a certain class to the multi-provider object using the ",(0,t.jsx)(n.code,{children:"useToken"})," property;"]}),"\n",(0,t.jsx)(n.li,{children:"then transfer this class as a regular provider;"}),"\n",(0,t.jsx)(n.li,{children:"next, you need to transfer the provider to the array of providers to substitute this class."}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"import { Injector, HTTP_INTERCEPTORS } from '@ditsmod/core';\n\nimport { DefaultInterceptor } from './default.interceptor.js';\nimport { MyInterceptor } from './my.interceptor.js';\n\nconst injector = Injector.resolveAndCreate([\n  { token: HTTP_INTERCEPTORS, useToken: DefaultInterceptor, multi: true },\n  DefaultInterceptor,\n  { token: DefaultInterceptor, useClass: MyInterceptor }\n]);\n\nconst locals = injector.get(HTTP_INTERCEPTORS); // [MyInterceptor]\n"})}),"\n",(0,t.jsx)(n.p,{children:"This construction makes sense, for example, if the first two points are performed somewhere in an external module to which you do not have access to edit, and the third point is already performed by the user of current module."}),"\n",(0,t.jsx)(n.h2,{id:"passing-of-providers-to-the-di-registry",children:"Passing of providers to the DI registry"}),"\n",(0,t.jsxs)(n.p,{children:["For one dependency, you need to transfer one or more providers to the DI registry. Most often, providers are passed to the DI registry via module metadata, although sometimes they are passed via controller metadata, or even directly to ",(0,t.jsx)(n.a,{href:"#injector",children:"injectors"}),". In the following example, ",(0,t.jsx)(n.code,{children:"SomeService"})," is passed into the ",(0,t.jsx)(n.code,{children:"providersPerMod"})," array:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"{9}",children:"import { featureModule } from '@ditsmod/core';\n\nimport { SomeService } from './some.service.js';\nimport { SomeController } from './some.controller.js';\n\n@featureModule({\n  controllers: [SomeController],\n  providersPerMod: [\n    SomeService\n  ],\n})\nexport class SomeModule {}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["After such a passing, consumers of providers can use ",(0,t.jsx)(n.code,{children:"SomeService"})," within ",(0,t.jsx)(n.code,{children:"SomeModule"}),". The identical result will be if we pass the same provider in object format:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"{9}",children:"import { featureModule } from '@ditsmod/core';\n\nimport { SomeService } from './some.service.js';\nimport { SomeController } from './some.controller.js';\n\n@featureModule({\n  controllers: [SomeController],\n  providersPerMod: [\n    { token: SomeService, useClass: SomeService }\n  ],\n})\nexport class SomeModule {}\n"})}),"\n",(0,t.jsx)(n.p,{children:"And now let's additionally pass another provider with the same token, but this time in the controller metadata:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"{8}",children:"import { controller } from '@ditsmod/core';\n\nimport { SomeService } from './some.service.js';\nimport { OtherService } from './other.service.js';\n\n@controller({\n  providersPerReq: [\n    { token: SomeService, useClass: OtherService }\n  ]\n})\nexport class SomeController {\n  constructor(private someService: SomeService) {}\n  // ...\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:['Pay attention to the highlighted line. This is how we say DI: "If this controller has a dependency on a provider with token ',(0,t.jsx)(n.code,{children:"SomeService"}),", it should be substituted with an instance of class ",(0,t.jsx)(n.code,{children:"OtherService"}),'". This substitution will be valid only for this controller. All other controllers in ',(0,t.jsx)(n.code,{children:"SomeModule"})," will receive ",(0,t.jsx)(n.code,{children:"SomeService"})," class instances by ",(0,t.jsx)(n.code,{children:"SomeService"})," token."]}),"\n",(0,t.jsx)(n.p,{children:"Similar substitution can be done at the application level and at the module level. This may sometimes be necessary, for example, when you want to have default configuration values at the application level, but custom values of this configuration at the level of a specific module. In this case, pass the default configuration in the root module first:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"{6}",children:"import { rootModule } from '@ditsmod/core';\nimport { ConfigService } from './config.service.js';\n\n@rootModule({\n  providersPerApp: [\n    ConfigService\n  ],\n})\nexport class AppModule {}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["And in a certain module, we substitute ",(0,t.jsx)(n.code,{children:"ConfigService"})," with an arbitrary value:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"{6}",children:"import { featureModule } from '@ditsmod/core';\nimport { ConfigService } from './config.service.js';\n\n@featureModule({\n  providersPerMod: [\n    { token: ConfigService, useValue: { propery1: 'some value' } }\n  ],\n})\nexport class SomeModule {}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"re-adding-providers",children:"Re-adding providers"}),"\n",(0,t.jsx)(n.p,{children:"Different providers with the same token can be added multiple times in the metadata of a module or controller, but DI will choose the last provider added (there is an exception to this rule, but it only applies to multi-providers):"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"import { featureModule } from '@ditsmod/core';\n\n@featureModule({\n  providersPerMod: [\n    { token: 'token1', useValue: 'value1' },\n    { token: 'token1', useValue: 'value2' },\n    { token: 'token1', useValue: 'value3' },\n  ],\n})\nexport class SomeModule {}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In this case, within the ",(0,t.jsx)(n.code,{children:"SomeModule"}),", ",(0,t.jsx)(n.code,{children:"value3"})," will be returned at the module, route, or request level for ",(0,t.jsx)(n.code,{children:"token1"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"In addition, different providers with the same token can be passed at the same time at different levels of the hierarchy, but DI will always choose the closest injectors (i.e., if a value for a provider is queried at the request level, then the injector at the request level will be looked up first, and only if there is no required provider, DI will rise to the parent injectors):"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"import { featureModule } from '@ditsmod/core';\n\n@featureModule({\n  providersPerMod: [{ token: 'token1', useValue: 'value1' }],\n  providersPerRou: [{ token: 'token1', useValue: 'value2' }],\n  providersPerReq: [{ token: 'token1', useValue: 'value3' }],\n})\nexport class SomeModule {}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In this case, within the ",(0,t.jsx)(n.code,{children:"SomeModule"}),", ",(0,t.jsx)(n.code,{children:"value3"})," will be returned at the request level for ",(0,t.jsx)(n.code,{children:"token1"}),", ",(0,t.jsx)(n.code,{children:"value2"})," - at the route level, and ",(0,t.jsx)(n.code,{children:"value1"})," - at the module level."]}),"\n",(0,t.jsx)(n.p,{children:"Also, if you import a specific provider from an external module and you have a provider with the same token in the current module, the local provider will have higher priority, provided they were passed at the same level of the injector hierarchy."}),"\n",(0,t.jsx)(n.h2,{id:"editing-values-in-the-di-registry",children:"Editing values in the DI registry"}),"\n",(0,t.jsxs)(n.p,{children:["As mentioned earlier, ",(0,t.jsx)(n.em,{children:"providers"})," are passed to the DI registry, from which ",(0,t.jsx)(n.em,{children:"values"})," are then formed to finally have a mapping between the token and its value:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"token1 -> value15\ntoken2 -> value100\n...\n"})}),"\n",(0,t.jsxs)(n.p,{children:["There is also an option to edit the ready ",(0,t.jsx)(n.em,{children:"values"})," of the DI register:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"{4}",children:"import { Injector } from '@ditsmod/core';\n\nconst injector = Injector.resolveAndCreate([{ token: 'token1', useValue: undefined }]);\ninjector.setByToken('token1', 'value1');\ninjector.get('token1'); // value1\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Note that in this case, the provider with ",(0,t.jsx)(n.code,{children:"token1"}),", which has the value ",(0,t.jsx)(n.code,{children:"undefined"}),", is transferred to the registry first, and only then do we change the value for that token. If you try to edit a value for a token that is not in the registry, DI will throw an error similar to the following:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:'DiError: Setting value by token failed: cannot find token in register: "token1". Try adding a provider with the same token to the current injector via module or controller metadata.\n'})}),"\n",(0,t.jsxs)(n.p,{children:["In most cases, value editing is used by ",(0,t.jsx)(n.a,{href:"/components-of-ditsmod-app/http-interceptors/",children:"interceptors"})," or ",(0,t.jsx)(n.a,{href:"/components-of-ditsmod-app/guards/",children:"guards"}),", as they thus transfer the result of their work to the registry:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://github.com/ditsmod/ditsmod/blob/core-2.51.2/packages/body-parser/src/body-parser.interceptor.ts#L23",children:"BodyParserInterceptor"}),";"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://github.com/ditsmod/ditsmod/blob/core-2.51.2/examples/14-auth-jwt/src/app/modules/services/auth/bearer.guard.ts#L24",children:"BearerGuard"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["As an alternative to the ",(0,t.jsx)(n.code,{children:"injector.setByToken()"})," method, an equivalent expression can be used:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"{5}",children:"import { KeyRegistry } from '@ditsmod/core';\n\n// ...\nconst { id } = KeyRegistry.get('token1');\ninjector.setById(id, 'value1');\n// ...\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The advantage of using the ",(0,t.jsx)(n.code,{children:"injector.setById()"})," method is that it is faster than the ",(0,t.jsx)(n.code,{children:"injector.setByToken()"})," method, but only if you get the ID from the ",(0,t.jsx)(n.code,{children:"KeyRegistry"})," once and then use ",(0,t.jsx)(n.code,{children:"injector.setById()"})," the many times."]}),"\n",(0,t.jsx)(n.h2,{id:"the-fromself-and-skipself-decorators",children:"The fromSelf and skipSelf decorators"}),"\n",(0,t.jsx)(n.p,{children:"These decorators are used to control the behavior of the injector when searching for values for a particular token. They make sense in the case where there is a certain hierarchy of injectors."}),"\n",(0,t.jsx)(n.h3,{id:"fromself",children:"fromSelf"}),"\n",(0,t.jsxs)(n.p,{children:["The decorator ",(0,t.jsx)(n.code,{children:"fromSelf"})," is used very rarely."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"import { injectable, fromSelf, Injector } from '@ditsmod/core';\n\nclass Service1 {}\n\n@injectable()\nclass Service2 {\n  constructor(@fromSelf() public service1: Service1) {}\n}\n\nconst parent = Injector.resolveAndCreate([Service1, Service2]);\nconst child = parent.resolveAndCreateChild([Service2]);\n\nconst service2 = parent.get(Service2) as Service2;\nservice2.service1 instanceof Service1; // true\n\nchild.get(Service2); // Error - Service1 not found\n"})}),"\n",(0,t.jsxs)(n.p,{children:["As you can see, ",(0,t.jsx)(n.code,{children:"Service2"})," depends on ",(0,t.jsx)(n.code,{children:"Service1"}),", and the ",(0,t.jsx)(n.code,{children:"fromSelf"}),' decorator tells DI: "When creating an instance of ',(0,t.jsx)(n.code,{children:"Service1"}),", use only the same injector that will create an instance of ",(0,t.jsx)(n.code,{children:"Service2"}),', and do not need to refer to the parent injector". When the parent injector is created, it is passed both required services, so when the ',(0,t.jsx)(n.code,{children:"Service2"})," token is requested, it will successfully resolve the dependency and issue an instance of this class."]}),"\n",(0,t.jsxs)(n.p,{children:["But when creating a child injector, ",(0,t.jsx)(n.code,{children:"Service1"})," was not passed to it, so when requesting a ",(0,t.jsx)(n.code,{children:"Service2"})," token, it will not be able to resolve the dependency of this service. If you remove the ",(0,t.jsx)(n.code,{children:"fromSelf"})," decorator from the constructor, the child injector will successfully resolve the ",(0,t.jsx)(n.code,{children:"Service2"})," dependency."]}),"\n",(0,t.jsx)(n.h3,{id:"skipself",children:"skipSelf"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"skipSelf"})," decorator is used more often than ",(0,t.jsx)(n.code,{children:"fromSelf"}),", but also rarely."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"import { injectable, skipSelf, Injector } from '@ditsmod/core';\n\nclass Service1 {}\n\n@injectable()\nclass Service2 {\n  constructor(@skipSelf() public service1: Service1) {}\n}\n\nconst parent = Injector.resolveAndCreate([Service1, Service2]);\nconst child = parent.resolveAndCreateChild([Service2]);\n\nparent.get(Service2); // Error - Service1 not found\n\nconst service2 = child.get(Service2) as Service2;\nservice2.service1 instanceof Service1; // true\n"})}),"\n",(0,t.jsxs)(n.p,{children:["As you can see, ",(0,t.jsx)(n.code,{children:"Service2"})," depends on ",(0,t.jsx)(n.code,{children:"Service1"}),", and the ",(0,t.jsx)(n.code,{children:"skipSelf"}),' decorator tells DI: "When creating an instance of ',(0,t.jsx)(n.code,{children:"Service1"}),", skip the injector that will create an instance of ",(0,t.jsx)(n.code,{children:"Service2"}),' and immediately call the parent injector". When the parent injector is created, it is passed both necessary services, but because of ',(0,t.jsx)(n.code,{children:"skipSelf"})," it cannot use the value for ",(0,t.jsx)(n.code,{children:"Service1"})," from its own registry, so it will not be able to resolve the specified dependency."]}),"\n",(0,t.jsxs)(n.p,{children:["And when creating a child injector, ",(0,t.jsx)(n.code,{children:"Service1"})," was not passed to it, but it can turn to the parent injector for it. Therefore, the child injector will successfully resolve the ",(0,t.jsx)(n.code,{children:"Service2"})," dependency."]}),"\n",(0,t.jsx)(n.h2,{id:"when-di-cant-find-the-right-provider",children:"When DI can't find the right provider"}),"\n",(0,t.jsx)(n.p,{children:"Remember that when DI cannot find the right provider, there are only three possible reasons:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["you did not transfer the required provider to DI in the metadata of the module or controller (well, or in the case of testing - in ",(0,t.jsx)(n.code,{children:"Injector.resolveAndCreate()"}),");"]}),"\n",(0,t.jsx)(n.li,{children:"you did not import the module where the provider you need is transferred, or this provider is not exported;"}),"\n",(0,t.jsx)(n.li,{children:"you are requesting a provider from the parent injector to the child injector."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>c});var t=r(6540);const s={},i=t.createContext(s);function o(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);