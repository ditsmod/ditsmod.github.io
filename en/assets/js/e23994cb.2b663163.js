"use strict";(self.webpackChunkditsmod_github_io=self.webpackChunkditsmod_github_io||[]).push([[638],{3437:(e,o,r)=>{r.r(o),r.d(o,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>t,metadata:()=>d,toc:()=>a});var n=r(4848),s=r(8453);const t={sidebar_position:3},i="Export, import, append",d={id:"developer-guides/exports-and-imports",title:"Export, import, append",description:"The module where you declare certain providers is called the host module for those providers. And when you use those providers in an external module, that external module is called the consumer module of those providers.",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/01-developer-guides/01-exports-and-imports.md",sourceDirName:"01-developer-guides",slug:"/developer-guides/exports-and-imports",permalink:"/en/developer-guides/exports-and-imports",draft:!1,unlisted:!1,editUrl:"https://github.com/ditsmod/ditsmod/edit/main/website/i18n/en/docusaurus-plugin-content-docs/current/01-developer-guides/01-exports-and-imports.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"ModuleManager",permalink:"/en/components-of-ditsmod-app/module-manager"},next:{title:"Collision of providers",permalink:"/en/developer-guides/providers-collisions"}},l={},a=[{value:"Export providers from non-root module",id:"export-providers-from-non-root-module",level:2},{value:"Export providers from the root module",id:"export-providers-from-the-root-module",level:2},{value:"Import module",id:"import-module",level:2},{value:"Import classes or class instances?",id:"import-classes-or-class-instances",level:3},{value:"Import and encapsulation",id:"import-and-encapsulation",level:3},{value:"Appending of the module",id:"appending-of-the-module",level:2},{value:"Re-export of the module",id:"re-export-of-the-module",level:2}];function c(e){const o={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(o.h1,{id:"export-import-append",children:"Export, import, append"}),"\n",(0,n.jsxs)(o.p,{children:["The module where you declare certain providers is called the ",(0,n.jsx)(o.strong,{children:"host module"})," for those providers. And when you use those providers in an external module, that external module is called the ",(0,n.jsx)(o.strong,{children:"consumer module"})," of those providers."]}),"\n",(0,n.jsx)(o.h2,{id:"export-providers-from-non-root-module",children:"Export providers from non-root module"}),"\n",(0,n.jsxs)(o.p,{children:["From the host module, you can export only classes or tokens of providers that are ",(0,n.jsx)(o.a,{href:"/components-of-ditsmod-app/dependency-injection/#providers",children:"declared in the form of an object"}),". That is, you cannot directly export providers in the form of an object:"]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",metastring:"{8}",children:"import { featureModule } from '@ditsmod/core';\n\nimport { FirstService } from './first.service.js';\nimport { SecondService } from './second.service.js';\n\n@featureModule({\n  providersPerMod: [FirstService, { token: SecondService, useClass: SecondService }],\n  exports: [SecondService],\n})\nexport class SomeModule {}\n"})}),"\n",(0,n.jsx)(o.p,{children:"In addition, you can export providers only those that are transferred to the following arrays:"}),"\n",(0,n.jsxs)(o.ul,{children:["\n",(0,n.jsxs)(o.li,{children:[(0,n.jsx)(o.code,{children:"providersPerMod"}),";"]}),"\n",(0,n.jsxs)(o.li,{children:[(0,n.jsx)(o.code,{children:"providersPerRou"}),";"]}),"\n",(0,n.jsxs)(o.li,{children:[(0,n.jsx)(o.code,{children:"providersPerReq"}),"."]}),"\n"]}),"\n",(0,n.jsxs)(o.p,{children:["It makes no sense to export the providers that are passed to ",(0,n.jsx)(o.code,{children:"providersPerApp"}),", since this array will be used to form the ",(0,n.jsx)(o.a,{href:"/components-of-ditsmod-app/dependency-injection#injector",children:"injector"})," at the application level. That is, the providers from the ",(0,n.jsx)(o.code,{children:"providersPerApp"})," array will be available for any module, at any level, and without exporting."]}),"\n",(0,n.jsxs)(o.p,{children:["Also keep in mind that only those services that will be directly used in the consumer modules need to be exported from the host module. In the example above, ",(0,n.jsx)(o.code,{children:"SecondService"})," can depend on ",(0,n.jsx)(o.code,{children:"FirstService"}),", but ",(0,n.jsx)(o.code,{children:"FirstService"})," does not need to be exported if it is not directly used in the consumer module. This ensures module encapsulation."]}),"\n",(0,n.jsx)(o.p,{children:"Exporting controllers does not make sense, since exporting only applies to providers."}),"\n",(0,n.jsx)(o.h2,{id:"export-providers-from-the-root-module",children:"Export providers from the root module"}),"\n",(0,n.jsx)(o.p,{children:"Exporting providers from the root module means that these providers will automatically be added to every module in the application:"}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",metastring:"{9}",children:"import { rootModule } from '@ditsmod/core';\n\nimport { SomeService } from './some.service.js';\nimport { OtherModule } from './other.module.js';\n\n@rootModule({\n  imports: [OtherModule],\n  providersPerRou: [SomeService],\n  exports: [SomeService, OtherModule],\n})\nexport class AppModule {}\n"})}),"\n",(0,n.jsxs)(o.p,{children:["In this case, ",(0,n.jsx)(o.code,{children:"SomeService"})," will be added to absolutely all application modules at the route level. As you can see, you can also export entire modules. In this case, all providers exported from ",(0,n.jsx)(o.code,{children:"OtherModule"})," will also be added to each application module."]}),"\n",(0,n.jsx)(o.h2,{id:"import-module",children:"Import module"}),"\n",(0,n.jsxs)(o.p,{children:["You cannot import a single provider into a Ditsmod module, but you can import an entire module with all the providers and ",(0,n.jsx)(o.a,{href:"/components-of-ditsmod-app/extensions",children:"extensions"})," exported in it:"]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",metastring:"{7}",children:"import { featureModule } from '@ditsmod/core';\n\nimport { FirstModule } from './first.module.js';\n\n@featureModule({\n  imports: [\n    FirstModule\n  ]\n})\nexport class SecondModule {}\n"})}),"\n",(0,n.jsxs)(o.p,{children:["For example, if ",(0,n.jsx)(o.code,{children:"SomeService"})," is exported in the ",(0,n.jsx)(o.code,{children:"FirstModule"}),", then this service can now be used in the ",(0,n.jsx)(o.code,{children:"SecondModule"})," in services and controllers. However, if ",(0,n.jsx)(o.code,{children:"FirstModule"})," has controllers, they will be ignored in this import form. For Ditsmod to take into account controllers from an imported module, the module must be imported with a prefix passed in ",(0,n.jsx)(o.code,{children:"path"}),":"]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",metastring:"{4}",children:"// ...\n@featureModule({\n  imports: [\n    { path: '', module: FirstModule }\n  ]\n})\nexport class SecondModule {}\n"})}),"\n",(0,n.jsxs)(o.p,{children:["Although ",(0,n.jsx)(o.code,{children:"path"})," is an empty string here, for Ditsmod, the presence of ",(0,n.jsx)(o.code,{children:"path"})," means:"]}),"\n",(0,n.jsxs)(o.ol,{children:["\n",(0,n.jsx)(o.li,{children:"to consider controllers from the imported module as well;"}),"\n",(0,n.jsxs)(o.li,{children:["to use ",(0,n.jsx)(o.code,{children:"path"})," as a prefix for all controllers imported from ",(0,n.jsx)(o.code,{children:"FirstModule"}),"."]}),"\n"]}),"\n",(0,n.jsx)(o.p,{children:"As you can see, in the previous example, this time neither the provider nor the module is imported, but the object. This object has the following interface:"}),"\n",(0,n.jsx)("a",{id:"ModuleWithParams"}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"interface ModuleWithParams<M extends AnyObj = AnyObj, E extends AnyObj = AnyObj> {\n  id?: string;\n  module: ModuleType<M>;\n  path?: string;\n  guards?: GuardItem[];\n  /**\n   * List of modules, `ModuleWithParams` or tokens of providers exported by this\n   * module.\n   */\n  exports?: any[];\n  providersPerApp?: Provider[];\n  providersPerMod?: Provider[];\n  providersPerRou?: Provider[];\n  providersPerReq?: Provider[];\n  /**\n   * This property allows you to pass any information to extensions.\n   *\n   * You must follow this rule: data for one extension - one key in `extensionsMeta` object.\n   */\n  extensionsMeta?: E;\n}\n"})}),"\n",(0,n.jsxs)(o.p,{children:["Note that only the ",(0,n.jsx)(o.code,{children:"module"})," property is required in this interface."]}),"\n",(0,n.jsx)(o.p,{children:"To reduce the length of the code when importing an object of this type, it is sometimes advisable to write a static method in the importing module. To see this clearly, let's take the previous example again:"}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",metastring:"{4}",children:"// ...\n@featureModule({\n  imports: [\n    { path: '', module: FirstModule }\n  ]\n})\nexport class SecondModule {}\n"})}),"\n",(0,n.jsxs)(o.p,{children:["If you wrote ",(0,n.jsx)(o.code,{children:"FirstModule"})," and knew that this module would make sense to be imported many times into different modules with different prefixes, then in this case you could write a static method in this class that returns an object specially designed for import:"]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"// ...\nexport class FirstModule {\n  static withPrefix(path: string) {\n    return {\n      module: this,\n      path\n    }\n  }\n}\n"})}),"\n",(0,n.jsx)(o.p,{children:"Now the object returned by this method can be imported as follows:"}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",metastring:"{4}",children:"// ...\n@featureModule({\n  imports: [\n    FirstModule.withPrefix('some-prefix')\n  ]\n})\nexport class SecondModule {}\n"})}),"\n",(0,n.jsx)(o.p,{children:"In this case, the reduction of the code almost did not occur compared to the previous example, when we imported the object directly, and the readability also worsened. So when writing static import methods, consider whether they simplify the code."}),"\n",(0,n.jsxs)(o.p,{children:["In order for TypeScript to control exactly what the static import method returns, it is recommended to use the ",(0,n.jsx)(o.code,{children:"ModuleWithParams"})," interface:"]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"import { ModuleWithParams } from '@ditsmod/core';\n// ...\nexport class SomeModule {\n  static withParams(someParams: SomeParams): ModuleWithParams<SomeModule> {\n    return {\n      module: this,\n      // ...\n    }\n  }\n}\n"})}),"\n",(0,n.jsx)(o.h3,{id:"import-classes-or-class-instances",children:"Import classes or class instances?"}),"\n",(0,n.jsx)(o.p,{children:"Let's consider a specific situation. In the following example, each provider is a class. Note what arrays these providers are passed to and what exactly is exported."}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"// ...\n@featureModule({\n  providersPerMod: [Provider1],\n  providersPerRou: [Provider2],\n  providersPerReq: [Provider3],\n  exports: [Provider1, Provider2, Provider3],\n})\nexport class Module1 {}\n"})}),"\n",(0,n.jsxs)(o.p,{children:["Suppose we import this module into ",(0,n.jsx)(o.code,{children:"Module2"}),", which has no providers of its own:"]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"// ...\n@featureModule({\n  imports: [Module1]\n  // ...\n})\nexport class Module2 {}\n"})}),"\n",(0,n.jsxs)(o.p,{children:["As a result of this import, ",(0,n.jsx)(o.code,{children:"Module2"})," will now have three providers at the same levels as declared in ",(0,n.jsx)(o.code,{children:"Module1"}),". When working with these providers, their instances are created separately in both modules. A ",(0,n.jsx)(o.a,{href:"https://en.wikipedia.org/wiki/Singleton_pattern",children:"singleton"})," can only be shared between modules if its provider is declared at the application level. In our example, providers are declared at the module, route, and request levels, so ",(0,n.jsx)(o.code,{children:"Module1"})," and ",(0,n.jsx)(o.code,{children:"Module2"})," will not share class instances at any level."]}),"\n",(0,n.jsx)(o.p,{children:"So it can be argued that classes are imported, not their instances."}),"\n",(0,n.jsx)(o.h3,{id:"import-and-encapsulation",children:"Import and encapsulation"}),"\n",(0,n.jsxs)(o.p,{children:["Let's consider a situation where only ",(0,n.jsx)(o.code,{children:"Provider3"})," is exported from ",(0,n.jsx)(o.code,{children:"Module1"}),", since only this provider is directly used in external modules:"]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"// ...\n@featureModule({\n  providersPerMod: [Provider1],\n  providersPerRou: [Provider2],\n  providersPerReq: [Provider3],\n  exports: [Provider3],\n})\nexport class Module1 {}\n"})}),"\n",(0,n.jsxs)(o.p,{children:["Suppose ",(0,n.jsx)(o.code,{children:"Provider3"})," has a dependency on ",(0,n.jsx)(o.code,{children:"Provider1"})," and ",(0,n.jsx)(o.code,{children:"Provider2"}),". What will Ditsmod do when importing this module into other modules? Ditsmod will import all three providers, since ",(0,n.jsx)(o.code,{children:"Provider3"})," depends on the other two providers."]}),"\n",(0,n.jsx)(o.h2,{id:"appending-of-the-module",children:"Appending of the module"}),"\n",(0,n.jsxs)(o.p,{children:["If you don't need to import providers and ",(0,n.jsx)(o.a,{href:"/components-of-ditsmod-app/extensions",children:"extensions"})," into the current module, but just append the external module to the prefix of the current module, you can use the ",(0,n.jsx)(o.code,{children:"appends"})," array:"]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",metastring:"{6}",children:"import { featureModule } from '@ditsmod/core';\n\nimport { FirstModule } from './first.module.js';\n\n@featureModule({\n  appends: [FirstModule]\n})\nexport class SecondModule {}\n"})}),"\n",(0,n.jsxs)(o.p,{children:["In this case, if ",(0,n.jsx)(o.code,{children:"SecondModule"})," has a prefix, it will be used as a prefix for all routes contained in ",(0,n.jsx)(o.code,{children:"FirstModule"}),". Only those modules with controllers can be appending."]}),"\n",(0,n.jsxs)(o.p,{children:["You can also attach an additional prefix to ",(0,n.jsx)(o.code,{children:"FirstModule"}),":"]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",metastring:"{3}",children:"// ...\n@featureModule({\n  appends: [{ path: 'some-path', module: FirstModule }]\n})\nexport class SecondModule {}\n"})}),"\n",(0,n.jsx)(o.p,{children:"In this example, an object was used, in which the module is passed for appending, it has the following interface:"}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"interface AppendsWithParams<T extends AnyObj = AnyObj> {\n  id?: string;\n  path: string;\n  module: ModuleType<T>;\n  guards?: GuardItem[];\n}\n"})}),"\n",(0,n.jsx)(o.h2,{id:"re-export-of-the-module",children:"Re-export of the module"}),"\n",(0,n.jsx)(o.p,{children:"In addition to importing a specific module, the same module can be simultaneously exported:"}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"import { featureModule } from '@ditsmod/core';\n\nimport { FirstModule } from './first.module.js';\n\n@featureModule({\n  imports: [FirstModule],\n  exports: [FirstModule],\n})\nexport class SecondModule {}\n"})}),"\n",(0,n.jsxs)(o.p,{children:["What is the meaning of this? - Now if you import ",(0,n.jsx)(o.code,{children:"SecondModule"})," into some other module, you will actually have ",(0,n.jsx)(o.code,{children:"FirstModule"})," imported as well."]}),"\n",(0,n.jsxs)(o.p,{children:["Pay attention! If during re-export you import an object with ",(0,n.jsx)(o.code,{children:"ModuleWithParams"})," interface, the same object must also be exported:"]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ts",children:"import { featureModule, ModuleWithParams } from '@ditsmod/core';\n\nimport { FirstModule } from './first.module.js';\n\nconst firstModuleWithParams: ModuleWithParams = { path: 'some-path', module: FirstModule };\n\n@featureModule({\n  imports: [firstModuleWithParams],\n  exports: [firstModuleWithParams],\n})\nexport class SecondModule {}\n"})})]})}function p(e={}){const{wrapper:o}={...(0,s.R)(),...e.components};return o?(0,n.jsx)(o,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},8453:(e,o,r)=>{r.d(o,{R:()=>i,x:()=>d});var n=r(6540);const s={},t=n.createContext(s);function i(e){const o=n.useContext(t);return n.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function d(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),n.createElement(t.Provider,{value:o},e.children)}}}]);