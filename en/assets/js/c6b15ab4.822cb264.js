"use strict";(self.webpackChunkditsmod_github_io=self.webpackChunkditsmod_github_io||[]).push([[307],{3697:(e,o,r)=>{r.r(o),r.d(o,{assets:()=>l,contentTitle:()=>d,default:()=>a,frontMatter:()=>n,metadata:()=>s,toc:()=>c});var i=r(4848),t=r(5680);const n={sidebar_position:9},d="Collision of providers",s={id:"developer-guides/providers-collisions",title:"Collision of providers",description:"Imagine you have Module3 where you imported Module2 and Module1. You did this import because you need Service2 and Service1 from these modules, respectively. You are viewing how these services work, but for some reason Service1 does not work as expected. You start debug and it turns out that Service1 exports both modules: Module2 and Module1. You expected that Service1 would only be exported from Module1, but the version exported from Module2 actually worked.",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/01-developer-guides/09-providers-collisions.md",sourceDirName:"01-developer-guides",slug:"/developer-guides/providers-collisions",permalink:"/en/developer-guides/providers-collisions",draft:!1,unlisted:!1,editUrl:"https://github.com/ditsmod/ditsmod/edit/main/website/i18n/en/docusaurus-plugin-content-docs/current/01-developer-guides/09-providers-collisions.md",tags:[],version:"current",sidebarPosition:9,frontMatter:{sidebar_position:9},sidebar:"tutorialSidebar",previous:{title:"Export, import, append",permalink:"/en/developer-guides/exports-and-imports"},next:{title:"Ditsmod coding style guide",permalink:"/en/developer-guides/conventions"}},l={},c=[{value:"Collision resolution",id:"collision-resolution",level:2}];function u(e){const o={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",...(0,t.RP)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(o.h1,{id:"collision-of-providers",children:"Collision of providers"}),"\n",(0,i.jsxs)(o.p,{children:["Imagine you have ",(0,i.jsx)(o.code,{children:"Module3"})," where you imported ",(0,i.jsx)(o.code,{children:"Module2"})," and ",(0,i.jsx)(o.code,{children:"Module1"}),". You did this import because you need ",(0,i.jsx)(o.code,{children:"Service2"})," and ",(0,i.jsx)(o.code,{children:"Service1"})," from these modules, respectively. You are viewing how these services work, but for some reason ",(0,i.jsx)(o.code,{children:"Service1"})," does not work as expected. You start debug and it turns out that ",(0,i.jsx)(o.code,{children:"Service1"})," exports both modules: ",(0,i.jsx)(o.code,{children:"Module2"})," and ",(0,i.jsx)(o.code,{children:"Module1"}),". You expected that ",(0,i.jsx)(o.code,{children:"Service1"})," would only be exported from ",(0,i.jsx)(o.code,{children:"Module1"}),", but the version exported from ",(0,i.jsx)(o.code,{children:"Module2"})," actually worked."]}),"\n",(0,i.jsx)(o.p,{children:"To prevent this from happening, if you import two or more modules that export non-identical providers with the same token, Ditsmod will throw the following error:"}),"\n",(0,i.jsxs)(o.blockquote,{children:["\n",(0,i.jsx)(o.p,{children:"Error: Importing providers to Module3 failed: exports from Module2 and Module1 causes collision with Service1. If Module3 declared in your application (it is not imported from node_modules), you should add Service1 to resolvedCollisionsPer* in this module. For example: resolvedCollisionsPerReq: [ [Service1, Module1] ]."}),"\n"]}),"\n",(0,i.jsx)(o.p,{children:"Specifically in this case:"}),"\n",(0,i.jsxs)(o.ol,{children:["\n",(0,i.jsxs)(o.li,{children:[(0,i.jsx)(o.code,{children:"Module1"})," substitute and then exports the provider with the token ",(0,i.jsx)(o.code,{children:"Service1"}),";"]}),"\n",(0,i.jsxs)(o.li,{children:["and ",(0,i.jsx)(o.code,{children:"Module2"})," substitute and then exports the provider with the token ",(0,i.jsx)(o.code,{children:"Service1"}),";"]}),"\n",(0,i.jsxs)(o.li,{children:["providers with token ",(0,i.jsx)(o.code,{children:"Service1"})," are not identical in ",(0,i.jsx)(o.code,{children:"Module1"})," and ",(0,i.jsx)(o.code,{children:"Module2"}),", i.e. from ",(0,i.jsx)(o.code,{children:"Module2"})," can be exported, for example, object ",(0,i.jsx)(o.code,{children:"{ token: Service1, useValue: {} }"}),", and from ",(0,i.jsx)(o.code,{children:"Module1"})," ",(0,i.jsx)(o.code,{children:"Service1"})," can be exported as a class."]}),"\n"]}),"\n",(0,i.jsxs)(o.p,{children:["And since both of these modules are imported into ",(0,i.jsx)(o.code,{children:"Module3"}),', this causes a "provider collisions", because the developer may not know which of these substitutions will work in ',(0,i.jsx)(o.code,{children:"Module3"}),"."]}),"\n",(0,i.jsx)(o.h2,{id:"collision-resolution",children:"Collision resolution"}),"\n",(0,i.jsxs)(o.p,{children:["If ",(0,i.jsx)(o.code,{children:"Module3"})," is declared in your application (it is not imported from ",(0,i.jsx)(o.code,{children:"node_modules"}),"), the collision is resolved by adding to ",(0,i.jsx)(o.code,{children:"resolvedCollisionsPer*"})," an array of two elements, with the provider's token in the first place and the module from which the provider needs to be taken in the second place:"]}),"\n",(0,i.jsx)(o.pre,{children:(0,i.jsx)(o.code,{className:"language-ts",metastring:"{6}",children:"import { Module1, Service1 } from './module1.js';\nimport { Module2 } from './module2.js';\n\n@featureModule({\n  imports: [Module2, Module1],\n  resolvedCollisionsPerReq: [ [Service1, Module1] ]\n})\nexport class Module3 {}\n"})}),"\n",(0,i.jsxs)(o.p,{children:["If you have installed ",(0,i.jsx)(o.code,{children:"Module3"})," using packages manager (npm, yarn, etc.), there is no point in modifying this module locally to resolve the collision. This situation can only occur if ",(0,i.jsx)(o.code,{children:"Module2"})," and ",(0,i.jsx)(o.code,{children:"Module1"})," are exported from the root module, so you need to remove one of these modules from there. And, of course, after that you will have to explicitly import the deleted module into those modules where it is needed."]})]})}function a(e={}){const{wrapper:o}={...(0,t.RP)(),...e.components};return o?(0,i.jsx)(o,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},5680:(e,o,r)=>{r.d(o,{RP:()=>c});var i=r(6540);function t(e,o,r){return o in e?Object.defineProperty(e,o,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[o]=r,e}function n(e,o){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);o&&(i=i.filter((function(o){return Object.getOwnPropertyDescriptor(e,o).enumerable}))),r.push.apply(r,i)}return r}function d(e){for(var o=1;o<arguments.length;o++){var r=null!=arguments[o]?arguments[o]:{};o%2?n(Object(r),!0).forEach((function(o){t(e,o,r[o])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):n(Object(r)).forEach((function(o){Object.defineProperty(e,o,Object.getOwnPropertyDescriptor(r,o))}))}return e}function s(e,o){if(null==e)return{};var r,i,t=function(e,o){if(null==e)return{};var r,i,t={},n=Object.keys(e);for(i=0;i<n.length;i++)r=n[i],o.indexOf(r)>=0||(t[r]=e[r]);return t}(e,o);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(i=0;i<n.length;i++)r=n[i],o.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(t[r]=e[r])}return t}var l=i.createContext({}),c=function(e){var o=i.useContext(l),r=o;return e&&(r="function"==typeof e?e(o):d(d({},o),e)),r},u={inlineCode:"code",wrapper:function(e){var o=e.children;return i.createElement(i.Fragment,{},o)}},a=i.forwardRef((function(e,o){var r=e.components,t=e.mdxType,n=e.originalType,l=e.parentName,a=s(e,["components","mdxType","originalType","parentName"]),p=c(r),h=t,m=p["".concat(l,".").concat(h)]||p[h]||u[h]||n;return r?i.createElement(m,d(d({ref:o},a),{},{components:r})):i.createElement(m,d({ref:o},a))}));a.displayName="MDXCreateElement"}}]);