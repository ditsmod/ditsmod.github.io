"use strict";(self.webpackChunkditsmod_github_io=self.webpackChunkditsmod_github_io||[]).push([[962],{3905:(e,t,r)=>{r.d(t,{Zo:()=>c,kt:()=>m});var n=r(7294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var l=n.createContext({}),p=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},c=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=p(r),h=o,m=d["".concat(l,".").concat(h)]||d[h]||u[h]||a;return r?n.createElement(m,i(i({ref:t},c),{},{components:r})):n.createElement(m,i({ref:t},c))}));function m(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=r.length,i=new Array(a);i[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:o,i[1]=s;for(var p=2;p<a;p++)i[p]=r[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}h.displayName="MDXCreateElement"},9165:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>p});var n=r(7462),o=(r(7294),r(3905));const a={sidebar_position:4},i="HTTP Interceptors",s={unversionedId:"components-of-ditsmod-app/http-interceptors",id:"components-of-ditsmod-app/http-interceptors",title:"HTTP Interceptors",description:"The interceptors are very similar in functionality to controllers, but they do not create routes, they are attached to existing routes. Multiple interceptors can work on a single route, launching one after another. Interceptors are analogous to middleware in ExpressJS, but interceptors can use DI. Additionally, interceptors can work before and after the controller's operation.",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/00-components-of-ditsmod-app/04-http-interceptors.md",sourceDirName:"00-components-of-ditsmod-app",slug:"/components-of-ditsmod-app/http-interceptors",permalink:"/en/components-of-ditsmod-app/http-interceptors",draft:!1,editUrl:"https://github.com/ditsmod/ditsmod/edit/main/website/i18n/en/docusaurus-plugin-content-docs/current/00-components-of-ditsmod-app/04-http-interceptors.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Dependency Injection",permalink:"/en/components-of-ditsmod-app/dependency-injection"},next:{title:"Guards",permalink:"/en/components-of-ditsmod-app/guards"}},l={},p=[{value:"HTTP request processing scheme",id:"http-request-processing-scheme",level:2},{value:"Non-singletons",id:"non-singletons",level:3},{value:"Singleton",id:"singleton",level:3},{value:"Creating an interceptor",id:"creating-an-interceptor",level:2},{value:"Passing interceptor to the injector",id:"passing-interceptor-to-the-injector",level:2}],c={toc:p},d="wrapper";function u(e){let{components:t,...r}=e;return(0,o.kt)(d,(0,n.Z)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"http-interceptors"},"HTTP Interceptors"),(0,o.kt)("p",null,"The interceptors are very similar in functionality to controllers, but they do not create routes, they are attached to existing routes. Multiple interceptors can work on a single route, launching one after another. Interceptors are analogous to ",(0,o.kt)("a",{parentName:"p",href:"https://expressjs.com/en/guide/writing-middleware.html"},"middleware in ExpressJS"),", but interceptors can use ",(0,o.kt)("a",{parentName:"p",href:"/components-of-ditsmod-app/dependency-injection"},"DI"),". Additionally, interceptors can work before and after the controller's operation. "),(0,o.kt)("p",null,"Given that interceptors do the same job that controllers can do, you can work without interceptors. But in this case, you will have to call various services in the controllers much more often."),(0,o.kt)("p",null,"Typically, interceptors are used to automate standard processing, such as:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"parsing the body of the request or headers;"),(0,o.kt)("li",{parentName:"ul"},"validation of the request;"),(0,o.kt)("li",{parentName:"ul"},"collecting and logging various application metrics;"),(0,o.kt)("li",{parentName:"ul"},"caching;"),(0,o.kt)("li",{parentName:"ul"},"etc.")),(0,o.kt)("p",null,"Interceptors can be centrally connected or disconnected without changing the method code of the controllers to which they are attached. Like controllers, interceptors can be ",(0,o.kt)("a",{parentName:"p",href:"/components-of-ditsmod-app/controllers-and-services/#what-is-a-controller"},"singletons")," or non-singletons. Unlike singletons, non-singletons have access to the request-level injector, so they can invoke request-level services. On the other hand, singletons are created at the route level - services are available to them at the route, module, or application level."),(0,o.kt)("h2",{id:"http-request-processing-scheme"},"HTTP request processing scheme"),(0,o.kt)("h3",{id:"non-singletons"},"Non-singletons"),(0,o.kt)("p",null,"HTTP request processing has the following workflow:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Ditsmod creates an instance of ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/ditsmod/ditsmod/blob/core-2.50.0/packages/core/src/services/pre-router.ts"},"PreRouter")," at the application level."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"PreRouter")," uses the router to search for the request handler according to the URI."),(0,o.kt)("li",{parentName:"ol"},"If the request handler is not found, ",(0,o.kt)("inlineCode",{parentName:"li"},"PreRouter")," issues a 501 error."),(0,o.kt)("li",{parentName:"ol"},"If a request handler is found, Ditsmod creates a provider instance with the ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/ditsmod/ditsmod/blob/core-2.50.0/packages/core/src/services/default-http-frontend.ts"},"HttpFrontend")," token at the request level, places it first in the queue of interceptors, and automatically calls it. By default, this interceptor is responsible for setting values for providers with ",(0,o.kt)("inlineCode",{parentName:"li"},"QUERY_PARAMS")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"PATH_PARAMS")," tokens."),(0,o.kt)("li",{parentName:"ol"},"If there are guards in the current route, they are started by default immediately after ",(0,o.kt)("inlineCode",{parentName:"li"},"HttpFrontend"),"."),(0,o.kt)("li",{parentName:"ol"},"Other interceptors may be launched next, depending on whether the previous interceptor in the queue will launch them."),(0,o.kt)("li",{parentName:"ol"},"If all interceptors have worked, Ditsmod starts ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/ditsmod/ditsmod/blob/core-2.50.0/packages/core/src/services/default-http-backend.ts"},"HttpBackend"),", which is instantiated at the request level. By default, ",(0,o.kt)("inlineCode",{parentName:"li"},"HttpBackend")," runs directly the controller method responsible for processing the current request.")),(0,o.kt)("p",null,"So, the approximate order of processing the request is as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"}," request -> PreRouter -> HttpFrontend -> guards -> [other interceptors] -> HttpBackend -> controller\nresponse <- PreRouter <- HttpFrontend <- guards <- [other interceptors] <- HttpBackend <- controller\n")),(0,o.kt)("p",null,"As ",(0,o.kt)("inlineCode",{parentName:"p"},"PreRouter"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"HttpFrontend"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"HttpBackend")," instances are created using DI, you can replace them with your own version of the respective classes. For example, if you don't just want to send a 501 status when the required route is missing, but also want to add some text or change headers, you can substitute ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/ditsmod/ditsmod/blob/core-2.50.0/packages/core/src/services/pre-router.ts"},"PreRouter")," with your own class."),(0,o.kt)("p",null,"Each call to the interceptor returns ",(0,o.kt)("inlineCode",{parentName:"p"},"Promise<any>"),", and it eventually leads to a controller method tied to the corresponding route. This means that in the interceptor you can listen for the result of promise resolve, which returns the method of the controller. However, at the moment (Ditsmod v2.0.0), ",(0,o.kt)("inlineCode",{parentName:"p"},"HttpFrontend")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"HttpBackend")," by default ignores everything that returns the controller or interceptors, so listening to the resolution of a promise can be useful only for collecting metrics."),(0,o.kt)("p",null,"On the other hand, with DI you can easily replace ",(0,o.kt)("inlineCode",{parentName:"p"},"HttpFrontend")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"HttpBackend")," with your own interceptors to take into account the return value of the controller method. One of the variants of this functionality is implemented in the ",(0,o.kt)("a",{parentName:"p",href:"/native-modules/return"},"@ditsmod/return")," module."),(0,o.kt)("h3",{id:"singleton"},"Singleton"),(0,o.kt)("p",null,"A singleton interceptor works very similarly to a non-singleton interceptor, except that it does not use an injector at the request level. The workflow with his participation differs in points 4 and 7, because a single interceptor instance is created at the route level:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Ditsmod creates an instance of ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/ditsmod/ditsmod/blob/core-2.50.0/packages/core/src/services/pre-router.ts"},"PreRouter")," at the application level."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"PreRouter")," uses the router to search for the request handler according to the URI."),(0,o.kt)("li",{parentName:"ol"},"If the request handler is not found, ",(0,o.kt)("inlineCode",{parentName:"li"},"PreRouter")," issues a 501 error."),(0,o.kt)("li",{parentName:"ol"},"If a request handler is found, Ditsmod uses a provider instance with the ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/ditsmod/ditsmod/blob/core-2.50.0/packages/core/src/services/default-http-frontend.ts"},"HttpFrontend")," token at the route level, places it first in the interceptor queue, and automatically invokes it. By default, this interceptor is responsible for setting ",(0,o.kt)("inlineCode",{parentName:"li"},"pathParams")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"queryParams")," values for ",(0,o.kt)("inlineCode",{parentName:"li"},"SingletonRequestContext"),"."),(0,o.kt)("li",{parentName:"ol"},"If there are guards in the current route, they are started by default immediately after ",(0,o.kt)("inlineCode",{parentName:"li"},"HttpFrontend"),"."),(0,o.kt)("li",{parentName:"ol"},"Other interceptors may be launched next, depending on whether the previous interceptor in the queue will launch them."),(0,o.kt)("li",{parentName:"ol"},"If all interceptors have worked, Ditsmod starts ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/ditsmod/ditsmod/blob/core-2.50.0/packages/core/src/services/default-http-backend.ts"},"HttpBackend"),", the instance of which is used at the route level. By default, ",(0,o.kt)("inlineCode",{parentName:"li"},"HttpBackend")," runs directly the controller method responsible for processing the current request.")),(0,o.kt)("h2",{id:"creating-an-interceptor"},"Creating an interceptor"),(0,o.kt)("p",null,"Each interceptor should be a class implementing the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/ditsmod/ditsmod/blob/core-2.50.0/packages/core/src/types/http-interceptor.ts#L38-L40"},"HttpInterceptor")," interface and annotated with the ",(0,o.kt)("inlineCode",{parentName:"p"},"injectable")," decorator:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { injectable, RequestContext, HttpHandler, HttpInterceptor } from '@ditsmod/core';\n\n@injectable()\nexport class MyHttpInterceptor implements HttpInterceptor {\n  intercept(next: HttpHandler, ctx: RequestContext) {\n    return next.handle(); // Here returns Promise<any>;\n  }\n}\n")),(0,o.kt)("p",null,"As you can see, the ",(0,o.kt)("inlineCode",{parentName:"p"},"intercept()")," method has two parameters: the first is the handler instance that calls the next interceptor, and the second is ",(0,o.kt)("inlineCode",{parentName:"p"},"RequestContext")," (native Node.js request and response objects). If the interceptor needs additional data for its work, it can be obtained in the constructor through DI, as in any service."),(0,o.kt)("h2",{id:"passing-interceptor-to-the-injector"},"Passing interceptor to the injector"),(0,o.kt)("p",null,"The non-singleton interceptor is passed to the injector at the request level using ",(0,o.kt)("a",{parentName:"p",href:"/components-of-ditsmod-app/dependency-injection#multi-providers"},"multi-providers")," with the ",(0,o.kt)("inlineCode",{parentName:"p"},"HTTP_INTERCEPTORS")," token:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { HTTP_INTERCEPTORS, featureModule } from '@ditsmod/core';\nimport { MyHttpInterceptor } from './my-http-interceptor.js';\n\n@featureModule({\n  // ...\n  providersPerReq: [{ token: HTTP_INTERCEPTORS, useClass: MyHttpInterceptor, multi: true }],\n})\nexport class SomeModule {}\n")),(0,o.kt)("p",null,"Transmission of a singleton interceptor occurs in exactly the same way, but at the route, module, or application level:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { HTTP_INTERCEPTORS, featureModule } from '@ditsmod/core';\nimport { MyHttpInterceptor } from './my-http-interceptor.js';\n\n@featureModule({\n  // ...\n  providersPerApp: [{ token: HTTP_INTERCEPTORS, useClass: MyHttpInterceptor, multi: true }],\n})\nexport class SomeModule {}\n")),(0,o.kt)("p",null,"In this case, the interceptor is passed at the application level, but keep in mind that if you also pass interceptors at lower levels, this interceptor will be ignored. This is how ",(0,o.kt)("a",{parentName:"p",href:"/components-of-ditsmod-app/dependency-injection#multi-providers"},"multi-providers")," work."),(0,o.kt)("p",null,"In this case, the interceptors are passed in the module's metadata. They can also be passed in the controller metadata. This means that interceptors can either work for all controllers in the module without exception, or only for a specific controller. If you only need to add interceptors to individual routes within controllers, you can do so with ",(0,o.kt)("a",{parentName:"p",href:"/components-of-ditsmod-app/extensions"},"extensions")," (this is how ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/ditsmod/ditsmod/blob/body-parser-2.13.1/packages/body-parser/src/body-parser.extension.ts#L54"},"interceptors for parsing the request body")," are added)."))}u.isMDXComponent=!0}}]);