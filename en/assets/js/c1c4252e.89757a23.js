"use strict";(self.webpackChunkditsmod_github_io=self.webpackChunkditsmod_github_io||[]).push([[49],{5214:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"basic-components/decorators-and-reflector","title":"Decorators and Reflector","description":"decorators-and-reflector}","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/01-basic-components/00-decorators-and-reflector.md","sourceDirName":"01-basic-components","slug":"/basic-components/decorators-and-reflector","permalink":"/en/basic-components/decorators-and-reflector","draft":false,"unlisted":false,"editUrl":"https://github.com/ditsmod/ditsmod/edit/main/website/i18n/en/docusaurus-plugin-content-docs/current/01-basic-components/00-decorators-and-reflector.md","tags":[],"version":"current","sidebarPosition":0,"frontMatter":{"sidebar_position":0},"sidebar":"tutorialSidebar","previous":{"title":"What is Ditsmod","permalink":"/en/"},"next":{"title":"Dependency Injection","permalink":"/en/basic-components/dependency-injection"}}');var c=n(4848),i=n(8453);const r={sidebar_position:0},o="Decorators and Reflector {#decorators-and-reflector}",a={},d=[];function l(e){const t={a:"a",code:"code",h1:"h1",header:"header",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(t.header,{children:(0,c.jsx)(t.h1,{id:"decorators-and-reflector",children:"Decorators and Reflector"})}),"\n",(0,c.jsx)(t.p,{children:"Let's start with the obvious \u2014 TypeScript syntax differs slightly from JavaScript syntax because it provides static typing capabilities. During the compilation of TypeScript code into JavaScript, the compiler can emit additional JavaScript code that can be used to obtain information about the static types of class properties or the static types of parameters in class methods. In other words, when working with TypeScript code, you can first define static types in classes, and then, by using a special API, access information about these static types in the resulting JavaScript code. Decorators signal the TypeScript compiler to emit information about the static types of a class, while the reflector stores and provides access to this information."}),"\n",(0,c.jsx)(t.p,{children:"In addition to static TypeScript types, decorators also allow you to store additional metadata that can be passed to decorators at the class level, class properties, or method parameters."}),"\n",(0,c.jsx)(t.p,{children:"In Ditsmod, decorators and the reflector are fundamental components that are used constantly and allow the application to be described declaratively. That's why learning Ditsmod should start with this topic."}),"\n",(0,c.jsxs)(t.p,{children:["Let's try experimenting with preserving static class types. Create a file ",(0,c.jsx)(t.code,{children:"src/app/services.ts"})," in the ",(0,c.jsx)(t.a,{href:"../../#installation",children:"ditsmod/rest-starter"})," repository, and paste the following code into it:"]}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-ts",children:"class Service1 {}\n\nclass Service2 {\n  constructor(service1: Service1) {}\n}\n"})}),"\n",(0,c.jsxs)(t.p,{children:["As you can see, the constructor of ",(0,c.jsx)(t.code,{children:"Service2"})," specifies a static data type for the ",(0,c.jsx)(t.code,{children:"service1"})," parameter. This is a typical example for applications where one class depends on another, and this dependency is declared in the class constructor. Why is it called a dependency? \u2014 Because before creating an instance of ",(0,c.jsx)(t.code,{children:"Service2"}),", an instance of ",(0,c.jsx)(t.code,{children:"Service1"})," must be created first."]}),"\n",(0,c.jsx)(t.p,{children:"If you run the command:"}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-bash",children:"npm run build\n"})}),"\n",(0,c.jsxs)(t.p,{children:["TypeScript code will be compiled and placed into the ",(0,c.jsx)(t.code,{children:"dist/app/services.js"})," file. It will look like this:"]}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-ts",children:"class Service1 {\n}\nclass Service2 {\n    constructor(service1) { }\n}\n"})}),"\n",(0,c.jsxs)(t.p,{children:["That is, the information about the parameter type in the ",(0,c.jsx)(t.code,{children:"Service2"})," constructor is lost. This does not suit us, because in this case we will not be able to automatically (programmatically) find out that ",(0,c.jsx)(t.code,{children:"Service2"})," depends on ",(0,c.jsx)(t.code,{children:"Service1"}),". But if we use a class decorator, the TypeScript compiler will output more JavaScript code containing information about static typing. For example, let's use the ",(0,c.jsx)(t.code,{children:"injectable"})," decorator:"]}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-ts",metastring:"{1,5}",children:"import { injectable } from '@ditsmod/core';\n\nclass Service1 {}\n\n@injectable()\nclass Service2 {\n  constructor(service1: Service1) {}\n}\n"})}),"\n",(0,c.jsxs)(t.p,{children:["Now, using the ",(0,c.jsx)(t.code,{children:"npm run build"})," command, the TypeScript compiler converts this code into the following JavaScript code and inserts it into ",(0,c.jsx)(t.code,{children:"dist/app/services.js"}),":"]}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-js",metastring:"{18}",children:'var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);\n};\nimport { injectable } from \'@ditsmod/core\';\nclass Service1 {\n}\nlet Service2 = class Service2 {\n    constructor(service1) { }\n};\nService2 = __decorate([\n    injectable(),\n    __metadata("design:paramtypes", [Service1])\n], Service2);\n'})}),"\n",(0,c.jsxs)(t.p,{children:["Fortunately, you will rarely need to inspect the ",(0,c.jsx)(t.code,{children:"dist"})," folder and analyze compiled code, but it can sometimes be useful to glance at it for a general understanding of how static typing is transferred into JavaScript code. The most interesting part is found in the last four lines. It's clear that the TypeScript compiler now associates the array ",(0,c.jsx)(t.code,{children:"[Service1]"})," with ",(0,c.jsx)(t.code,{children:"Service2"}),". This array contains information about the static parameter types detected by the compiler in the ",(0,c.jsx)(t.code,{children:"Service2"})," constructor. It looks like we can now programmatically find out that ",(0,c.jsx)(t.code,{children:"Service2"})," depends on ",(0,c.jsx)(t.code,{children:"Service1"}),". The only thing left to do is find out what APIs Ditsmod provides to store and read this information."]}),"\n",(0,c.jsxs)(t.p,{children:["Further analysis of the compiled code shows that the ",(0,c.jsx)(t.code,{children:"Reflect"})," class is used to store metadata related to static typing. At the initial stage of learning Ditsmod, you don\u2019t need to dive deeply into how ",(0,c.jsx)(t.code,{children:"Reflect"})," works, because Ditsmod provides higher-level tools that simplify working with storing and using class metadata. At this point, it\u2019s enough to know that ",(0,c.jsx)(t.code,{children:"Reflect"})," is imported from the ",(0,c.jsx)(t.a,{href:"https://github.com/ditsmod/ditsmod/blob/core-2.54.0/packages/core/package.json#L53",children:"reflect-metadata"})," library, and the API of this library is then used by Ditsmod to read the metadata described above. This is handled by the so-called ",(0,c.jsx)(t.strong,{children:"reflector"}),"."]}),"\n",(0,c.jsxs)(t.p,{children:["Let's see what higher-level tools Ditsmod provides for working with the reflector. Let's make the previous example more complex to see how metadata can be extracted and how complex dependency chains can be formed. Consider three classes with the following dependency: ",(0,c.jsx)(t.code,{children:"Service3"})," -> ",(0,c.jsx)(t.code,{children:"Service2"})," -> ",(0,c.jsx)(t.code,{children:"Service1"}),". Insert the following code into ",(0,c.jsx)(t.code,{children:"src/app/services.ts"}),":"]}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-ts",metastring:"{15}",children:"import { injectable, getDependencies } from '@ditsmod/core';\n\nclass Service1 {}\n\n@injectable()\nclass Service2 {\n  constructor(service1: Service1) {}\n}\n\n@injectable()\nclass Service3 {\n  constructor(service2: Service2) {}\n}\n\nconsole.log(getDependencies(Service3)); // [ { token: [class Service2], required: true } ]\n"})}),"\n",(0,c.jsxs)(t.p,{children:["The ",(0,c.jsx)(t.code,{children:"getDependencies()"})," function uses the reflector and returns an array of direct dependencies of ",(0,c.jsx)(t.code,{children:"Service3"}),". You might guess that by passing ",(0,c.jsx)(t.code,{children:"Service2"})," to ",(0,c.jsx)(t.code,{children:"getDependencies()"}),", we'll see the dependency on ",(0,c.jsx)(t.code,{children:"Service1"}),". This way, you can ",(0,c.jsx)(t.strong,{children:"automatically"})," build the entire dependency chain ",(0,c.jsx)(t.code,{children:"Service3"})," -> ",(0,c.jsx)(t.code,{children:"Service2"})," -> ",(0,c.jsx)(t.code,{children:"Service1"}),'. This process in DI is called "dependency resolution". And here the word "automatically" is intentionally bolded because it is a very important feature supported by DI. Users only pass ',(0,c.jsx)(t.code,{children:"Service3"})," to DI, and they don't need to manually explore what this class depends on \u2014 DI can resolve the dependency automatically. By the way, users will rarely need to use the ",(0,c.jsx)(t.code,{children:"getDependencies()"})," function, except in a few rare cases."]}),"\n",(0,c.jsx)(t.p,{children:'Strictly speaking, the mechanism of storing and retrieving metadata from the reflector using decorators is not yet Dependency Injection. However, Dependency Injection extensively uses decorators and the reflector in its operation, so in this documentation, you might sometimes see that DI "obtains information about class dependencies" although in reality, it\'s the reflector that does this.'}),"\n",(0,c.jsx)(t.p,{children:"The code in the last example can be compiled and run with the following command:"}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-bash",children:"tput reset && npm run build && node dist/app/services.js\n"})}),"\n",(0,c.jsx)(t.p,{children:"To have the code automatically execute after every change, you can use two terminals. In the first terminal, you can run the command to compile the code:"}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-bash",children:"npm run build -- --watch\n"})}),"\n",(0,c.jsx)(t.p,{children:"And in the second terminal, you can run the command to execute the compiled code:"}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-bash",children:"node --watch dist/app/services.js\n"})}),"\n",(0,c.jsxs)(t.p,{children:["Now, if in ",(0,c.jsx)(t.code,{children:"src/app/services.ts"})," you pass ",(0,c.jsx)(t.code,{children:"Service2"})," to the ",(0,c.jsx)(t.code,{children:"getDependencies()"})," function, after a few seconds, you should see the output ",(0,c.jsx)(t.code,{children:"[ { token: [class Service1], required: true } ]"})," in the second terminal."]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,c.jsx)(t,{...e,children:(0,c.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var s=n(6540);const c={},i=s.createContext(c);function r(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:r(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);