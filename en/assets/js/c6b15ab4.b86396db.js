"use strict";(self.webpackChunkditsmod_github_io=self.webpackChunkditsmod_github_io||[]).push([[307],{9349:(e,o,r)=>{r.r(o),r.d(o,{assets:()=>l,contentTitle:()=>t,default:()=>a,frontMatter:()=>n,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"developer-guides/providers-collisions","title":"Provider Collisions","description":"Imagine you have Module3, where you import Module2 and Module1. You made these imports because you need Provider2 and Provider1 from these modules, respectively. You review the results of these providers\u2019 operations, but for some reason, Provider1 does not behave as expected. You start debugging and discover that Provider1 is exported from both Module2 and Module1. You expected Provider1 to be exported only from Module1, but in reality, the version exported by Module2 is being used:","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/01-developer-guides/09-providers-collisions.md","sourceDirName":"01-developer-guides","slug":"/developer-guides/providers-collisions","permalink":"/en/developer-guides/providers-collisions","draft":false,"unlisted":false,"editUrl":"https://github.com/ditsmod/ditsmod/edit/main/website/i18n/en/docusaurus-plugin-content-docs/current/01-developer-guides/09-providers-collisions.md","tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"sidebar_position":9},"sidebar":"tutorialSidebar","previous":{"title":"Export, import, append","permalink":"/en/developer-guides/exports-and-imports"},"next":{"title":"Ditsmod coding style guide","permalink":"/en/developer-guides/conventions"}}');var d=r(4848),s=r(8453);const n={sidebar_position:9},t="Provider Collisions",l={},c=[{value:"Collision resolution",id:"collision-resolution",level:2}];function u(e){const o={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(o.header,{children:(0,d.jsx)(o.h1,{id:"provider-collisions",children:"Provider Collisions"})}),"\n",(0,d.jsxs)(o.p,{children:["Imagine you have ",(0,d.jsx)(o.code,{children:"Module3"}),", where you import ",(0,d.jsx)(o.code,{children:"Module2"})," and ",(0,d.jsx)(o.code,{children:"Module1"}),". You made these imports because you need ",(0,d.jsx)(o.code,{children:"Provider2"})," and ",(0,d.jsx)(o.code,{children:"Provider1"})," from these modules, respectively. You review the results of these providers\u2019 operations, but for some reason, ",(0,d.jsx)(o.code,{children:"Provider1"})," does not behave as expected. You start debugging and discover that ",(0,d.jsx)(o.code,{children:"Provider1"})," is exported from both ",(0,d.jsx)(o.code,{children:"Module2"})," and ",(0,d.jsx)(o.code,{children:"Module1"}),". You expected ",(0,d.jsx)(o.code,{children:"Provider1"})," to be exported only from ",(0,d.jsx)(o.code,{children:"Module1"}),", but in reality, the version exported by ",(0,d.jsx)(o.code,{children:"Module2"})," is being used:"]}),"\n",(0,d.jsx)(o.pre,{children:(0,d.jsx)(o.code,{className:"language-ts",metastring:"{8,14}",children:"import { featureModule, rootModule } from '@ditsmod/core';\n\nclass Provider1 {}\nclass Provider2 {}\n\n@featureModule({\n  providersPerReq: [Provider1],\n  exports: [Provider1]\n})\nclass Module1 {}\n\n@featureModule({\n  providersPerReq: [{ token: Provider1, useValue: 'some value' }, Provider2],\n  exports: [Provider1, Provider2],\n})\nclass Module2 {}\n\n@rootModule({\n  imports: [Module1, Module2],\n})\nclass Module3 {}\n"})}),"\n",(0,d.jsx)(o.p,{children:"To prevent this, if you import two or more modules that export non-identical providers with the same token, Ditsmod will throw an error similar to this:"}),"\n",(0,d.jsxs)(o.blockquote,{children:["\n",(0,d.jsx)(o.p,{children:"Error: Importing providers to Module3 failed: exports from Module1, Module2 causes collision with Provider1. You should add Provider1 to resolvedCollisionsPerReq in this module. For example: resolvedCollisionsPerReq: [ [Provider1, Module1] ]."}),"\n"]}),"\n",(0,d.jsx)(o.p,{children:"In this specific scenario:"}),"\n",(0,d.jsxs)(o.ol,{children:["\n",(0,d.jsxs)(o.li,{children:[(0,d.jsx)(o.code,{children:"Module1"})," exports a provider with the token ",(0,d.jsx)(o.code,{children:"Provider1"}),"."]}),"\n",(0,d.jsxs)(o.li,{children:[(0,d.jsx)(o.code,{children:"Module2"})," overrides and then exports a provider with the token ",(0,d.jsx)(o.code,{children:"Provider1"}),"."]}),"\n",(0,d.jsxs)(o.li,{children:["The providers with the token ",(0,d.jsx)(o.code,{children:"Provider1"})," in ",(0,d.jsx)(o.code,{children:"Module1"})," and ",(0,d.jsx)(o.code,{children:"Module2"})," are not identical."]}),"\n"]}),"\n",(0,d.jsxs)(o.p,{children:["And because both of these modules are imported into ",(0,d.jsx)(o.code,{children:"Module3"}),', a "provider collision" occurs, leaving the developer uncertain about which provider will be used in ',(0,d.jsx)(o.code,{children:"Module3"}),"."]}),"\n",(0,d.jsx)(o.h2,{id:"collision-resolution",children:"Collision resolution"}),"\n",(0,d.jsxs)(o.p,{children:["If ",(0,d.jsx)(o.code,{children:"Module3"})," is declared in your application (it is not imported from ",(0,d.jsx)(o.code,{children:"node_modules"}),"), the collision is resolved by adding to ",(0,d.jsx)(o.code,{children:"resolvedCollisionsPer*"})," an array of two elements, with the provider's token in the first place and the module from which the provider needs to be taken in the second place:"]}),"\n",(0,d.jsx)(o.pre,{children:(0,d.jsx)(o.code,{className:"language-ts",metastring:"{6}",children:"import { Module1, Service1 } from './module1.js';\nimport { Module2 } from './module2.js';\n\n@featureModule({\n  imports: [Module2, Module1],\n  resolvedCollisionsPerReq: [ [Service1, Module1] ]\n})\nexport class Module3 {}\n"})}),"\n",(0,d.jsxs)(o.p,{children:["If you have installed ",(0,d.jsx)(o.code,{children:"Module3"})," using packages manager (npm, yarn, etc.), there is no point in modifying this module locally to resolve the collision. This situation can only occur if ",(0,d.jsx)(o.code,{children:"Module2"})," and ",(0,d.jsx)(o.code,{children:"Module1"})," are exported from the root module, so you need to remove one of these modules from there. And, of course, after that you will have to explicitly import the deleted module into those modules where it is needed."]})]})}function a(e={}){const{wrapper:o}={...(0,s.R)(),...e.components};return o?(0,d.jsx)(o,{...e,children:(0,d.jsx)(u,{...e})}):u(e)}},8453:(e,o,r)=>{r.d(o,{R:()=>n,x:()=>t});var i=r(6540);const d={},s=i.createContext(d);function n(e){const o=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function t(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(d):e.components||d:n(e.components),i.createElement(s.Provider,{value:o},e.children)}}}]);