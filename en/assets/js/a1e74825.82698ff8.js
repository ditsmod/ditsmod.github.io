"use strict";(self.webpackChunkditsmod_github_io=self.webpackChunkditsmod_github_io||[]).push([[90],{1329:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>c,toc:()=>d});const c=JSON.parse('{"id":"components-of-ditsmod-app/decorators-and-reflector","title":"Decorators and Reflector","description":"decorators-and-reflector}","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/00-components-of-ditsmod-app/00-decorators-and-reflector.md","sourceDirName":"00-components-of-ditsmod-app","slug":"/components-of-ditsmod-app/decorators-and-reflector","permalink":"/en/components-of-ditsmod-app/decorators-and-reflector","draft":false,"unlisted":false,"editUrl":"https://github.com/ditsmod/ditsmod/edit/main/website/i18n/en/docusaurus-plugin-content-docs/current/00-components-of-ditsmod-app/00-decorators-and-reflector.md","tags":[],"version":"current","sidebarPosition":0,"frontMatter":{"sidebar_position":0},"sidebar":"tutorialSidebar","previous":{"title":"What is Ditsmod","permalink":"/en/"},"next":{"title":"Dependency Injection","permalink":"/en/components-of-ditsmod-app/dependency-injection"}}');var r=n(4848),s=n(8453);const i={sidebar_position:0},o="Decorators and Reflector {#decorators-and-reflector}",a={},d=[];function l(e){const t={a:"a",code:"code",h1:"h1",header:"header",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"decorators-and-reflector",children:"Decorators and Reflector"})}),"\n",(0,r.jsx)(t.p,{children:"Let's start with the obvious \u2014 TypeScript syntax is slightly different from JavaScript syntax because it has static typing capabilities. JavaScript does not have static typing at all, but during the compilation of TypeScript code into JavaScript, the compiler can provide additional JavaScript code that can be used to obtain information about static types."}),"\n",(0,r.jsxs)(t.p,{children:["Let's experiment a bit. Create a file ",(0,r.jsx)(t.code,{children:"src/app/services.ts"})," in ",(0,r.jsx)(t.a,{href:"../../#installation",children:"ditsmod/rest-starter"})," and insert the following code:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"class Service1 {}\n\nclass Service2 {\n  constructor(service1: Service1) {}\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["As you can see, in the constructor of ",(0,r.jsx)(t.code,{children:"Service2"}),", a static data type is specified for the ",(0,r.jsx)(t.code,{children:"service1"})," parameter. If you run the command:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:"npm run build\n"})}),"\n",(0,r.jsxs)(t.p,{children:["TypeScript code will be compiled and placed into the ",(0,r.jsx)(t.code,{children:"dist/app/services.js"})," file. It will look like this:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"class Service1 {\n}\nclass Service2 {\n    constructor(service1) { }\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["That is, the information about the parameter type in the ",(0,r.jsx)(t.code,{children:"Service2"})," constructor is lost. But if we use a class decorator, the TypeScript compiler will output more JavaScript code containing information about static typing. For example, let\u2019s use the ",(0,r.jsx)(t.code,{children:"injectable"})," decorator:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",metastring:"{1,5}",children:"import { injectable } from '@ditsmod/core';\n\nclass Service1 {}\n\n@injectable()\nclass Service2 {\n  constructor(service1: Service1) {}\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Now, using the ",(0,r.jsx)(t.code,{children:"npm run build"})," command, the TypeScript compiler converts this code into the following JavaScript code and inserts it into ",(0,r.jsx)(t.code,{children:"dist/app/services.js"}),":"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",metastring:"{18}",children:'var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);\n};\nimport { injectable } from \'@ditsmod/core\';\nclass Service1 {\n}\nlet Service2 = class Service2 {\n    constructor(service1) { }\n};\nService2 = __decorate([\n    injectable(),\n    __metadata("design:paramtypes", [Service1])\n], Service2);\n'})}),"\n",(0,r.jsxs)(t.p,{children:["Fortunately, you will rarely need to inspect the ",(0,r.jsx)(t.code,{children:"dist"})," folder and analyze compiled code, but it can sometimes be useful to glance at it for a general understanding of how static typing is transferred into JavaScript code. The most interesting part is found in the last four lines. It\u2019s clear that the TypeScript compiler now associates the array ",(0,r.jsx)(t.code,{children:"[Service1]"})," with ",(0,r.jsx)(t.code,{children:"Service2"}),". This array contains information about the static parameter types detected by the compiler in the ",(0,r.jsx)(t.code,{children:"Service2"})," constructor."]}),"\n",(0,r.jsxs)(t.p,{children:["Further analysis of the compiled code shows that the ",(0,r.jsx)(t.code,{children:"Reflect"})," class is used to store metadata with static typing. This class is assumed to be imported from the ",(0,r.jsx)(t.a,{href:"https://github.com/ditsmod/ditsmod/blob/core-2.54.0/packages/core/package.json#L53",children:"reflect-metadata"})," library. The API of this library is then used by Ditsmod to read the above metadata. This process is handled by the so-called ",(0,r.jsx)(t.strong,{children:"reflector"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["Let\u2019s see what tools Ditsmod provides for working with the reflector. Let\u2019s make the previous example more complex to see how metadata can be extracted and how complex dependency chains can be formed. Consider three classes with the following dependency: ",(0,r.jsx)(t.code,{children:"Service3"})," -> ",(0,r.jsx)(t.code,{children:"Service2"})," -> ",(0,r.jsx)(t.code,{children:"Service1"}),". Insert the following code into ",(0,r.jsx)(t.code,{children:"src/app/services.ts"}),":"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"import { injectable, getDependencies } from '@ditsmod/core';\n\nclass Service1 {}\n\n@injectable()\nclass Service2 {\n  constructor(service1: Service1) {}\n}\n\n@injectable()\nclass Service3 {\n  constructor(service2: Service2) {}\n}\n\nconsole.log(getDependencies(Service3)); // [ { token: [class Service2], required: true } ]\n"})}),"\n",(0,r.jsx)(t.p,{children:"This code can be compiled and executed with the following command:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:"tput reset && npm run build && node dist/app/services.js\n"})}),"\n",(0,r.jsxs)(t.p,{children:["In the previous example, the ",(0,r.jsx)(t.code,{children:"getDependencies()"})," function uses the reflector and returns an array of direct dependencies of ",(0,r.jsx)(t.code,{children:"Service3"}),". You might guess that by passing ",(0,r.jsx)(t.code,{children:"Service2"})," to ",(0,r.jsx)(t.code,{children:"getDependencies()"}),", we\u2019ll see the dependency on ",(0,r.jsx)(t.code,{children:"Service1"}),". This way, you can ",(0,r.jsx)(t.strong,{children:"automatically"})," build the entire dependency chain ",(0,r.jsx)(t.code,{children:"Service3"})," -> ",(0,r.jsx)(t.code,{children:"Service2"})," -> ",(0,r.jsx)(t.code,{children:"Service1"}),". This process in DI is called \u201cdependency resolution.\u201d And here the word \u201cautomatically\u201d is intentionally bolded because it is a very important feature supported by DI. Users only pass ",(0,r.jsx)(t.code,{children:"Service3"})," to DI, and they don\u2019t need to manually explore what this class depends on \u2014 DI can resolve the dependency automatically. By the way, users will rarely need to use the ",(0,r.jsx)(t.code,{children:"getDependencies()"})," function, except in a few rare cases."]}),"\n",(0,r.jsx)(t.p,{children:'Strictly speaking, the mechanism of storing and retrieving metadata from the reflector using decorators is not yet Dependency Injection. However, Dependency Injection extensively uses decorators and the reflector in its operation, so in this documentation, you might sometimes see that DI "obtains information about class dependencies" although in reality, it\u2019s the reflector that does this.'}),"\n",(0,r.jsx)(t.p,{children:"To have the code automatically execute after every change, you can use two terminals. In the first terminal, you can run the command to compile the code:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:"npm run build -- --watch\n"})}),"\n",(0,r.jsx)(t.p,{children:"And in the second terminal, you can run the command to execute the compiled code:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:"node --watch dist/app/services.js\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Now, if in ",(0,r.jsx)(t.code,{children:"src/app/services.ts"})," you pass ",(0,r.jsx)(t.code,{children:"Service1"})," to the ",(0,r.jsx)(t.code,{children:"getDependencies()"})," function, after a few seconds, you should see the output ",(0,r.jsx)(t.code,{children:"[ { token: [class Service1], required: true } ]"})," in the second terminal."]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>o});var c=n(6540);const r={},s=c.createContext(r);function i(e){const t=c.useContext(s);return c.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),c.createElement(s.Provider,{value:t},e.children)}}}]);