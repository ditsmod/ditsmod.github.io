<!doctype html>
<html lang="uk" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-components-of-ditsmod-app/dependency-injection" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.1.1">
<title data-rh="true">Dependency Injection | Ditsmod</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://ditsmod.github.io/components-of-ditsmod-app/dependency-injection/"><meta data-rh="true" property="og:locale" content="uk"><meta data-rh="true" property="og:locale:alternate" content="en"><meta data-rh="true" name="docusaurus_locale" content="uk"><meta data-rh="true" name="docsearch:language" content="uk"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Dependency Injection | Ditsmod"><meta data-rh="true" name="description" content="Для чого потрібен DI?"><meta data-rh="true" property="og:description" content="Для чого потрібен DI?"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://ditsmod.github.io/components-of-ditsmod-app/dependency-injection/"><link data-rh="true" rel="alternate" href="https://ditsmod.github.io/en/components-of-ditsmod-app/dependency-injection/" hreflang="en"><link data-rh="true" rel="alternate" href="https://ditsmod.github.io/components-of-ditsmod-app/dependency-injection/" hreflang="uk"><link data-rh="true" rel="alternate" href="https://ditsmod.github.io/components-of-ditsmod-app/dependency-injection/" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://KXSV6YPHSY-dsn.algolia.net" crossorigin="anonymous"><link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-JB9Z2HZH02"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-JB9Z2HZH02",{})</script>


<link rel="search" type="application/opensearchdescription+xml" title="Ditsmod" href="/opensearch.xml"><link rel="stylesheet" href="/assets/css/styles.5e447fbd.css">
<script src="/assets/js/runtime~main.576358cc.js" defer="defer"></script>
<script src="/assets/js/main.4bcd0cad.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Перейти до основного вмісту"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Перейти до основного вмісту</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="Ditsmod Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.svg" alt="Ditsmod Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div></a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/ditsmod/ditsmod" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link header-github-link" aria-label="GitHub repository"></a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link"><svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true" class="iconLanguage_nlXk"><path fill="currentColor" d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"></path></svg>Українська</a><ul class="dropdown__menu"><li><a href="/en/components-of-ditsmod-app/dependency-injection/" target="_self" rel="noopener noreferrer" class="dropdown__link" lang="en">English</a></li><li><a href="/components-of-ditsmod-app/dependency-injection/" target="_self" rel="noopener noreferrer" class="dropdown__link dropdown__link--active" lang="uk">Українська</a></li></ul></div><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Перемикання між темним та світлим режимом (зараз використовується Світлий режим)" aria-label="Перемикання між темним та світлим режимом (зараз використовується Світлий режим)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"><button type="button" class="DocSearch DocSearch-Button" aria-label="Пошук"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20" aria-hidden="true"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Пошук</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Прокрутити до початку" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/">Що таке Ditsmod</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/components-of-ditsmod-app/module/">Складові Ditsmod-застосунку</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/components-of-ditsmod-app/module/">Модулі</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/components-of-ditsmod-app/controllers-and-services/">Роутер, контролери та сервіси</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/components-of-ditsmod-app/dependency-injection/">Dependency Injection</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/components-of-ditsmod-app/http-interceptors/">HTTP Інтерсептори</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/components-of-ditsmod-app/guards/">Ґарди (охоронці)</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/components-of-ditsmod-app/extensions/">Розширення</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/components-of-ditsmod-app/logger/">Logger</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/components-of-ditsmod-app/log-mediator/">LogMediator</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/components-of-ditsmod-app/http-error-handler/">HttpErrorHandler</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/components-of-ditsmod-app/module-manager/">ModuleManager</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/developer-guides/exports-and-imports/">Гайди розробника</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/native-modules/routing/">Рідні Ditsmod-модулі</a></div></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Навігаційний ланцюжок поточної сторінки"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Головна сторінка" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">Складові Ditsmod-застосунку</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Dependency Injection</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">Зміст цієї сторінки</button></div><div class="theme-doc-markdown markdown"><h1 id="dependency-injection">Dependency Injection</h1>
<h2 id="для-чого-потрібен-di">Для чого потрібен DI?</h2>
<p>Давайте спочатку ознайомимось із загальною картиною роботи <a href="https://uk.wikipedia.org/wiki/%D0%92%D0%BF%D1%80%D0%BE%D0%B2%D0%B0%D0%B4%D0%B6%D0%B5%D0%BD%D0%BD%D1%8F_%D0%B7%D0%B0%D0%BB%D0%B5%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B5%D0%B9">Dependency Injection</a> (або просто DI), а потім в деталях розглянемо кожен важливий її компонент окремо.</p>
<p>Мабуть найпростіше зрозуміти, що саме робить DI, на прикладах. В даному разі нам потрібен інстанс класу <code>Service3</code> та його метод <code>doSomething()</code>:</p>
<pre><code class="language-ts" metastring="title=&#x27;./services.ts&#x27;">export class Service1 {}

export class Service2 {
  constructor(private service1: Service1) {}
  // ...
  // Використання this.service1 у якомусь із методів.
}

export class Service3 {
  constructor(private service2: Service2) {}

  doSomething(param1: any) {
    // Використання this.service2 у даному методі.
  }
}

export function getService3() {
  const service1 = new Service1();
  const service2 = new Service2(service1);
  return new Service3(service2);
}
</code></pre>
<p>Як бачите, <code>Service3</code> залежить від <code>Service2</code>, який, у свою чергу, залежить від <code>Service1</code>. Покищо інстанс <code>Service3</code> отримати досить просто:</p>
<pre><code class="language-ts" metastring="{5} title=&#x27;./some.service.ts&#x27;">import { getService3 } from &#x27;./services.js&#x27;;

export class SomeService {
  method1() {
    const service3 = getService3();
    service3.doSomething(123);
  }
}
</code></pre>
<p>У функції <code>getService3</code> захардкоджено створення інстансу <code>Service3</code>, і це є проблемою, тому що писати юніт-тести для цієї функції проблематично, особливо в контексті EcmaScript Module, оскільки ви не зможете підмінити <code>Service1</code> та <code>Service2</code> моками. Ще один серйозний мінус функції <code>getService3</code> в тому, що в реальному застосунку вона може стати досить складною через потребу враховувати конфігурацію кожної із залежностей. Тобто, наприклад, в одному випадку в тілі <code>getService3</code> може очікуватись, що вона буде створювати кожен раз нові інстанси <code>Service1</code> та <code>Service2</code>, в другому випадку - потрібно щоб вони були <a href="https://uk.wikipedia.org/wiki/%D0%9E%D0%B4%D0%B8%D0%BD%D0%B0%D0%BA_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F)" title="Singleton">одинаками</a> для усього застосунку, а в третьому - що тільки один із них повинен бути одинаком...</p>
<p>Наступний  приклад майже не відрізняється від попереднього прикладу, де ми також оголошували клас <code>Service3</code>, але тут ми дописали декоратор <code>injectable</code> над кожним класом, який має конструктор з параметрами, і не стали створювати функцію <code>getService3</code>:</p>
<pre><code class="language-ts" metastring="{5,12} title=&#x27;./services.ts&#x27;">import { injectable } from &#x27;@ditsmod/core&#x27;;

export class Service1 {}

@injectable()
export class Service2 {
  constructor(private service1: Service1) {}
  // ...
  // Використання this.service1 у якомусь із методів.
}

@injectable()
export class Service3 {
  constructor(private service2: Service2) {}

  doSomething(param1: any) {
    // Використання this.service2 у даному методі.
  }
}
</code></pre>
<p>Покищо можна і не знати що саме робить декоратор <code>injectable</code>, зараз важливіше дізнатись, як тепер ми можемо запитувати інстанс <code>Service3</code> у будь-якому місці нашої програми:</p>
<pre><code class="language-ts" metastring="{4,6,9} title=&#x27;./some.service.ts&#x27;">import { injectable } from &#x27;@ditsmod/core&#x27;;
import { Service3 } from &#x27;./services.js&#x27;;

@injectable()
export class SomeService {
  constructor(private service3: Service3) {}

  method1() {
    this.service3.doSomething(123);
  }
}
</code></pre>
<p>Як бачите, ми більше не створюємо інстансу <code>Service3</code> за допомогою оператора <code>new</code>, натомість цим займається DI і передає у конструктор готовий інстанс. Навіть якщо згодом у конструкторі <code>Service3</code> параметри будуть змінюватись, нічого не прийдеться змінювати у тих місцях, де використовується <code>Service3</code>.</p>
<p>Щоправда, щоб DI зміг створити інстанс класу <code>Service3</code>, до реєстру DI потрібно передати усі необхідні класи в масиві (про це буде йти мова пізніше). DI має змогу проглядати параметри конструкторів кожного з цих класів, тому він може створювати та автоматично підставляти відповідні інстанси класів.</p>
<h2 id="магія-роботи-з-метаданими">&quot;Магія&quot; роботи з метаданими</h2>
<p>З точки зору JavaScript-розробника, в тому, що DI якимось чином може проглядати параметри конструкторів класів і бачити там інші класи - це можна назвати &quot;магією&quot;. Якщо проглянути репозиторій <code>@ditsmod/core</code>, можна побачити що:</p>
<ol>
<li>у файлі <code>tsconfig.json</code> вказано <a href="https://github.com/ditsmod/ditsmod/blob/core-2.51.1/packages/core/tsconfig.json#L30">&quot;emitDecoratorMetadata&quot;: true</a>;</li>
<li>у файлі <code>package.json</code> вказано залежність від бібліотеки <a href="https://github.com/ditsmod/ditsmod/blob/core-2.51.1/packages/core/package.json#L52">reflect-metadata</a>;</li>
<li>є цілий ряд декоратораторів (<code>rootModule</code>, <code>featureModule</code>, <code>controller</code>, <code>injectable</code>...).</li>
</ol>
<p>Усі ці складові якраз і забезпечують &quot;магію&quot; зчитування та збереження метаданих, які ви прописуєте у своїх класах за допомогою декораторів. Вам можна глибоко і не розбиратись як саме працює ця &quot;магія&quot;, але варто пам&#x27;ятати хоча б які саме складові вона має.</p>
<p>Варто також зазначити, що Ditsmod не використовує <a href="https://github.com/tc39/proposal-decorators">нові декоратори</a>, оскільки вони покищо не мають API для роботи з параметрами методів.</p>
<h2 id="залежність">Залежність</h2>
<p>Якщо для створення інстанса даного класа вам потрібно спочатку створити інстанси інших класів - значить даний клас має залежності. Наприклад, якщо в конструкторі сервісу ви прописуєте ось таке:</p>
<pre><code class="language-ts" metastring="{6}">import { injectable } from &#x27;@ditsmod/core&#x27;;
import { FirstService } from &#x27;./first.service.js&#x27;;

@injectable()
export class SecondService {
  constructor(private firstService: FirstService) {}
  // ...
}
</code></pre>
<p>це означає, що <code>SecondService</code> має залежність від <code>FirstService</code>, і очікується що DI вирішить цю залежність наступним чином:</p>
<ol>
<li>спочатку DI прогляне конструктор <code>FirstService</code>;</li>
<li>якщо у <code>FirstService</code> немає залежності, буде створено інстанс <code>FirstService</code>;</li>
<li>інстанс <code>FirstService</code> буде передано в конструктор <code>SecondService</code>.</li>
</ol>
<p>Якщо після виконання першого пункту виясниться, що <code>FirstService</code> має свої власні залежності, то DI буде рекурсивно виконувати ці три пункти для кожної даної залежності.</p>
<p>Якщо ви забудете написати (або навмисно видалите) декоратор <code>injectable</code> перед класом, що має залежності в конструкторі, DI кине помилку про те, що він не може вирішити залежність даного класа. Це відбувається через те, що <code>injectable</code> бере участь у зчитуванні та збереженні метаданих класу.</p>
<h3 id="опціональна-залежність">Опціональна залежність</h3>
<p>Інколи вам може знадобитись вказати опціональну (необов&#x27;язкову) залежність в конструкторі. Давайте розглянемо наступний приклад, де після властивості <code>firstService</code> поставлено знак питання, і таким чином вказано для TypeScript що ця властивість є опціональною:</p>
<pre><code class="language-ts" metastring="{6}">import { injectable } from &#x27;@ditsmod/core&#x27;;
import { FirstService } from &#x27;./first.service.js&#x27;;

@injectable()
export class SecondService {
  constructor(private firstService?: FirstService) {}
  // ...
}
</code></pre>
<p>Але DI проігнорує цю опціональність і видасть помилку у разі відсутності можливості для створення <code>FirstService</code>. Щоб даний код працював, необхідно скористатись декоратором <code>optional</code>:</p>
<pre><code class="language-ts" metastring="{6}">import { injectable, optional } from &#x27;@ditsmod/core&#x27;;
import { FirstService } from &#x27;./first.service.js&#x27;;

@injectable()
export class SecondService {
  constructor(@optional() private firstService?: FirstService) {}
  // ...
}
</code></pre>
<h2 id="токен-залежності">Токен залежності</h2>
<p>У попередніх прикладах ви вже багато разів бачили токен залежності, але формально покищо ми його не представили. Давайте знову розглянемо попередній приклад:</p>
<pre><code class="language-ts" metastring="{6}">import { injectable } from &#x27;@ditsmod/core&#x27;;
import { FirstService } from &#x27;./first.service.js&#x27;;

@injectable()
export class SecondService {
  constructor(private firstService: FirstService) {}
  // ...
}
</code></pre>
<p>Тут мається на увазі, що <code>FirstService</code> є класом, і через це він може одночасно використовуватись і у якості TypeScript-типу, і у якості <strong>токену</strong>. По-суті, токен - це ідентифікатор, який асоціюється із відповідною залежністю. Дуже важливо розуміти, що сам механізм використання токенів потрібний для JavaScript-runtime, тому у якості токенів не можна використовувати такі типи, які у TypeScript-коді ми оголошуємо з ключовими словами <code>interface</code>, <code>type</code>, <code>enum</code> і т.п., бо їх не існує у JavaScript-коді.</p>
<p>На відміну від класу, масив не може одночасно використовуватись і у якості TypeScript-типу, і у якості токену. З іншого боку, токен може мати зовсім нерелевантний тип даних відносно залежності, з якою він асоціюється, тому, наприклад, рядковий тип токена може асоціюватись із залежністю, що має будь-який TypeScript-тип, включаючи масиви, інтерфейси, enum і т.д.</p>
<p>Передати токен можна у короткій або довгій формі вказання залежності. В останньому прикладі використовується <strong>коротка форма</strong> вказання залежності, вона має суттєві обмеження, бо таким чином можна вказати залежність лише від певного <em>класу</em>.</p>
<p>А ще існує <strong>довга форма</strong> вказання залежності за допомогою декоратора <code>inject</code>, вона дозволяє використовувати альтернативний токен:</p>
<pre><code class="language-ts" metastring="{6}">import { injectable, inject } from &#x27;@ditsmod/core&#x27;;
import { InterfaceOfItem } from &#x27;./types.js&#x27;;

@injectable()
export class SecondService {
  constructor(@inject(&#x27;some-string&#x27;) private someArray: InterfaceOfItem[]) {}
  // ...
}
</code></pre>
<p>Коли використовується <code>inject</code>, DI бере до уваги лише переданий в нього токен. В даному разі DI ігнорує тип змінної - <code>InterfaceOfItem[]</code>, використовуючи в якості токена текстовий рядок <code>some-string</code>. Таким чином, DI дає можливість розділяти токен та тип змінної, тому в конструкторі можна отримати будь-який тип залежності, в ключаючи різні типи масивів чи enum.</p>
<p>Токеном може бути референс на клас, об&#x27;єкт чи функцію, також у якості токену можна використовувати текстові та числові значення. Для довгої форми вказання залежностей, у якості токена рекомендуємо використовувати інстанс класу <code>InjectionToken&lt;T&gt;</code>, оскільки клас <code>InjectionToken&lt;T&gt;</code> має параметризований тип <code>T</code>, за допомогою якого можна вказати тип даних, який асоціюється з даним токеном:</p>
<pre><code class="language-ts" metastring="{5,14}">// tokens.ts
import { InjectionToken } from &#x27;@ditsmod/core&#x27;;
import { InterfaceOfItem } from &#x27;./types.js&#x27;;

const SOME_TOKEN = new InjectionToken&lt;InterfaceOfItem[]&gt;(&#x27;InterfaceOfItem&#x27;);

// second-service.ts
import { injectable, inject } from &#x27;@ditsmod/core&#x27;;
import { InterfaceOfItem } from &#x27;./types.js&#x27;;
import { SOME_TOKEN } from &#x27;./tokens.js&#x27;;

@injectable()
export class SecondService {
  constructor(@inject(SOME_TOKEN) private someArray: InterfaceOfItem[]) {}
  // ...
}
</code></pre>
<h2 id="провайдери">Провайдери</h2>
<p>У DI є реєстр, який по-суті є мапінгом між токеном та значенням, яке потрібно видавати для цього токена. Схематично цей реєстр можна показати так:</p>
<pre><code>токен1 -&gt; значення15
токен2 -&gt; значення100
...
</code></pre>
<p>Як можна здогадатись, при вирішенні залежності, DI братиме токени з параметрів конструктора певного класа, і шукатиме для них значення у реєстрі DI. Якщо усі необхідні токени у реєстрі знайшлись, значить їхні значення передаються у конструктор, і таким чином успішно вирішується залежність даного класа.</p>
<p>DI створює значення у реєстрі для кожного токена використовуючи так звані <strong>провайдери</strong>. Отже, щоб DI міг вирішити певну залежність, спочатку необхідно передати відповідний провайдер до реєстру DI, а потім DI буде видавати значення цього провайдера по його токену. Тому якщо ви вказали певну залежність у класі, але не передали відповідного провайдера, DI не зможе вирішити дану залежність. Про те, як саме можна передавати провайдери до DI, йдеться <a href="#%D0%BF%D0%B5%D1%80%D0%B5%D0%B4%D0%B0%D1%87%D0%B0-%D0%BF%D1%80%D0%BE%D0%B2%D0%B0%D0%B9%D0%B4%D0%B5%D1%80%D1%96%D0%B2-%D0%B2-%D1%80%D0%B5%D1%94%D1%81%D1%82%D1%80-di">в наступному розділі</a>. Провайдер може бути або класом, або об&#x27;єктом:</p>
<pre><code class="language-ts" metastring="{3-8}">import { Class } from &#x27;@ditsmod/core&#x27;;

type Provider = Class&lt;any&gt; |
{ token: any, useClass: Class&lt;any&gt;, multi?: boolean } |
{ token: any, useValue: any, multi?: boolean } |
{ token?: any, useFactory: (...args: any[]) =&gt; any, deps: any[], multi?: boolean } |
{ token?: any, useFactory: [Class&lt;any&gt;, Class&lt;any&gt;.prototype.methodName], multi?: boolean } |
{ token: any, useToken: any, multi?: boolean }
</code></pre>
<p>Зверніть увагу, що токен для провайдера з властивістю <code>useFactory</code> є опціональним, оскільки DI може використати функцію чи метод вказаного класу у якості токена.</p>
<p>Якщо провайдер представлено у вигляді об&#x27;єкта, у його властивості можуть передаватись наступні значення:</p>
<ul>
<li>
<p><code>useClass</code> - сюди передається клас, чий інстанс буде використано як значення цього провайдера. Приклад такого провайдера:</p>
<pre><code class="language-ts">{ token: &#x27;token1&#x27;, useClass: SomeService }
</code></pre>
</li>
<li>
<p><code>useValue</code> - сюди передається будь-яке значення, окрім <code>undefined</code>, DI його видаватиме без змін. Приклад такого провайдера:</p>
<pre><code class="language-ts">{ token: &#x27;token2&#x27;, useValue: &#x27;some value&#x27; }
</code></pre>
</li>
<li>
<p><code>useFactory</code> - сюди можна передавати аргументи у двох формах.</p>
<ul>
<li>
<p><strong>Перша форма</strong> (рекомендована, через свою кращу інкапсуляцію) передбачає, що до <code>useFactory</code> передається <a href="https://www.typescriptlang.org/docs/handbook/2/objects.html#tuple-types">tuple</a>, де на першому місці повинен бути клас, а на другому місці - метод цього класу, який повинен повернути якесь значення для вказаного токена. Наприклад, якщо клас буде таким:</p>
<pre><code class="language-ts">import { methodFactory } from &#x27;@ditsmod/core&#x27;;

export class ClassWithFactory {
  @methodFactory()
  method1(dependecy1: Dependecy1, dependecy2: Dependecy2) {
    // ...
    return &#x27;...&#x27;;
  }
}
</code></pre>
<p>В такому разі провайдер потрібно передавати до реєстру DI в наступному форматі:</p>
<pre><code class="language-ts">{ token: &#x27;token3&#x27;, useFactory: [ClassWithFactory, ClassWithFactory.prototype.method1] }
</code></pre>
<p>Спочатку DI створить інстанс цього класу, потім викличе його метод та отримає результат, який вже і буде асоціюватись з указаним токеном. Метод указаного класу може повертати будь-яке значення, окрім <code>undefined</code>.</p>
</li>
<li>
<p><strong>Друга форма</strong> передбачає, що до <code>useFactory</code> можна передавати функцію, яка може мати параметри - тобто може мати залежність. Цю залежність необхідно додатково вручну вказувати у властивості <code>deps</code> у вигляді масиву токенів, причому порядок передачі токенів важливий:</p>
<pre><code class="language-ts" metastring="{6}">function fn1(service1: Service1, service2: Service2) {
  // ...
  return &#x27;some value&#x27;;
}

{ token: &#x27;token3&#x27;, useFactory: fn1, deps: [Service1, Service2] }
</code></pre>
<p>Зверніть увагу, що у властивість <code>deps</code> передаються саме <em>токени</em> провайдерів, і DI їх сприймає саме як токени, а не як провайдери. Тобто для цих токенів до реєстру DI ще треба буде <a href="#%D0%BF%D0%B5%D1%80%D0%B5%D0%B4%D0%B0%D1%87%D0%B0-%D0%BF%D1%80%D0%BE%D0%B2%D0%B0%D0%B9%D0%B4%D0%B5%D1%80%D1%96%D0%B2-%D0%B2-%D1%80%D0%B5%D1%94%D1%81%D1%82%D1%80-di">передати відповідні провайдери</a>. Також зверніть увагу, що у <code>deps</code> не передаються декоратори для параметрів (зокрема такі як <code>fromSelf</code> та <code>skipSelf</code>). Якщо для вашої фабрики необхідні декоратори параметрів - вам потрібно скористатись першою формою передачі аргументів до <code>useFactory</code>.</p>
</li>
</ul>
</li>
<li>
<p><code>useToken</code> - в цю властивість провайдера передається інший токен. Якщо ви записуєте таке:</p>
<pre><code class="language-ts">{ token: SecondService, useToken: FirstService }
</code></pre>
<p>таким чином ви говорите DI: &quot;Коли споживачі провайдерів запитують токен <code>SecondService</code>, потрібно використати значення для токена <code>FirstService</code>&quot;. Іншими словами, ця директива робить аліас <code>SecondService</code>, який вказує на <code>FirstService</code>.</p>
</li>
</ul>
<p>Тепер, коли ви вже ознайомились з поняттям <strong>провайдер</strong>, можна уточнити, що під <strong>залежністю</strong> розуміють залежність саме від <strong>значення провайдера</strong>. Таку залежність мають <strong>споживачі</strong> значень провайдерів або в конструкторах сервісів, або в конструкторах чи методах контролерів, або в методі <code>get()</code> <a href="#%D1%96%D0%BD%D0%B6%D0%B5%D0%BA%D1%82%D0%BE%D1%80">інжекторів</a> (про це буде згадано пізніше).</p>
<h2 id="інжектор">Інжектор</h2>
<p>В описі провайдерів було згадано за <em>реєстри DI</em>, тепер давайте розберемось як формуються ці реєстри, і де саме вони знаходяться.</p>
<p>Якщо сильно спростити схему роботи DI, можна сказати що DI приймає масив провайдерів на вході, а на виході видає <strong>інжектор</strong>, який вміє створювати значення для кожного переданого провайдера. Тобто, реєстри DI формуються на основі масивів провайдерів, які передаються в інжектор:</p>
<pre><code class="language-ts" metastring="{15}">import { Injector, injectable } from &#x27;@ditsmod/core&#x27;;

class Service1 {}

@injectable()
class Service2 {
  constructor(service1: Service1) {}
}

@injectable()
class Service3 {
  constructor(service2: Service2) {}
}

const injector = Injector.resolveAndCreate([Service1, Service2, Service3]);
const service3 = injector.get(Service3);
service3 === injector.get(Service3); // true
service3 === injector.resolveAndInstantiate(Service3); // false
</code></pre>
<p>Як бачите, метод <code>Injector.resolveAndCreate()</code> на вході приймає масив провайдерів, а на виході видає інжектор, який вміє видавати значення кожного провайдера по його токену за допомогою методу <code>injector.get()</code>, з урахуванням усього ланцюжка залежностей (<code>Service3</code> -&gt; <code>Service2</code> -&gt; <code>Service1</code>).</p>
<p>Що робить <code>injector.get()</code>:</p>
<ul>
<li>коли у нього запитують <code>Service3</code>, він проглядає конструктор цього класу, бачить залежність від <code>Service2</code>;</li>
<li>потім проглядає конструктор у <code>Service2</code>, бачить залежність від <code>Service1</code>;</li>
<li>потім проглядає конструктор у <code>Service1</code>, не знаходить там залежності, і тому першим створює інстанс <code>Service1</code>;</li>
<li>потім створює інстанс <code>Service2</code> використовуючи інстанс <code>Service1</code>;</li>
<li>і останнім створює інстанс <code>Service3</code> використовуючи інстанс <code>Service2</code>;</li>
<li>якщо пізніше будуть запитувати повторно інстанс <code>Service3</code>, метод <code>injector.get()</code> буде повертати раніше створений інстанс <code>Service3</code> з кешу даного інжектора.</li>
</ul>
<p>Інколи останній пункт (коли інстанс <code>Service3</code> повертається з кешу інжектора), є небажаним. В такому разі ви можете скористатись методом <code>injector.resolveAndInstantiate()</code>, який приймає провайдер, резолвить його в контексті поточного інжектора, і кожен раз повертає новий інстанс даного провайдера.</p>
<p>Під час автоматичного вирішення залежності класу (коли інжектор не використовується напряму), Ditsmod під капотом використовує метод <code>injector.get()</code>.</p>
<p>Використовуючи DI, вам можна і не знати весь ланцюжок залежностей <code>Service3</code>, довірте цю роботу  інжектору, головне - передайте в реєстр DI усі необхідні класи. Майте на увазі, що таким чином можна писати unit-тести для окремо-взятих класів.</p>
<h2 id="ієрархія-інжекторів">Ієрархія інжекторів</h2>
<p>DI дозволяє створювати ще й ієрархію інжекторів - це коли є батьківські та дочірні інжектори. На перший погляд, немає нічого цікавого у такій ієрархії, бо не зрозуміло для чого вона потрібна, але у Ditsmod ця можливість використовується якраз дуже часто, оскільки вона дозволяє робити архітектуру застосунку модульною. Вивченню специфіки ієрархії варто приділити особливу увагу, це в майбутньому збереже вам не одну годину часу, бо ви знатимете як воно працює і чому воно не знаходить цієї залежності...</p>
<p>При створенні ієрархії, зв&#x27;язок утримує лише дочірній інжектор, він має об&#x27;єкт батьківського інжектора. В той же час, батьківський інжектор нічого не знає про свої дочірні інжектори. Тобто зв&#x27;язок між інжекторами в ієрархії є одностороннім. Умовно, це виглядає наступним чином:</p>
<pre><code class="language-ts" metastring="{6}">interface Parent {
  // Тут є певні властивості батьківського інжектора, але немає дочірнього інжектора
}

interface Child {
  parent: Parent;
  // Тут існують інші властивості дочірного інжектора.
}
</code></pre>
<p>Завдяки наявності об&#x27;єкта батьківського інжектора, дочірній інжектор може звертатись до батьківського інжектора, коли у нього запитують значення провайдера, якого у нього немає.</p>
<p>Давайте розглянемо наступний приклад. Для спрощення, тут взагалі не використовуються декоратори, оскільки кожен клас є незалежним:</p>
<pre><code class="language-ts" metastring="{8-9}">import { Injector } from &#x27;@ditsmod/core&#x27;;

class Service1 {}
class Service2 {}
class Service3 {}
class Service4 {}

const parent = Injector.resolveAndCreate([Service1, Service2]); // Батьківський інжектор
const child = parent.resolveAndCreateChild([Service2, Service3]); // Дочірній інжектор

child.get(Service1); // ОК
parent.get(Service1); // ОК

parent.get(Service1) === child.get(Service1); // true

child.get(Service2); // ОК
parent.get(Service2); // ОК

parent.get(Service2) === child.get(Service2); // false

child.get(Service3); // ОК
parent.get(Service3); // Error - No provider for Service3!

child.get(Service4); // Error - No provider for Service4!
parent.get(Service4); // Error - No provider for Service4!
</code></pre>
<p>Як бачите, при створенні дочірнього інжектора, йому не передали <code>Service1</code>, тому при запиті інстансу цього класу він звернеться до батька. До речі, тут є один неочевидний, але дуже важливий момент: через метод <code>get()</code> дочірні інжектори тільки запитують у батьківських інжекторів певні інстанси класів, а самостійно вони їх не створюють. Саме тому цей вираз повертає <code>true</code>:</p>
<pre><code class="language-ts">parent.get(Service1) === child.get(Service1); // true
</code></pre>
<p>А <code>Service2</code> є в обох інжекторах, тому кожен із них створить свою локальну версію цього сервіса, і саме через це даний вираз повертає <code>false</code>:</p>
<pre><code class="language-ts">parent.get(Service2) === child.get(Service2); // false
</code></pre>
<p>Батьківський інжектор не може створити інстансу класу <code>Service3</code> через те, що батьківський інжектор не має зв&#x27;язку з дочірнім інжектором, в якому є <code>Service3</code>.</p>
<p>Ну і обидва інжектори не можуть видати інстансу <code>Service4</code>, бо їм не передали цього класу при їхньому створенні.</p>
<h3 id="ієрархія-інжекторів-в-застосунку-ditsmod">Ієрархія інжекторів в застосунку Ditsmod</h3>
<p>Раніше в документації ви зустрічали наступні властивості об&#x27;єкта, які передаються через метадані  модуля або контролера:</p>
<ul>
<li><code>providersPerApp</code> - провайдери на рівні застосунку;</li>
<li><code>providersPerMod</code> - провайдери на рівні модуля;</li>
<li><code>providersPerRou</code> - провайдери на рівні роута;</li>
<li><code>providersPerReq</code> - провайдери на рівні HTTP-запиту.</li>
</ul>
<p>Використовуючи ці масиви, Ditsmod формує різні інжектори, що пов&#x27;язані між собою ієрархічним зв&#x27;язком. Таку ієрархію можна зімітувати наступним чином:</p>
<pre><code class="language-ts">import { Injector } from &#x27;@ditsmod/core&#x27;;

const providersPerApp = [];
const providersPerMod = [];
const providersPerRou = [];
const providersPerReq = [];

const injectorPerApp = Injector.resolveAndCreate(providersPerApp);
const injectorPerMod = injectorPerApp.resolveAndCreateChild(providersPerMod);
const injectorPerRou = injectorPerMod.resolveAndCreateChild(providersPerRou);
const injectorPerReq = injectorPerRou.resolveAndCreateChild(providersPerReq);
</code></pre>
<p>Під капотом, Ditsmod робить аналогічну процедуру багато разів для різних модулів, роутів та запитів. Наприклад, якщо застосунок Ditsmod має два модулі, і десять роутів, відповідно буде створено один інжектор на рівні застосунку, по одному інжектору для кожного модуля (2 шт.), по одному інжектору для кожного роуту (10 шт.), і по одному інжектору на кожен запит. Інжектори на рівні запиту видаляються автоматично кожен раз після завершення обробки запиту.</p>
<p>Нагадаємо, що вищі в ієрархії інжектори не мають доступу до нижчих в ієрархії інжекторів. Це означає, що <strong>при передачі класу у певний інжектор, потрібно враховувати мінімальний рівень ієрархії його залежностей</strong>.</p>
<p>Наприклад, якщо ви напишете клас, що має залежність від HTTP-запиту, ви зможете його передати тільки у масив <code>providersPerReq</code>, бо тільки з цього масиву формується інжектор, до якого Ditsmod буде автоматично додавати провайдер з об&#x27;єктом HTTP-запиту. З іншого боку, інстанс цього класу матиме доступ до усіх своїх батьківських інжекторів: на рівні роуту, модуля, та застосунку. Тому даний клас може залежати від провайдерів на будь-якому рівні.</p>
<p>Також ви можете написати певний клас і передати його в масив <code>providersPerMod</code>, в такому разі він може залежати тільки від провайдерів на рівні модуля, або на рівні застосунку. Якщо він буде залежати від провайдерів, які ви передали в масив <code>providersPerRou</code> чи <code>providersPerReq</code>, ви отримаєте помилку про те, що ці провайдери не знайдені.</p>
<h3 id="ієрархія-інжекторів-контролера">Ієрархія інжекторів контролера</h3>
<p>Будь-який контролер <a href="/components-of-ditsmod-app/controllers-and-services/#%D1%89%D0%BE-%D1%8F%D0%B2%D0%BB%D1%8F%D1%94-%D1%81%D0%BE%D0%B1%D0%BE%D1%8E-%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D0%B5%D1%80" title="Singleton">неодинак</a>, окрім свого власного інжектора на рівні запиту, має ще й три батьківські інжектори: на рівні роута, модуля та застосунка. Ці інжектори також формуються на основі провайдерів, які ви передаєте в наступні масиви:</p>
<ul>
<li><code>providersPerApp</code>;</li>
<li><code>providersPerMod</code>;</li>
<li><code>providersPerRou</code>;</li>
<li><code>providersPerReq</code> (це масив, з якого формується інжектор для контролера неодинака).</li>
</ul>
<p>Тобто контролер неодинак може залежати від сервісів на будь-якому рівні.</p>
<p>Якщо ж контролер є <a href="/components-of-ditsmod-app/controllers-and-services/#%D1%89%D0%BE-%D1%8F%D0%B2%D0%BB%D1%8F%D1%94-%D1%81%D0%BE%D0%B1%D0%BE%D1%8E-%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D0%B5%D1%80" title="Singleton">одинаком</a>, його власний інжектор знаходиться на рівні модуля, і він має один батьківський інжектор на рівні застосунку:</p>
<ul>
<li><code>providersPerApp</code>;</li>
<li><code>providersPerMod</code> (це масив, з якого формується інжектор для контролера одинака).</li>
</ul>
<h3 id="ієрархія-інжекторів-сервіса">Ієрархія інжекторів сервіса</h3>
<p>На відміну від контролера, інжектор певного сервіса може бути на будь-якому рівні: на рівні застосунку, модуля, роуту, чи запиту. На практиці це означає, що провайдер для даного сервіса передається в один (або в декілька) із вищезазначених масивів. Наприклад, в наступному прикладі <code>SomeService</code> передається в інжектор на рівні роуту, а <code>OtherService</code> - на рівні модуля:</p>
<pre><code class="language-ts" metastring="{5-6}">import { Injector } from &#x27;@ditsmod/core&#x27;;
// ...

const providersPerApp = [];
const providersPerMod = [OtherService];
const providersPerRou = [SomeService];
const providersPerReq = [];

const injectorPerApp = Injector.resolveAndCreate(providersPerApp);
const injectorPerMod = injectorPerApp.resolveAndCreateChild(providersPerMod);
const injectorPerRou = injectorPerMod.resolveAndCreateChild(providersPerRou);
const injectorPerReq = injectorPerRou.resolveAndCreateChild(providersPerReq);
</code></pre>
<p>В даному разі, якщо <code>SomeService</code> матиме залежність від <code>OtherService</code>, DI зможе створити інстанс <code>SomeService</code>, оскільки інжектор на рівні роуту може отримати інстанс <code>OtherService</code> від свого батьківського інжектора на рівні модуля. А от якщо навпаки - <code>OtherService</code> матиме залежність від <code>SomeService</code> - DI не зможе створити інстансу <code>OtherService</code>, оскільки інжектор на рівні модуля не бачить свого дочірнього інжектора на рівні роуту.</p>
<h3 id="поточний-інжектор">Поточний інжектор</h3>
<p>Безпосередньо сам інжектор сервіса чи контролера вам рідко може знадобиться, але ви його можете отримати у конструкторі як і значення будь-якого іншого провайдера:</p>
<pre><code class="language-ts" metastring="{6}">import { injectable, Injector } from &#x27;@ditsmod/core&#x27;;
import { FirstService } from &#x27;./first.service.js&#x27;;

@injectable()
export class SecondService {
  constructor(private injector: Injector) {}

  someMethod() {
    const firstService = this.injector.get(FirstService);  // Lazy loading of dependency
  }
}
</code></pre>
<p>Майте на увазі, що ви таким чином отримуєте інжектор, що створив інстанс даного сервіса. Рівень ієрархії цього інжектора залежить тільки від того, в реєстр якого інжектора передали <code>SecondService</code>.</p>
<h2 id="мульти-провайдери">Мульти-провайдери</h2>
<p>Цей вид провайдерів існує тільки у вигляді об&#x27;єкта, і він відрізняється від звичайних DI-провайдерів наявністю властивості <code>multi: true</code>. Такі провайдери доцільно використовувати, коли є потреба у передачі до DI зразу декількох провайдерів з однаковим токеном, щоб DI повернув таку саму кількість значень для цих провайдерів в одному масиві:</p>
<pre><code class="language-ts">import { Injector } from &#x27;@ditsmod/core&#x27;;
import { LOCAL } from &#x27;./tokens.js&#x27;;

const injector = Injector.resolveAndCreate([
  { token: LOCAL, useValue: &#x27;uk&#x27;, multi: true },
  { token: LOCAL, useValue: &#x27;en&#x27;, multi: true },
]);

const locals = injector.get(LOCAL); // [&#x27;uk&#x27;, &#x27;en&#x27;]
</code></pre>
<p>По-суті, мульти-провайдери дозволяють створювати групи провайдерів, що мають спільний токен. Ця можливість зокрема використовується для створення групи <code>HTTP_INTERCEPTORS</code>, а також для створення різних <a href="/components-of-ditsmod-app/extensions/#%D0%B3%D1%80%D1%83%D0%BF%D0%B8-%D1%80%D0%BE%D0%B7%D1%88%D0%B8%D1%80%D0%B5%D0%BD%D1%8C">груп розширень</a>.</p>
<p>Не допускається щоб в одному інжекторі однаковий токен мали і звичайні, і мульти-провайдери:</p>
<pre><code class="language-ts" metastring="{5-6}">import { Injector } from &#x27;@ditsmod/core&#x27;;
import { LOCAL } from &#x27;./tokens.js&#x27;;

const injector = Injector.resolveAndCreate([
  { token: LOCAL, useValue: &#x27;uk&#x27; },
  { token: LOCAL, useValue: &#x27;en&#x27;, multi: true },
]);

const locals = injector.get(LOCAL); // Error: Cannot mix multi providers and regular providers
</code></pre>
<p>Дочірні інжектори можуть повертати значення мульти-провайдерів батьківського інжектора, лише якщо при їх створенні їм не передавались провайдери з такими самими токенами:</p>
<pre><code class="language-ts">import { Injector } from &#x27;@ditsmod/core&#x27;;
import { LOCAL } from &#x27;./tokens.js&#x27;;

const parent = Injector.resolveAndCreate([
  { token: LOCAL, useValue: &#x27;uk&#x27;, multi: true },
  { token: LOCAL, useValue: &#x27;en&#x27;, multi: true },
]);

const child = parent.resolveAndCreateChild([]);

const locals = child.get(LOCAL); // [&#x27;uk&#x27;, &#x27;en&#x27;]
</code></pre>
<p>Якщо ж і в дочірнього, і в батьківського інжектора є мульти-провайдери з однаковим токеном, дочірній інжектор повертатиме знач ення лише зі свого масиву:</p>
<pre><code class="language-ts">import { Injector } from &#x27;@ditsmod/core&#x27;;
import { LOCAL } from &#x27;./tokens.js&#x27;;

const parent = Injector.resolveAndCreate([
  { token: LOCAL, useValue: &#x27;uk&#x27;, multi: true },
  { token: LOCAL, useValue: &#x27;en&#x27;, multi: true },
]);

const child = parent.resolveAndCreateChild([
  { token: LOCAL, useValue: &#x27;аа&#x27;, multi: true }
]);

const locals = child.get(LOCAL); // [&#x27;аа&#x27;]
</code></pre>
<h3 id="підміна-мультипровайдерів">Підміна мультипровайдерів</h3>
<p>Щоб стала можливою підміна конкретного мультипровайдера, можна зробити так:</p>
<ol>
<li>передайте певний клас в об&#x27;єкт мультипровайдера використовуючи властивість <code>useToken</code>;</li>
<li>потім даний клас передайте у якості звичайного провайдера;</li>
<li>наступним в масив провайдерів потрібно передати провайдер для підміни даного класу.</li>
</ol>
<pre><code class="language-ts">import { Injector } from &#x27;@ditsmod/core&#x27;;

import { HTTP_INTERCEPTORS } from &#x27;./constants.js&#x27;;
import { DefaultInterceptor } from &#x27;./default.interceptor.js&#x27;;
import { MyInterceptor } from &#x27;./my.interceptor.js&#x27;;

const injector = Injector.resolveAndCreate([
  { token: HTTP_INTERCEPTORS, useToken: DefaultInterceptor, multi: true },
  DefaultInterceptor,
  { token: DefaultInterceptor, useClass: MyInterceptor }
]);

const locals = injector.get(HTTP_INTERCEPTORS); // [MyInterceptor]
</code></pre>
<p>Така конструкція має сенс, наприклад, якщо перші два пункти виконуються десь у зовнішньому модулі, до якого у вас немає доступу на редагування, а третій пункт виконує вже користувач поточного модуля.</p>
<h2 id="передача-провайдерів-в-реєстр-di">Передача провайдерів в реєстр DI</h2>
<p>На одну залежність, в реєстр DI потрібно передавати один або декілька провайдерів. Частіше за все, провайдери передаються в реєстр DI через метадані модулів, хоча інколи вони передаються через метадані контролерів, або навіть напряму в <a href="#%D1%96%D0%BD%D0%B6%D0%B5%D0%BA%D1%82%D0%BE%D1%80">інжектори</a>. В наступному прикладі <code>SomeService</code> передається в масив <code>providersPerMod</code>:</p>
<pre><code class="language-ts" metastring="{9}">import { featureModule } from &#x27;@ditsmod/core&#x27;;

import { SomeService } from &#x27;./some.service.js&#x27;;
import { SomeController } from &#x27;./some.controller.js&#x27;;

@featureModule({
  controllers: [SomeController],
  providersPerMod: [
    SomeService
  ],
})
export class SomeModule {}
</code></pre>
<p>Після такої передачі, споживачі провайдерів можуть використовувати <code>SomeService</code> в межах <code>SomeModule</code>. Ідентичний результат буде, якщо ми цей же провайдер передамо у форматі об&#x27;єкта:</p>
<pre><code class="language-ts" metastring="{9}">import { featureModule } from &#x27;@ditsmod/core&#x27;;

import { SomeService } from &#x27;./some.service.js&#x27;;
import { SomeController } from &#x27;./some.controller.js&#x27;;

@featureModule({
  controllers: [SomeController],
  providersPerMod: [
    { token: SomeService, useClass: SomeService }
  ],
})
export class SomeModule {}
</code></pre>
<p>І тепер давайте додатково з цим же токеном передамо інший провайдер, але на цей раз у метадані контролера:</p>
<pre><code class="language-ts" metastring="{8}">import { controller } from &#x27;@ditsmod/core&#x27;;

import { SomeService } from &#x27;./some.service.js&#x27;;
import { OtherService } from &#x27;./other.service.js&#x27;;

@controller({
  providersPerReq: [
    { token: SomeService, useClass: OtherService }
  ]
})
export class SomeController {
  constructor(private someService: SomeService) {}
  // ...
}
</code></pre>
<p>Зверніть увагу на виділений рядок. Таким чином ми говоримо DI: &quot;Якщо даний контролер має залежність від провайдера з токеном <code>SomeService</code>, її потрібно підмінити інстансом класу <code>OtherService</code>&quot;. Ця підміна буде діяти тільки для даного контролера. Усі інші контролери в <code>SomeModule</code> по токену <code>SomeService</code> будуть отримувати інстанси класу <code>SomeService</code>.</p>
<p>Аналогічну підміну можна робити на рівні застосунку та на рівні модуля. Це інколи може знадобитись, наприклад коли ви хочете мати дефолтні значення конфігурації на рівні застосунку, але кастомні значення цієї конфігурації на рівні конкретного модуля. В такому разі передамо спочатку дефолтний конфіг в кореневому модулі:</p>
<pre><code class="language-ts" metastring="{6}">import { rootModule } from &#x27;@ditsmod/core&#x27;;
import { ConfigService } from &#x27;./config.service.js&#x27;;

@rootModule({
  providersPerApp: [
    ConfigService
  ],
})
export class AppModule {}
</code></pre>
<p>І вже у певному модулі підмінюємо <code>ConfigService</code> на довільне значення:</p>
<pre><code class="language-ts" metastring="{6}">import { featureModule } from &#x27;@ditsmod/core&#x27;;
import { ConfigService } from &#x27;./config.service.js&#x27;;

@featureModule({
  providersPerMod: [
    { token: ConfigService, useValue: { propery1: &#x27;some value&#x27; } }
  ],
})
export class SomeModule {}
</code></pre>
<h2 id="повторне-додавання-провайдерів">Повторне додавання провайдерів</h2>
<p>Різні провайдери з одним і тим самим токеном можна додавати багато разів в метадані модуля чи контролера, але DI вибере той із провайдерів, що додано останнім (виключення з цього правила є, але це стосується лише мульти-провайдерів):</p>
<pre><code class="language-ts">import { featureModule } from &#x27;@ditsmod/core&#x27;;

@featureModule({
  providersPerMod: [
    { token: &#x27;token1&#x27;, useValue: &#x27;value1&#x27; },
    { token: &#x27;token1&#x27;, useValue: &#x27;value2&#x27; },
    { token: &#x27;token1&#x27;, useValue: &#x27;value3&#x27; },
  ],
})
export class SomeModule {}
</code></pre>
<p>В даному разі, в межах <code>SomeModule</code> по <code>token1</code> буде видаватись <code>value3</code> на рівні модуля, роуту чи запиту.</p>
<p>Окрім цього, різні провайдери з одним і тим самим токеном можна передавати одночасно на декількох різних рівнях ієрархії, але DI завжди буде вибирати найближчі інжектори (тобто, якщ о значення для провайдера запитується на рівні запиту, то спочатку буде проглядатись інжектор на рівні запиту, і лише якщо там немає потрібного провайдера, DI буде підніматись до батьківських інжекторів):</p>
<pre><code class="language-ts">import { featureModule } from &#x27;@ditsmod/core&#x27;;

@featureModule({
  providersPerMod: [{ token: &#x27;token1&#x27;, useValue: &#x27;value1&#x27; }],
  providersPerRou: [{ token: &#x27;token1&#x27;, useValue: &#x27;value2&#x27; }],
  providersPerReq: [{ token: &#x27;token1&#x27;, useValue: &#x27;value3&#x27; }],
})
export class SomeModule {}
</code></pre>
<p>В даному разі, в межах <code>SomeModule</code> по <code>token1</code> буде видаватись <code>value3</code> на рівні запиту, <code>value2</code> - на рівні роуту, і <code>value1</code> - на рівні модуля.</p>
<p>Також, якщо ви імпортуєте певний провайдер із зовнішнього модуля, і у вас у поточному модулі є провайдер з таким же токеном, то локальний провайдер матиме вищій пріоритет, при умові, що вони передавались на однаковому рівні ієрархії інжекторів.</p>
<h2 id="редагування-значень-в-реєстрі-di">Редагування значень в реєстрі DI</h2>
<p>Як вже було сказано раніше, в реєстр DI передаються <em>провайдери</em>, з яких потім формуються <em>значення</em>, щоб в кінцевому результаті мати мапінг між токеном та його значенням:</p>
<pre><code>token1 -&gt; value15
token2 -&gt; value100
...
</code></pre>
<p>О крім цього, існує можливість редагування готових <em>значень</em> реєстра DI:</p>
<pre><code class="language-ts" metastring="{4}">import { Injector } from &#x27;@ditsmod/core&#x27;;

const injector = Injector.resolveAndCreate([{ token: &#x27;token1&#x27;, useValue: undefined }]);
injector.setByToken(&#x27;token1&#x27;, &#x27;value1&#x27;);
injector.get(&#x27;token1&#x27;); // value1
</code></pre>
<p>Зверніть увагу, що в даному разі до реєстру спочатку передається провайдер з <code>token1</code>, який має значення <code>undefined</code>, і лише потім ми змінюємо значення для даного токена. Якщо ви спробуєте редагувати значення для токена, якого у реєстрі немає, DI кине приблизно таку помилку:</p>
<pre><code class="language-text">DiError: Setting value by token failed: cannot find token in register: &quot;token1&quot;. Try adding a provider with the same token to the current injector via module or controller metadata.
</code></pre>
<p>У більшості випадків, редагування значень використовують <a href="/components-of-ditsmod-app/http-interceptors/">інтерсептори</a> або <a href="/components-of-ditsmod-app/guards/">гарди</a>, оскільки вони таким чином передають результат своєї роботи до реєстру:</p>
<ol>
<li><a href="https://github.com/ditsmod/ditsmod/blob/core-2.51.2/packages/body-parser/src/body-parser.interceptor.ts#L23">BodyParserInterceptor</a>;</li>
<li><a href="https://github.com/ditsmod/ditsmod/blob/core-2.51.2/examples/14-auth-jwt/src/app/modules/services/auth/bearer.guard.ts#L24">BearerGuard</a>.</li>
</ol>
<p>У якості альтернативи для методу <code>injector.setByToken()</code>, можна вико ристовувати еквівалентний вираз:</p>
<pre><code class="language-ts" metastring="{5}">import { KeyRegistry } from &#x27;@ditsmod/core&#x27;;

// ...
const { id } = KeyRegistry.get(&#x27;token1&#x27;);
injector.setById(id, &#x27;value1&#x27;);
// ...
</code></pre>
<p>Переваги використання методу <code>injector.setById()</code> в тому, що він швидший за метод <code>injector.setByToken()</code>, але лише при умові, якщо ви один раз отримуєте ID із <code>KeyRegistry</code>, а потім багато разів використовуєте <code>injector.setById()</code>.</p>
<h2 id="декоратори-fromself-та-skipself">Декоратори fromSelf та skipSelf</h2>
<p>Ці декоратори використовуються для управління поведінкою інжектора під час пошуку значень для певного токена. Вони мають сенс у випадку, коли існує певна ієрархія інжекторів.</p>
<h3 id="fromself">fromSelf</h3>
<p>Декоратор <code>fromSelf</code> використовується дуже рідко.</p>
<pre><code class="language-ts">import { injectable, fromSelf, Injector } from &#x27;@ditsmod/core&#x27;;

class Service1 {}

@injectable()
class Service2 {
  constructor(@fromSelf() public service1: Service1) {}
}

const parent = Injector.resolveAndCreate([Service1, Service2]);
const child = parent.resolveAndCreateChild([Service2]);

const service2 = parent.get(Service2) as Service2;
service2.service1 instanceof Service1; // true

child.get(Service2); // Error - Service1 not found
</code></pre>
<p>Як бачите, <code>Service2</code> залежить від <code>Service1</code>, причому декоратор <code>fromSelf</code> вказує DI: &quot;При створенні інстансу <code>Service1</code> використовувати тільки той самий інжектор, який створить інстанс <code>Service2</code>, а до батьківського інжектора не потрібно звертатись&quot;. Коли створюється батьківський інжектор, йому передають обидва необхідні сервіси, тому при запиті токену <code>Service2</code> він успішно вирішить залежність та видасть інстанс цього класу.</p>
<p>А ось при створенні дочірнього інжектора, йому не передали <code>Service1</code>, тому при запиті токену <code>Service2</code> він не зможе вирішити залежність цього сервісу. Якщо прибрати декоратор <code>fromSelf</code> з конструктора, то дочірній іжектор успішно вирішить залежність <code>Service2</code>.</p>
<h3 id="skipself">skipSelf</h3>
<p>Декоратор <code>skipSelf</code> використовується частіше, ніж <code>fromSelf</code>, але також рідко.</p>
<pre><code class="language-ts">import { injectable, skipSelf, Injector } from &#x27;@ditsmod/core&#x27;;

class Service1 {}

@injectable()
class Service2 {
  constructor(@skipSelf() public service1: Service1) {}
}

const parent = Injector.resolveAndCreate([Service1, Service2]);
const child = parent.resolveAndCreateChild([Service2]);

parent.get(Service2); // Error - Service1 not found

const service2 = child.get(Service2) as Service2;
service2.service1 instanceof Service1; // true
</code></pre>
<p>Як бачите, <code>Service2</code> залежить від <code>Service1</code>, причому декоратор <code>skipSelf</code> вказує DI: &quot;При створенні інстансу <code>Service1</code> пропустити той інжектор, який створить інстанс <code>Service2</code>, і зразу звертатись до батьківського інжектора&quot;. Коли створюється батьківський інжектор, йому передають обидва необхідні сервіси, але через <code>skipSelf</code> він не зможе звернутись до батьківського інжектора, бо його у нього немає. Тому батьківський інжектор не зможе вирішити залежність.</p>
<p>А при створенні дочірнього інжектора, йому не передали <code>Service1</code>, зате він може звернутись до батьківського інжектора за ним. Тому дочірній інжектор успішно вирішить залежність <code>Service2</code>.</p>
<h2 id="коли-di-не-може-знайти-потрібного-провайдера">Коли DI не може знайти потрібного провайдера</h2>
<p>Пам&#x27;ятайте, що коли DI не може знайти потрібного провайдера, існує всього три можливі причини:</p>
<ol>
<li>ви не передали потрібний провайдер до DI в метадані модуля чи контролера (ну або у випадку тестування - у <code>Injector.resolveAndCreate()</code>);</li>
<li>ви не імпортували модуль, де передається потрібний вам провайдер, або ж цей провайдер не експортується;</li>
<li>ви запитуєте у батьківському інжекторі провайдер з дочірнього інжектора.</li>
</ol></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/ditsmod/ditsmod/edit/main/website/docs/00-components-of-ditsmod-app/02-dependency-injection.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Відредагувати цю сторінку</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="сторінка документації"><a class="pagination-nav__link pagination-nav__link--prev" href="/components-of-ditsmod-app/controllers-and-services/"><div class="pagination-nav__sublabel">Попередня сторінка</div><div class="pagination-nav__label">Роутер, контролери та сервіси</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/components-of-ditsmod-app/http-interceptors/"><div class="pagination-nav__sublabel">Наступна сторінка</div><div class="pagination-nav__label">HTTP Інтерсептори</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#для-чого-потрібен-di" class="table-of-contents__link toc-highlight">Для чого потрібен DI?</a></li><li><a href="#магія-роботи-з-метаданими" class="table-of-contents__link toc-highlight">&quot;Магія&quot; роботи з метаданими</a></li><li><a href="#залежність" class="table-of-contents__link toc-highlight">Залежність</a><ul><li><a href="#опціональна-залежність" class="table-of-contents__link toc-highlight">Опціональна залежність</a></li></ul></li><li><a href="#токен-залежності" class="table-of-contents__link toc-highlight">Токен залежності</a></li><li><a href="#провайдери" class="table-of-contents__link toc-highlight">Провайдери</a></li><li><a href="#інжектор" class="table-of-contents__link toc-highlight">Інжектор</a></li><li><a href="#ієрархія-інжекторів" class="table-of-contents__link toc-highlight">Ієрархія інжекторів</a><ul><li><a href="#ієрархія-інжекторів-в-застосунку-ditsmod" class="table-of-contents__link toc-highlight">Ієрархія інжекторів в застосунку Ditsmod</a></li><li><a href="#ієрархія-інжекторів-контролера" class="table-of-contents__link toc-highlight">Ієрархія інжекторів контролера</a></li><li><a href="#ієрархія-інжекторів-сервіса" class="table-of-contents__link toc-highlight">Ієрархія інжекторів сервіса</a></li><li><a href="#поточний-інжектор" class="table-of-contents__link toc-highlight">Поточний інжектор</a></li></ul></li><li><a href="#мульти-провайдери" class="table-of-contents__link toc-highlight">Мульти-провайдери</a><ul><li><a href="#підміна-мультипровайдерів" class="table-of-contents__link toc-highlight">Підміна мультипровайдерів</a></li></ul></li><li><a href="#передача-провайдерів-в-реєстр-di" class="table-of-contents__link toc-highlight">Передача провайдерів в реєстр DI</a></li><li><a href="#повторне-додавання-провайдерів" class="table-of-contents__link toc-highlight">Повторне додавання провайдерів</a></li><li><a href="#редагування-значень-в-реєстрі-di" class="table-of-contents__link toc-highlight">Редагування значень в реєстрі DI</a></li><li><a href="#декоратори-fromself-та-skipself" class="table-of-contents__link toc-highlight">Декоратори fromSelf та skipSelf</a><ul><li><a href="#fromself" class="table-of-contents__link toc-highlight">fromSelf</a></li><li><a href="#skipself" class="table-of-contents__link toc-highlight">skipSelf</a></li></ul></li><li><a href="#коли-di-не-може-знайти-потрібного-провайдера" class="table-of-contents__link toc-highlight">Коли DI не може знайти потрібного провайдера</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/ditsmod" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/ditsmod" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/ditsmod/ditsmod" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>